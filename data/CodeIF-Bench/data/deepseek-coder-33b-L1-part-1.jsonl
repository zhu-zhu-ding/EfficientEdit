[
    {
        "prompt": "Write a python function called 'remove_occ' to remove first and last occurrence of a given character from the string.",
        "instruction": "The function should raise a ValueError with the message 'Second parameter must be a single character.' if the second parameter is not a single character.",
        "code_before": "def remove_occ(s, c):\n    first_occ = s.find(c)\n    last_occ = s.rfind(c)\n    if first_occ != -1 and last_occ != -1:\n        s = s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]\n    return s\n",
        "base_tests": [
            "assert remove_occ(\"hello\",\"l\") == \"heo\"",
            "assert remove_occ(\"abcda\",\"a\") == \"bcd\"",
            "assert remove_occ(\"PHP\",\"P\") == \"H\""
        ],
        "tests": [
            "try: remove_occ('hello', 'll')\nexcept ValueError as e: assert str(e) == 'Second parameter must be a single character.'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'remove_occ' to remove first and last occurrence of a given character from the string.",
        "instruction": "The function should return the original string if the character to be removed does not exist in the string.",
        "code_before": "def remove_occ(s, c):\n    first_occ = s.find(c)\n    last_occ = s.rfind(c)\n    if first_occ != -1 and last_occ != -1:\n        s = s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]\n    return s\n",
        "base_tests": [
            "assert remove_occ(\"hello\",\"l\") == \"heo\"",
            "assert remove_occ(\"abcda\",\"a\") == \"bcd\"",
            "assert remove_occ(\"PHP\",\"P\") == \"H\""
        ],
        "tests": [
            "assert remove_occ('hello', 'x') == 'hello'"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'remove_occ' to remove first and last occurrence of a given character from the string.",
        "instruction": "Extend the function to remove all occurrences of the character if a third parameter 'all' is set to True.",
        "code_before": "def remove_occ(s, c):\n    first_occ = s.find(c)\n    last_occ = s.rfind(c)\n    if first_occ != -1 and last_occ != -1:\n        s = s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]\n    return s\n",
        "base_tests": [
            "assert remove_occ(\"hello\",\"l\") == \"heo\"",
            "assert remove_occ(\"abcda\",\"a\") == \"bcd\"",
            "assert remove_occ(\"PHP\",\"P\") == \"H\""
        ],
        "tests": [
            "assert remove_occ('banana', 'a', all=True) == 'bnn'"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'remove_occ' to remove first and last occurrence of a given character from the string.",
        "instruction": "The function should include type annotations for its parameters and return type, including two parameters: 's': str, 'ch': str, and a return type: str.",
        "code_before": "def remove_occ(s, c):\n    first_occ = s.find(c)\n    last_occ = s.rfind(c)\n    if first_occ != -1 and last_occ != -1:\n        s = s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]\n    return s\n",
        "base_tests": [
            "assert remove_occ(\"hello\",\"l\") == \"heo\"",
            "assert remove_occ(\"abcda\",\"a\") == \"bcd\"",
            "assert remove_occ(\"PHP\",\"P\") == \"H\""
        ],
        "tests": [
            "assert remove_occ.__annotations__ == {'s': str, 'ch': str, 'return': str}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'remove_occ' to remove first and last occurrence of a given character from the string.",
        "instruction": "The function should have a cyclomatic complexity of 3 or less.",
        "code_before": "def remove_occ(s, c):\n    first_occ = s.find(c)\n    last_occ = s.rfind(c)\n    if first_occ != -1 and last_occ != -1:\n        s = s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]\n    return s\n",
        "base_tests": [
            "assert remove_occ(\"hello\",\"l\") == \"heo\"",
            "assert remove_occ(\"abcda\",\"a\") == \"bcd\"",
            "assert remove_occ(\"PHP\",\"P\") == \"H\""
        ],
        "tests": [
            "from mccabe import get_code_complexity\nimport inspect\nsource_code = inspect.getsource(remove_occ)\nassert get_code_complexity(source_code) <= 3"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'remove_occ' to remove first and last occurrence of a given character from the string.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper indentation and spacing.",
        "code_before": "def remove_occ(s, c):\n    first_occ = s.find(c)\n    last_occ = s.rfind(c)\n    if first_occ != -1 and last_occ != -1:\n        s = s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]\n    return s\n",
        "base_tests": [
            "assert remove_occ(\"hello\",\"l\") == \"heo\"",
            "assert remove_occ(\"abcda\",\"a\") == \"bcd\"",
            "assert remove_occ(\"PHP\",\"P\") == \"H\""
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(remove_occ)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'sort_matrix' to sort a given matrix in ascending order according to the sum of its rows.",
        "instruction": "The function should raise a TypeError if the input is not a list of lists or if any element in the matrix is not an integer.",
        "code_before": "def sort_matrix(matrix):\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    \n    # Zip the sums with the original matrix rows\n    # and sort by the sums\n    sorted_matrix = [row for _, row in sorted(zip(row_sums, matrix))]\n    \n    return sorted_matrix\n",
        "base_tests": [
            "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
            "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
            "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
        ],
        "tests": [
            "try: sort_matrix('not a matrix')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'\ntry: sort_matrix([[1, 2], [3, 'a']])\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'sort_matrix' to sort a given matrix in ascending order according to the sum of its rows.",
        "instruction": "The function should correctly handle an empty matrix by returning an empty matrix.",
        "code_before": "def sort_matrix(matrix):\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    \n    # Zip the sums with the original matrix rows\n    # and sort by the sums\n    sorted_matrix = [row for _, row in sorted(zip(row_sums, matrix))]\n    \n    return sorted_matrix\n",
        "base_tests": [
            "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
            "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
            "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
        ],
        "tests": [
            "assert sort_matrix([]) == []"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'sort_matrix' to sort a given matrix in ascending order according to the sum of its rows.",
        "instruction": "Extend the function to handle matrices with rows of varying lengths by treating missing values as zeros.",
        "code_before": "def sort_matrix(matrix):\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    \n    # Zip the sums with the original matrix rows\n    # and sort by the sums\n    sorted_matrix = [row for _, row in sorted(zip(row_sums, matrix))]\n    \n    return sorted_matrix\n",
        "base_tests": [
            "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
            "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
            "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
        ],
        "tests": [
            "assert sort_matrix([[1, 2, 3], [4, 5], [6]]) == [[6], [4, 5], [1, 2, 3]]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'sort_matrix' to sort a given matrix in ascending order according to the sum of its rows.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'matrix': 'list[list[int]]', and a return type: 'list[list[int]]'.",
        "code_before": "def sort_matrix(matrix):\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    \n    # Zip the sums with the original matrix rows\n    # and sort by the sums\n    sorted_matrix = [row for _, row in sorted(zip(row_sums, matrix))]\n    \n    return sorted_matrix\n",
        "base_tests": [
            "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
            "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
            "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
        ],
        "tests": [
            "def test_annotations():\n    from typing import get_type_hints\n    hints = get_type_hints(sort_matrix)\n    assert hints == {'matrix': 'list[list[int]]', 'return': 'list[list[int]]'}\ntest_annotations()"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'sort_matrix' to sort a given matrix in ascending order according to the sum of its rows.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation, spacing, and naming conventions.",
        "code_before": "def sort_matrix(matrix):\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    \n    # Zip the sums with the original matrix rows\n    # and sort by the sums\n    sorted_matrix = [row for _, row in sorted(zip(row_sums, matrix))]\n    \n    return sorted_matrix\n",
        "base_tests": [
            "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
            "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
            "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    code_string = inspect.getsource(function_name)\n    with open(filename, \"w\") as file:\n        file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=True)\n        result = style.check_files([filename])\n        if result.total_errors > 0:\n            print(f\"PEP 8 violations found: {result.total_errors} errors.\")\n        if result.total_errors > 0:\n            print(f\"PEP 8 violations found: {result.total_errors} errors.\")\n        os.remove(filename)\n    assert result.total_errors == 0\ncheck_code_style(sort_matrix)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'count_common' to count the most common words in a dictionary.",
        "instruction": "The function should raise a TypeError if the input is not a list of strings.",
        "code_before": "def count_common(dictionary):\n    word_count = {}\n    for word in dictionary.values():\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    return word_count\n",
        "base_tests": [
            "assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]",
            "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]",
            "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"
        ],
        "tests": [
            "try: count_common('not a list')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'\ntry: count_common([123, 'word'])\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'count_common' to count the most common words in a dictionary.",
        "instruction": "The function should handle an empty list input by returning an empty list.",
        "code_before": "def count_common(dictionary):\n    word_count = {}\n    for word in dictionary.values():\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    return word_count\n",
        "base_tests": [
            "assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]",
            "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]",
            "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"
        ],
        "tests": [
            "assert count_common([]) == []"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'count_common' to count the most common words in a dictionary.",
        "instruction": "Extend the function to allow an optional parameter that specifies the number of top frequent words to return.",
        "code_before": "def count_common(dictionary):\n    word_count = {}\n    for word in dictionary.values():\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    return word_count\n",
        "base_tests": [
            "assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]",
            "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]",
            "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"
        ],
        "tests": [
            "assert count_common(['apple', 'banana', 'apple', 'orange', 'banana', 'banana'], 2) == [('banana', 3), ('apple', 2)]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'count_common' to count the most common words in a dictionary.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'words': list, and a return type: list.",
        "code_before": "def count_common(dictionary):\n    word_count = {}\n    for word in dictionary.values():\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n    return word_count\n",
        "base_tests": [
            "assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]",
            "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]",
            "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"
        ],
        "tests": [
            "assert count_common.__annotations__ == {'words': list, 'return': list}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.",
        "instruction": "The function should accept three positive numerical inputs representing the base area, height, and length of the triangular prism, and return a positive numerical output representing the volume.The inputs can be either integers or floating-point numbers.",
        "code_before": "def find_volume(base, height, length):\n    return 0.5 * base * height * length\n",
        "base_tests": [
            "assert find_volume(10,8,6) == 240",
            "assert find_volume(3,2,2) == 6",
            "assert find_volume(1,2,1) == 1"
        ],
        "tests": [
            "assert find_volume(5.5, 3.2, 4.1) == 72.16",
            "assert find_volume(7, 2, 3) == 42"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.",
        "instruction": "The function should raise a ValueError with error message 'All dimensions must be positive numbers.' if any of the inputs are non-positive or non-numeric.",
        "code_before": "def find_volume(base, height, length):\n    return 0.5 * base * height * length\n",
        "base_tests": [
            "assert find_volume(10,8,6) == 240",
            "assert find_volume(3,2,2) == 6",
            "assert find_volume(1,2,1) == 1"
        ],
        "tests": [
            "try: find_volume(-1, 2, 3)\nexcept ValueError as e: assert str(e) == 'All dimensions must be positive numbers.'\nelse: assert False, 'TypeError not raised'",
            "try: find_volume('a', 2, 3)\nexcept ValueError as e: assert str(e) == 'All dimensions must be positive numbers.'\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.",
        "instruction": "The function should correctly handle edge cases where one or more dimensions are at their minimum positive value.",
        "code_before": "def find_volume(base, height, length):\n    return 0.5 * base * height * length\n",
        "base_tests": [
            "assert find_volume(10,8,6) == 240",
            "assert find_volume(3,2,2) == 6",
            "assert find_volume(1,2,1) == 1"
        ],
        "tests": [
            "assert find_volume(0.0001, 0.0001, 0.0001) == 5e-13",
            "assert find_volume(1, 1, 1) == 0.5"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.",
        "instruction": "Extend the function to handle inputs as a list or tuple of three elements, representing the base area, height, and length.",
        "code_before": "def find_volume(base, height, length):\n    return 0.5 * base * height * length\n",
        "base_tests": [
            "assert find_volume(10,8,6) == 240",
            "assert find_volume(3,2,2) == 6",
            "assert find_volume(1,2,1) == 1"
        ],
        "tests": [
            "assert find_volume([10, 8, 6]) == 240",
            "assert find_volume((3, 2, 2)) == 6"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.",
        "instruction": "The function should include type annotations for its parameters and return type, including three parameters: 'base_area': float, 'height': float, 'length': float, and a return type: float, and have a docstring explaining its purpose and usage: 'Calculate the volume of a triangular prism.'",
        "code_before": "def find_volume(base, height, length):\n    return 0.5 * base * height * length\n",
        "base_tests": [
            "assert find_volume(10,8,6) == 240",
            "assert find_volume(3,2,2) == 6",
            "assert find_volume(1,2,1) == 1"
        ],
        "tests": [
            "assert find_volume.__annotations__ == {'base_area': float, 'height': float, 'length': float, 'return': float}",
            "assert 'Calculate the volume of a triangular prism' in find_volume.__doc__"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.",
        "instruction": "The function should maintain a cyclomatic complexity of 1, indicating a straightforward calculation without any branching.",
        "code_before": "def find_volume(base, height, length):\n    return 0.5 * base * height * length\n",
        "base_tests": [
            "assert find_volume(10,8,6) == 240",
            "assert find_volume(3,2,2) == 6",
            "assert find_volume(1,2,1) == 1"
        ],
        "tests": [
            "from mccabe import get_code_complexity\nimport inspect\nsource_code = inspect.getsource(find_volume)\nassert get_code_complexity(source_code) <= 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def find_volume(base, height, length):\n    return 0.5 * base * height * length\n",
        "base_tests": [
            "assert find_volume(10,8,6) == 240",
            "assert find_volume(3,2,2) == 6",
            "assert find_volume(1,2,1) == 1"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_volume)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.",
        "instruction": "The function should accept a single string input and return a list of strings, each representing a segment of the original string split at lowercase letters.",
        "code_before": "def split_lowerstring(s):\n    return [s[i] for i in range(len(s)) if s[i].isupper()]\n",
        "base_tests": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "tests": [
            "assert isinstance(split_lowerstring('Test'), list) and all(isinstance(i, str) for i in split_lowerstring('Test'))"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.",
        "instruction": "The function should raise a TypeError if the input is not a string.",
        "code_before": "def split_lowerstring(s):\n    return [s[i] for i in range(len(s)) if s[i].isupper()]\n",
        "base_tests": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "tests": [
            "try: split_lowerstring(123); assert False, 'Expected TypeError' except TypeError: pass"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.",
        "instruction": "The function should return an empty list if the input string contains no lowercase letters.",
        "code_before": "def split_lowerstring(s):\n    return [s[i] for i in range(len(s)) if s[i].isupper()]\n",
        "base_tests": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "tests": [
            "assert split_lowerstring('ABC') == []"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.",
        "instruction": "Extend the function to optionally include the uppercase letters at the start of each segment in the output list when include_lower = True",
        "code_before": "def split_lowerstring(s):\n    return [s[i] for i in range(len(s)) if s[i].isupper()]\n",
        "base_tests": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "tests": [
            "assert split_lowerstring('AbCd', include_lower=True) == ['Ab', 'Cd']"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'text': str, and a return type: list.",
        "code_before": "def split_lowerstring(s):\n    return [s[i] for i in range(len(s)) if s[i].isupper()]\n",
        "base_tests": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "tests": [
            "assert 'def split_lowerstring(text: str) -> list:' in inspect.getsource(split_lowerstring)"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a single path through the code.",
        "code_before": "def split_lowerstring(s):\n    return [s[i] for i in range(len(s)) if s[i].isupper()]\n",
        "base_tests": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "tests": [
            "from mccabe import get_code_complexity\nimport inspect\nsource_code = inspect.getsource(split_lowerstring)\nassert get_code_complexity(source_code) <= 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation and spacing.",
        "code_before": "def split_lowerstring(s):\n    return [s[i] for i in range(len(s)) if s[i].isupper()]\n",
        "base_tests": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(split_lowerstring)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.",
        "instruction": "The function should accept a string as input and return a string as output, specifically 'Found a match!' or 'Not matched!'.",
        "code_before": "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n",
        "base_tests": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "tests": [
            "assert isinstance(text_lowercase_underscore('abc_def'), str)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.",
        "instruction": "The function should raise a TypeError if the input is not a string.",
        "code_before": "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n",
        "base_tests": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "tests": [
            "try:\n    text_lowercase_underscore(123)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for non-string input'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.",
        "instruction": "The function should correctly handle an empty string input by returning 'Not matched!'.",
        "code_before": "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n",
        "base_tests": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "tests": [
            "assert text_lowercase_underscore('') == 'Not matched!'"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.",
        "instruction": "Extend the function to handle multiple sequences separated by underscores and return 'Found a match!' if at least one sequence matches.",
        "code_before": "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n",
        "base_tests": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "tests": [
            "assert text_lowercase_underscore('abc_def_ghi') == 'Found a match!'"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'text': str, and a return type: str.",
        "code_before": "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n",
        "base_tests": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "tests": [
            "assert text_lowercase_underscore.__annotations__ == {'text': str, 'return': str}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a single decision point.",
        "code_before": "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n",
        "base_tests": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(text_lowercase_underscore))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation and spacing.",
        "code_before": "import re\n\ndef text_lowercase_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n",
        "base_tests": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(text_lowercase_underscore)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.",
        "instruction": "The function should accept only non-negative integers as input and return a non-negative integer as output.",
        "code_before": "def square_perimeter(side):\n    return 4 * side\n",
        "base_tests": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "tests": [
            "assert square_perimeter(0) == 0\nassert square_perimeter(15) == 60\ntry:\n    square_perimeter(-5)\nexcept ValueError:\n    pass\nelse:\n    assert False, 'Expected ValueError for negative input'"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.",
        "instruction": "The function should raise a ValueError if the input is negative.",
        "code_before": "def square_perimeter(side):\n    return 4 * side\n",
        "base_tests": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "tests": [
            "try:\n    square_perimeter(-1)\nexcept ValueError:\n    pass\nelse:\n    assert False, 'Expected ValueError for negative input'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.",
        "instruction": "The function should correctly handle the edge case where the side length is zero.",
        "code_before": "def square_perimeter(side):\n    return 4 * side\n",
        "base_tests": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "tests": [
            "assert square_perimeter(0) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.",
        "instruction": "Extend the function to handle floating-point numbers by rounding them to the nearest integer using the standard rounding rule before calculating the perimeter.",
        "code_before": "def square_perimeter(side):\n    return 4 * side\n",
        "base_tests": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "tests": [
            "assert square_perimeter(4.5) == 20\nassert square_perimeter(3.7) == 16"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'a': int, and a return type: int.",
        "code_before": "def square_perimeter(side):\n    return 4 * side\n",
        "base_tests": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "tests": [
            "assert square_perimeter.__annotations__ == {'a': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a single path through the code.",
        "code_before": "def square_perimeter(side):\n    return 4 * side\n",
        "base_tests": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(square_perimeter))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def square_perimeter(side):\n    return 4 * side\n",
        "base_tests": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(square_perimeter)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'remove_dirty_chars' to remove characters from the first string which are present in the second string.",
        "instruction": "The function should accept two strings as input and return a string as output. The input strings should only contain alphabetic characters. If the input strings contain non-alphabetic characters, the function should raise a ValueError, and an assertion error should occur with the message: 'Input strings must only contain alphabetic characters.'",
        "code_before": "def remove_dirty_chars(s, dirty):\n    return ''.join([c for c in s if c not in dirty])\n",
        "base_tests": [
            "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
            "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
            "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "
        ],
        "tests": [
            "assert remove_dirty_chars('hello', 'world') == 'he', 'The function did not return the expected output for valid inputs.'",
            "try: remove_dirty_chars('hell0', 'world')\nexcept ValueError as e: assert str(e) == 'Input strings must only contain alphabetic characters.'"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'remove_dirty_chars' to remove characters from the first string which are present in the second string.",
        "instruction": "The function should raise a TypeError if either of the inputs is not a string.",
        "code_before": "def remove_dirty_chars(s, dirty):\n    return ''.join([c for c in s if c not in dirty])\n",
        "base_tests": [
            "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
            "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
            "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "
        ],
        "tests": [
            "try:\n    remove_dirty_chars(123, 'abc')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for non-string input'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'remove_dirty_chars' to remove characters from the first string which are present in the second string.",
        "instruction": "The function should return the original string if the second string is empty.",
        "code_before": "def remove_dirty_chars(s, dirty):\n    return ''.join([c for c in s if c not in dirty])\n",
        "base_tests": [
            "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
            "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
            "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "
        ],
        "tests": [
            "assert remove_dirty_chars('example', '') == 'example', 'Function should return the original string if the second string is empty.'"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'remove_dirty_chars' to remove characters from the first string which are present in the second string.",
        "instruction": "The function should be extended to handle case-insensitive character removal.",
        "code_before": "def remove_dirty_chars(s, dirty):\n    return ''.join([c for c in s if c not in dirty])\n",
        "base_tests": [
            "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
            "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
            "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "
        ],
        "tests": [
            "assert remove_dirty_chars('HelloWorld', 'hELLO') == 'World', 'Function should handle case-insensitive character removal.'"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'remove_dirty_chars' to remove characters from the first string which are present in the second string.",
        "instruction": "The function should include type annotations for its parameters and return type.The parameters should be annotated as 'string': str and 'second_string': str, and the return type is str.",
        "code_before": "def remove_dirty_chars(s, dirty):\n    return ''.join([c for c in s if c not in dirty])\n",
        "base_tests": [
            "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
            "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
            "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "
        ],
        "tests": [
            "assert remove_dirty_chars.__annotations__ == {'string': str, 'second_string': str, 'return': str}, 'Function should have correct type annotations.'"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'remove_dirty_chars' to remove characters from the first string which are present in the second string.",
        "instruction": "The function should follow PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def remove_dirty_chars(s, dirty):\n    return ''.join([c for c in s if c not in dirty])\n",
        "base_tests": [
            "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
            "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
            "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(remove_dirty_chars)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function named 'test_duplicate' to find whether a given array of integers contains any duplicate element.",
        "instruction": "The function should accept a list of integers and return a boolean indicating the presence of duplicates. It should raise a TypeError if the input is not a list.",
        "code_before": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True\n",
        "base_tests": [
            "assert test_duplicate(([1,2,3,4,5]))==False",
            "assert test_duplicate(([1,2,3,4, 4]))==True",
            "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
        ],
        "tests": [
            "assert test_duplicate([1, 2, 3, 4, 5]) == False",
            "assert test_duplicate([1, 2, 3, 4, 4]) == True",
            "assert test_duplicate([1, 1, 2, 2, 3, 3, 4, 4, 5]) == True",
            "try:\n    test_duplicate('12345')\n    assert False, 'TypeError not raised'\nexcept TypeError:\n    pass"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function named 'test_duplicate' to find whether a given array of integers contains any duplicate element.",
        "instruction": "The function should handle exceptions gracefully and raise a ValueError with the message 'Input must be a list of integers' if the input is not a list.",
        "code_before": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True\n",
        "base_tests": [
            "assert test_duplicate(([1,2,3,4,5]))==False",
            "assert test_duplicate(([1,2,3,4, 4]))==True",
            "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
        ],
        "tests": [
            "try:\n    test_duplicate(None)\n    assert False, 'TypeError not raised'\nexcept TypeError as e:\n    assert str(e) == 'Input must be a list of integers'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function named 'test_duplicate' to find whether a given array of integers contains any duplicate element.",
        "instruction": "The function should correctly handle edge cases such as an empty list and a list with one element.",
        "code_before": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True\n",
        "base_tests": [
            "assert test_duplicate(([1,2,3,4,5]))==False",
            "assert test_duplicate(([1,2,3,4, 4]))==True",
            "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
        ],
        "tests": [
            "assert test_duplicate([]) == False",
            "assert test_duplicate([1]) == False"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function named 'test_duplicate' to find whether a given array of integers contains any duplicate element.",
        "instruction": "Extend the function to return the list of duplicate elements if any are found, otherwise return an empty list.",
        "code_before": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True\n",
        "base_tests": [
            "assert test_duplicate(([1,2,3,4,5]))==False",
            "assert test_duplicate(([1,2,3,4, 4]))==True",
            "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
        ],
        "tests": [
            "assert test_duplicate([1, 2, 3, 4, 5]) == []",
            "assert test_duplicate([1, 2, 3, 4, 4]) == [4]",
            "assert test_duplicate([1, 1, 2, 2, 3, 3, 4, 4, 5]) == [1, 2, 3, 4]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function named 'test_duplicate' to find whether a given array of integers contains any duplicate element.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'arraynums': list, and the return type should be annotated as bool.",
        "code_before": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True\n",
        "base_tests": [
            "assert test_duplicate(([1,2,3,4,5]))==False",
            "assert test_duplicate(([1,2,3,4, 4]))==True",
            "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
        ],
        "tests": [
            "assert test_duplicate.__annotations__ == {'arraynums': list, 'return': bool}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function named 'test_duplicate' to find whether a given array of integers contains any duplicate element.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def test_duplicate(arr):\n    if len(arr) == len(set(arr)):\n        return False\n    else:\n        return True\n",
        "base_tests": [
            "assert test_duplicate(([1,2,3,4,5]))==False",
            "assert test_duplicate(([1,2,3,4, 4]))==True",
            "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(test_duplicate)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.",
        "instruction": "The function should accept an integer as input and return a boolean indicating whether the number is a Woodall number.",
        "code_before": "def is_woodall(n):\n    if n < 1:\n        return False\n    n_str = str(n)\n    for i in range(1, len(n_str)):\n        if int(n_str[:i]) * (int(n_str[:i]) + 1) != int(n_str[:i+1]):\n            return False\n    return True\n",
        "base_tests": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "tests": [
            "assert isinstance(is_woodall(383), bool)",
            "assert isinstance(is_woodall(254), bool)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.",
        "instruction": "The function should raise a TypeError if the input is not an integer.",
        "code_before": "def is_woodall(n):\n    if n < 1:\n        return False\n    n_str = str(n)\n    for i in range(1, len(n_str)):\n        if int(n_str[:i]) * (int(n_str[:i]) + 1) != int(n_str[:i+1]):\n            return False\n    return True\n",
        "base_tests": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "tests": [
            "try: is_woodall('383')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'",
            "try: is_woodall(3.83)\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.",
        "instruction": "The function should correctly handle edge cases such as very large integers and zero.",
        "code_before": "def is_woodall(n):\n    if n < 1:\n        return False\n    n_str = str(n)\n    for i in range(1, len(n_str)):\n        if int(n_str[:i]) * (int(n_str[:i]) + 1) != int(n_str[:i+1]):\n            return False\n    return True\n",
        "base_tests": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "tests": [
            "assert is_woodall(0) == False",
            "assert is_woodall(1) == True",
            "assert is_woodall(999999999999) == False"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.",
        "instruction": "Extend the function to return a list of all Woodall numbers up to a given number if the input is a positive integer.",
        "code_before": "def is_woodall(n):\n    if n < 1:\n        return False\n    n_str = str(n)\n    for i in range(1, len(n_str)):\n        if int(n_str[:i]) * (int(n_str[:i]) + 1) != int(n_str[:i+1]):\n            return False\n    return True\n",
        "base_tests": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "tests": [
            "assert is_woodall(10) == [1, 7]",
            "assert is_woodall(15) == [1, 7, 15]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'x': int, and the return type should be annotated as bool.",
        "code_before": "def is_woodall(n):\n    if n < 1:\n        return False\n    n_str = str(n)\n    for i in range(1, len(n_str)):\n        if int(n_str[:i]) * (int(n_str[:i]) + 1) != int(n_str[:i+1]):\n            return False\n    return True\n",
        "base_tests": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "tests": [
            "assert is_woodall.__annotations__ == {'x': int, 'return': bool}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple, linear function.",
        "code_before": "def is_woodall(n):\n    if n < 1:\n        return False\n    n_str = str(n)\n    for i in range(1, len(n_str)):\n        if int(n_str[:i]) * (int(n_str[:i]) + 1) != int(n_str[:i+1]):\n            return False\n    return True\n",
        "base_tests": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(is_woodall))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def is_woodall(n):\n    if n < 1:\n        return False\n    n_str = str(n)\n    for i in range(1, len(n_str)):\n        if int(n_str[:i]) * (int(n_str[:i]) + 1) != int(n_str[:i+1]):\n            return False\n    return True\n",
        "base_tests": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(is_woodall)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function named 'multiples_of_num' to find m number of multiples of n.",
        "instruction": "The function should raise a ValueError if either m or n is negative.",
        "code_before": "def multiples_of_num(n, m):\n    return [n * i for i in range(1, m+1)]\n",
        "base_tests": [
            "assert multiples_of_num(4,3)== [3,6,9,12]",
            "assert multiples_of_num(2,5)== [5,10]",
            "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"
        ],
        "tests": [
            "try: multiples_of_num(-1, 5)\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError'",
            "try: multiples_of_num(3, -2)\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function named 'multiples_of_num' to find m number of multiples of n.",
        "instruction": "The function should handle the edge case where m is zero, returning an empty list.",
        "code_before": "def multiples_of_num(n, m):\n    return [n * i for i in range(1, m+1)]\n",
        "base_tests": [
            "assert multiples_of_num(4,3)== [3,6,9,12]",
            "assert multiples_of_num(2,5)== [5,10]",
            "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"
        ],
        "tests": [
            "assert multiples_of_num(0, 5) == []",
            "assert multiples_of_num(0, 0) == []"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function named 'multiples_of_num' to find m number of multiples of n.",
        "instruction": "Extend the function to handle cases where n is a floating-point number, returning multiples as floating-point numbers.",
        "code_before": "def multiples_of_num(n, m):\n    return [n * i for i in range(1, m+1)]\n",
        "base_tests": [
            "assert multiples_of_num(4,3)== [3,6,9,12]",
            "assert multiples_of_num(2,5)== [5,10]",
            "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"
        ],
        "tests": [
            "assert multiples_of_num(3, 2.5) == [2.5, 5.0, 7.5]",
            "assert multiples_of_num(4, 1.1) == [1.1, 2.2, 3.3, 4.4]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function named 'multiples_of_num' to find m number of multiples of n.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'm': int, 'n': int, and the return type should be annotated as list.",
        "code_before": "def multiples_of_num(n, m):\n    return [n * i for i in range(1, m+1)]\n",
        "base_tests": [
            "assert multiples_of_num(4,3)== [3,6,9,12]",
            "assert multiples_of_num(2,5)== [5,10]",
            "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"
        ],
        "tests": [
            "assert multiples_of_num.__annotations__ == {'m': int, 'n': int, 'return': list}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function named 'multiples_of_num' to find m number of multiples of n.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a single path through the function.",
        "code_before": "def multiples_of_num(n, m):\n    return [n * i for i in range(1, m+1)]\n",
        "base_tests": [
            "assert multiples_of_num(4,3)== [3,6,9,12]",
            "assert multiples_of_num(2,5)== [5,10]",
            "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(multiples_of_num))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function named 'multiples_of_num' to find m number of multiples of n.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def multiples_of_num(n, m):\n    return [n * i for i in range(1, m+1)]\n",
        "base_tests": [
            "assert multiples_of_num(4,3)== [3,6,9,12]",
            "assert multiples_of_num(2,5)== [5,10]",
            "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(multiples_of_num)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function 'find_first_duplicate' to find the first duplicate element in a given array of integers.",
        "instruction": "The function should raise a TypeError if the input is not a list of integers.",
        "code_before": "def find_first_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n",
        "base_tests": [
            "assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4",
            "assert find_first_duplicate([1, 2, 3, 4])==-1",
            "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"
        ],
        "tests": [
            "try: find_first_duplicate('not a list')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function 'find_first_duplicate' to find the first duplicate element in a given array of integers.",
        "instruction": "The function should handle an empty list by returning -1.",
        "code_before": "def find_first_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n",
        "base_tests": [
            "assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4",
            "assert find_first_duplicate([1, 2, 3, 4])==-1",
            "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"
        ],
        "tests": [
            "assert find_first_duplicate([]) == -1"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function 'find_first_duplicate' to find the first duplicate element in a given array of integers.",
        "instruction": "Extend the function to return a list of all duplicate elements in the order they first appear, or an empty list if there are no duplicates.",
        "code_before": "def find_first_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n",
        "base_tests": [
            "assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4",
            "assert find_first_duplicate([1, 2, 3, 4])==-1",
            "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"
        ],
        "tests": [
            "assert find_first_duplicate([1, 2, 3, 2, 4, 5, 4]) == [2, 4]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function 'find_first_duplicate' to find the first duplicate element in a given array of integers.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'nums': list, and the return type should be annotated as int.",
        "code_before": "def find_first_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n",
        "base_tests": [
            "assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4",
            "assert find_first_duplicate([1, 2, 3, 4])==-1",
            "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"
        ],
        "tests": [
            "assert find_first_duplicate.__annotations__ == {'nums': list, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function 'find_first_duplicate' to find the first duplicate element in a given array of integers.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper indentation and spacing.",
        "code_before": "def find_first_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n",
        "base_tests": [
            "assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4",
            "assert find_first_duplicate([1, 2, 3, 4])==-1",
            "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_first_duplicate)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function named 'maximum_sum' to find the maximum sum of elements of list in a list of lists.",
        "instruction": "The function should accept a list of lists containing integers and return an integer representing the maximum sum of elements from any sublist.",
        "code_before": "def maximum_sum(list_of_lists):\n    return max(sum(lst) for lst in list_of_lists)\n",
        "base_tests": [
            "assert maximum_sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
            "assert maximum_sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
            "assert maximum_sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"
        ],
        "tests": [
            "assert isinstance(maximum_sum([[1, 2], [3, 4]]), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function named 'maximum_sum' to find the maximum sum of elements of list in a list of lists.",
        "instruction": "The function should raise a TypeError if the input is not a list of lists or if any sublist contains non-integer elements.",
        "code_before": "def maximum_sum(list_of_lists):\n    return max(sum(lst) for lst in list_of_lists)\n",
        "base_tests": [
            "assert maximum_sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
            "assert maximum_sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
            "assert maximum_sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"
        ],
        "tests": [
            "try:\n    maximum_sum([[1, 2], [3, 'a']])\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass",
            "try:\n    maximum_sum(123)\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function named 'maximum_sum' to find the maximum sum of elements of list in a list of lists.",
        "instruction": "The function should return 0 if the input list is empty or if all sublists are empty.",
        "code_before": "def maximum_sum(list_of_lists):\n    return max(sum(lst) for lst in list_of_lists)\n",
        "base_tests": [
            "assert maximum_sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
            "assert maximum_sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
            "assert maximum_sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"
        ],
        "tests": [
            "assert maximum_sum([]) == 0\nassert maximum_sum([[], [], []]) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function named 'maximum_sum' to find the maximum sum of elements of list in a list of lists.",
        "instruction": "Extend the function to handle negative integers and ensure it returns the maximum sum correctly.",
        "code_before": "def maximum_sum(list_of_lists):\n    return max(sum(lst) for lst in list_of_lists)\n",
        "base_tests": [
            "assert maximum_sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
            "assert maximum_sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
            "assert maximum_sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"
        ],
        "tests": [
            "assert maximum_sum([[-1, -2, -3], [-4, -5, -6], [-10, -11, -12], [-7, -8, -9]]) == -6"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function named 'maximum_sum' to find the maximum sum of elements of list in a list of lists.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'list1': list[list[int]], and the return type should be annotated as int.",
        "code_before": "def maximum_sum(list_of_lists):\n    return max(sum(lst) for lst in list_of_lists)\n",
        "base_tests": [
            "assert maximum_sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
            "assert maximum_sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
            "assert maximum_sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"
        ],
        "tests": [
            "assert maximum_sum.__annotations__ == {'list1': 'list[list[int]]', 'return': 'int'}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function named 'maximum_sum' to find the maximum sum of elements of list in a list of lists.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def maximum_sum(list_of_lists):\n    return max(sum(lst) for lst in list_of_lists)\n",
        "base_tests": [
            "assert maximum_sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
            "assert maximum_sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
            "assert maximum_sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(maximum_sum)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'binary_to_decimal' to convert the given binary number to its decimal equivalent.",
        "instruction": "The function should raise a ValueError with a descriptive error message as 'Invalid binary number' if the input is not a valid binary string.",
        "code_before": "def binary_to_decimal(binary):\n    binary = str(binary)\n    decimal = 0\n    for digit in binary:\n        decimal = decimal*2 + int(digit)\n    return decimal\n",
        "base_tests": [
            "assert binary_to_decimal(100) == 4",
            "assert binary_to_decimal(1011) == 11",
            "assert binary_to_decimal(1101101) == 109"
        ],
        "tests": [
            "try:\n    binary_to_decimal('102')\n    assert False, 'Expected ValueError'\nexcept ValueError as e:\n    assert str(e) == 'Invalid binary number'",
            "try:\n    binary_to_decimal('abc')\n    assert False, 'Expected ValueError'\nexcept ValueError as e:\n    assert str(e) == 'Invalid binary number'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'binary_to_decimal' to convert the given binary number to its decimal equivalent.",
        "instruction": "The function should correctly handle the edge case of an empty string by returning 0.",
        "code_before": "def binary_to_decimal(binary):\n    binary = str(binary)\n    decimal = 0\n    for digit in binary:\n        decimal = decimal*2 + int(digit)\n    return decimal\n",
        "base_tests": [
            "assert binary_to_decimal(100) == 4",
            "assert binary_to_decimal(1011) == 11",
            "assert binary_to_decimal(1101101) == 109"
        ],
        "tests": [
            "assert binary_to_decimal('') == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'binary_to_decimal' to convert the given binary number to its decimal equivalent.",
        "instruction": "Extend the function to handle binary numbers with leading zeros correctly.",
        "code_before": "def binary_to_decimal(binary):\n    binary = str(binary)\n    decimal = 0\n    for digit in binary:\n        decimal = decimal*2 + int(digit)\n    return decimal\n",
        "base_tests": [
            "assert binary_to_decimal(100) == 4",
            "assert binary_to_decimal(1011) == 11",
            "assert binary_to_decimal(1101101) == 109"
        ],
        "tests": [
            "assert binary_to_decimal('000100') == 4",
            "assert binary_to_decimal('0000') == 0"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'binary_to_decimal' to convert the given binary number to its decimal equivalent.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'binary': str, and the return type should be annotated as int.",
        "code_before": "def binary_to_decimal(binary):\n    binary = str(binary)\n    decimal = 0\n    for digit in binary:\n        decimal = decimal*2 + int(digit)\n    return decimal\n",
        "base_tests": [
            "assert binary_to_decimal(100) == 4",
            "assert binary_to_decimal(1011) == 11",
            "assert binary_to_decimal(1101101) == 109"
        ],
        "tests": [
            "assert 'def binary_to_decimal(binary: str) -> int' in inspect.getsource(binary_to_decimal)"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'binary_to_decimal' to convert the given binary number to its decimal equivalent.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a single path through the code.",
        "code_before": "def binary_to_decimal(binary):\n    binary = str(binary)\n    decimal = 0\n    for digit in binary:\n        decimal = decimal*2 + int(digit)\n    return decimal\n",
        "base_tests": [
            "assert binary_to_decimal(100) == 4",
            "assert binary_to_decimal(1011) == 11",
            "assert binary_to_decimal(1101101) == 109"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(binary_to_decimal))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'binary_to_decimal' to convert the given binary number to its decimal equivalent.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def binary_to_decimal(binary):\n    binary = str(binary)\n    decimal = 0\n    for digit in binary:\n        decimal = decimal*2 + int(digit)\n    return decimal\n",
        "base_tests": [
            "assert binary_to_decimal(100) == 4",
            "assert binary_to_decimal(1011) == 11",
            "assert binary_to_decimal(1101101) == 109"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(binary_to_decimal)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'find_product' to find the product of non-repeated elements in a given array.",
        "instruction": "The function should accept a list of integers as input and return an integer as output, representing the product of non-repeated elements.",
        "code_before": "def find_product(arr):\n    product = 1\n    for i in set(arr):\n        if arr.count(i) == 1:\n            product *= i\n    return product\n",
        "base_tests": [
            "assert find_product([1,1,2,3],4) == 6",
            "assert find_product([1,2,3,1,1],5) == 6",
            "assert find_product([1,1,4,5,6],5) == 120"
        ],
        "tests": [
            "assert isinstance(find_product([1, 2, 3], 3), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'find_product' to find the product of non-repeated elements in a given array.",
        "instruction": "The function should raise a TypeError if the input is not a list of integers.",
        "code_before": "def find_product(arr):\n    product = 1\n    for i in set(arr):\n        if arr.count(i) == 1:\n            product *= i\n    return product\n",
        "base_tests": [
            "assert find_product([1,1,2,3],4) == 6",
            "assert find_product([1,2,3,1,1],5) == 6",
            "assert find_product([1,1,4,5,6],5) == 120"
        ],
        "tests": [
            "try: find_product('not a list', 3)\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'find_product' to find the product of non-repeated elements in a given array.",
        "instruction": "The function should return 1 if the input list is empty, as there are no elements to multiply.",
        "code_before": "def find_product(arr):\n    product = 1\n    for i in set(arr):\n        if arr.count(i) == 1:\n            product *= i\n    return product\n",
        "base_tests": [
            "assert find_product([1,1,2,3],4) == 6",
            "assert find_product([1,2,3,1,1],5) == 6",
            "assert find_product([1,1,4,5,6],5) == 120"
        ],
        "tests": [
            "assert find_product([], 0) == 1"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'find_product' to find the product of non-repeated elements in a given array.",
        "instruction": "Extend the function to handle negative numbers correctly, ensuring the product is calculated accurately.",
        "code_before": "def find_product(arr):\n    product = 1\n    for i in set(arr):\n        if arr.count(i) == 1:\n            product *= i\n    return product\n",
        "base_tests": [
            "assert find_product([1,1,2,3],4) == 6",
            "assert find_product([1,2,3,1,1],5) == 6",
            "assert find_product([1,1,4,5,6],5) == 120"
        ],
        "tests": [
            "assert find_product([-1, -2, 3, 3], 4) == 2"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'find_product' to find the product of non-repeated elements in a given array.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'arr': list, 'n': int, and the return type should be annotated as int.",
        "code_before": "def find_product(arr):\n    product = 1\n    for i in set(arr):\n        if arr.count(i) == 1:\n            product *= i\n    return product\n",
        "base_tests": [
            "assert find_product([1,1,2,3],4) == 6",
            "assert find_product([1,2,3,1,1],5) == 6",
            "assert find_product([1,1,4,5,6],5) == 120"
        ],
        "tests": [
            "assert find_product.__annotations__ == {'arr': list, 'n': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'find_product' to find the product of non-repeated elements in a given array.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def find_product(arr):\n    product = 1\n    for i in set(arr):\n        if arr.count(i) == 1:\n            product *= i\n    return product\n",
        "base_tests": [
            "assert find_product([1,1,2,3],4) == 6",
            "assert find_product([1,2,3,1,1],5) == 6",
            "assert find_product([1,1,4,5,6],5) == 120"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_product)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function 'check_k_elements' to check if the given tuple list has all k elements.",
        "instruction": "The function should return a boolean value indicating whether all tuples in the list contain exactly k elements.",
        "code_before": "def check_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n",
        "base_tests": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
            "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
            "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"
        ],
        "tests": [
            "assert isinstance(check_k_elements([(1, 2), (3, 4)], 2), bool)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function 'check_k_elements' to check if the given tuple list has all k elements.",
        "instruction": "The function should raise a TypeError if the input is not a list of tuples or if k is not an integer.",
        "code_before": "def check_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n",
        "base_tests": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
            "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
            "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"
        ],
        "tests": [
            "try:\n    check_k_elements('not a tuple list', 2)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    check_k_elements([(1, 2), (3, 4)], 'not an integer')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function 'check_k_elements' to check if the given tuple list has all k elements.",
        "instruction": "The function should handle edge cases such as an empty list or tuples with zero elements.",
        "code_before": "def check_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n",
        "base_tests": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
            "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
            "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"
        ],
        "tests": [
            "assert check_k_elements([], 0) == True\nassert check_k_elements([()], 0) == True"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function 'check_k_elements' to check if the given tuple list has all k elements.",
        "instruction": "Extend the function to return the count of tuples that have exactly k elements.",
        "code_before": "def check_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n",
        "base_tests": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
            "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
            "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"
        ],
        "tests": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == 1"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function 'check_k_elements' to check if the given tuple list has all k elements.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'test_list': list[tuple], 'K': int, and the return type should be annotated as bool.",
        "code_before": "def check_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n",
        "base_tests": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
            "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
            "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"
        ],
        "tests": [
            "assert check_k_elements.__annotations__ == {'test_list': list[tuple], 'K': int, 'return': bool}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function 'check_k_elements' to check if the given tuple list has all k elements.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def check_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n",
        "base_tests": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
            "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
            "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(check_k_elements)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function named 'remove' to remove all digits from a list of strings.",
        "instruction": "The function should raise a TypeError if the input is not a list or if any element in the list is not a string.",
        "code_before": "def remove(lst):\n    return [''.join(c for c in s if not c.isdigit()) for s in lst]\n",
        "base_tests": [
            "assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']",
            "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']",
            "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"
        ],
        "tests": [
            "try:\n    remove('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    remove([123, 'valid', 456])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function named 'remove' to remove all digits from a list of strings.",
        "instruction": "The function should handle edge cases such as an empty list or strings with no digits gracefully.",
        "code_before": "def remove(lst):\n    return [''.join(c for c in s if not c.isdigit()) for s in lst]\n",
        "base_tests": [
            "assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']",
            "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']",
            "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"
        ],
        "tests": [
            "assert remove([]) == []\nassert remove(['no digits here']) == ['no digits here']"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function named 'remove' to remove all digits from a list of strings.",
        "instruction": "Extend the function to include an additional parameter specifying other characters to be removed, in addition to digits.",
        "code_before": "def remove(lst):\n    return [''.join(c for c in s if not c.isdigit()) for s in lst]\n",
        "base_tests": [
            "assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']",
            "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']",
            "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"
        ],
        "tests": [
            "assert remove_extended(['abcd123', '456defg'], 'abcdef') == ['d', 'g']"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function named 'remove' to remove all digits from a list of strings.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'list': list[str], and the return type should be annotated as list[str].",
        "code_before": "def remove(lst):\n    return [''.join(c for c in s if not c.isdigit()) for s in lst]\n",
        "base_tests": [
            "assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']",
            "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']",
            "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"
        ],
        "tests": [
            "assert remove.__annotations__ == {'list': list[str], 'return': list[str]}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function named 'remove' to remove all digits from a list of strings.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def remove(lst):\n    return [''.join(c for c in s if not c.isdigit()) for s in lst]\n",
        "base_tests": [
            "assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']",
            "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']",
            "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(remove)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'binomial_coeff' to find binomial co-efficient.",
        "instruction": "The function should accept two non-negative integer inputs n and k, and return an integer output representing the binomial coefficient.",
        "code_before": "def binomial_coeff(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_coeff(n-1, k-1) + binomial_coeff(n-1, k)\n",
        "base_tests": [
            "assert binomial_coeff(5,2) == 10",
            "assert binomial_coeff(4,3) == 4",
            "assert binomial_coeff(3,2) == 3"
        ],
        "tests": [
            "assert isinstance(binomial_coeff(5, 2), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'binomial_coeff' to find binomial co-efficient.",
        "instruction": "The function should raise a ValueError with a descriptive message as 'Inputs must be non-negative and k must not be greater than n' if either input is negative or if k is greater than n.",
        "code_before": "def binomial_coeff(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_coeff(n-1, k-1) + binomial_coeff(n-1, k)\n",
        "base_tests": [
            "assert binomial_coeff(5,2) == 10",
            "assert binomial_coeff(4,3) == 4",
            "assert binomial_coeff(3,2) == 3"
        ],
        "tests": [
            "try: binomial_coeff(-1, 2)\nexcept ValueError as e: assert str(e) == 'Inputs must be non-negative and k must not be greater than n'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'binomial_coeff' to find binomial co-efficient.",
        "instruction": "The function should correctly handle edge cases such as when n or k is 0, or when n equals k.",
        "code_before": "def binomial_coeff(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_coeff(n-1, k-1) + binomial_coeff(n-1, k)\n",
        "base_tests": [
            "assert binomial_coeff(5,2) == 10",
            "assert binomial_coeff(4,3) == 4",
            "assert binomial_coeff(3,2) == 3"
        ],
        "tests": [
            "assert binomial_coeff(0, 0) == 1\nassert binomial_coeff(5, 0) == 1\nassert binomial_coeff(5, 5) == 1"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'binomial_coeff' to find binomial co-efficient.",
        "instruction": "Extend the function to handle large values of n and k efficiently using memoization or iterative approach.",
        "code_before": "def binomial_coeff(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_coeff(n-1, k-1) + binomial_coeff(n-1, k)\n",
        "base_tests": [
            "assert binomial_coeff(5,2) == 10",
            "assert binomial_coeff(4,3) == 4",
            "assert binomial_coeff(3,2) == 3"
        ],
        "tests": [
            "assert binomial_coeff(100, 50) == 100891344545564193334812497256"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'binomial_coeff' to find binomial co-efficient.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, 'k': int, and the return type should be annotated as int.",
        "code_before": "def binomial_coeff(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_coeff(n-1, k-1) + binomial_coeff(n-1, k)\n",
        "base_tests": [
            "assert binomial_coeff(5,2) == 10",
            "assert binomial_coeff(4,3) == 4",
            "assert binomial_coeff(3,2) == 3"
        ],
        "tests": [
            "assert binomial_coeff.__annotations__ == {'n': int, 'k': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'binomial_coeff' to find binomial co-efficient.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def binomial_coeff(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_coeff(n-1, k-1) + binomial_coeff(n-1, k)\n",
        "base_tests": [
            "assert binomial_coeff(5,2) == 10",
            "assert binomial_coeff(4,3) == 4",
            "assert binomial_coeff(3,2) == 3"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(binomial_coeff)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function 'get_odd_occurrence' to find the element occurring odd number of times.",
        "instruction": "The function should raise a TypeError if the input is not a list of integers.",
        "code_before": "def get_odd_occurrence(lst):\n    counts = {}\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    for num, count in counts.items():\n        if count % 2 != 0:\n            return num\n    return None\n",
        "base_tests": [
            "assert get_odd_occurrence([1,2,3,1,2,3,1],7) == 1",
            "assert get_odd_occurrence([1,2,3,2,3,1,3],7) == 3",
            "assert get_odd_occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"
        ],
        "tests": [
            "try:\n    get_odd_occurrence('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    get_odd_occurrence([1, 'two', 3])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function 'get_odd_occurrence' to find the element occurring odd number of times.",
        "instruction": "The function should handle an empty list by returning None.",
        "code_before": "def get_odd_occurrence(lst):\n    counts = {}\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    for num, count in counts.items():\n        if count % 2 != 0:\n            return num\n    return None\n",
        "base_tests": [
            "assert get_odd_occurrence([1,2,3,1,2,3,1],7) == 1",
            "assert get_odd_occurrence([1,2,3,2,3,1,3],7) == 3",
            "assert get_odd_occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"
        ],
        "tests": [
            "assert get_odd_occurrence([]) is None"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function 'get_odd_occurrence' to find the element occurring odd number of times.",
        "instruction": "The function should be able to handle lists with multiple elements occurring an odd number of times and return a list of such elements. The parameter should be annotated as arr: list, arr_size: int, and the return type should be annotated as int.",
        "code_before": "def get_odd_occurrence(lst):\n    counts = {}\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    for num, count in counts.items():\n        if count % 2 != 0:\n            return num\n    return None\n",
        "base_tests": [
            "assert get_odd_occurrence([1,2,3,1,2,3,1],7) == 1",
            "assert get_odd_occurrence([1,2,3,2,3,1,3],7) == 3",
            "assert get_odd_occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"
        ],
        "tests": [
            "assert get_odd_occurrence([1, 2, 3, 1, 2, 3, 1, 3]) == [1, 3]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function 'get_odd_occurrence' to find the element occurring odd number of times.",
        "instruction": "The function should include type annotations for its parameters and return type, including two parameters: 'arr': list, 'arr_size': int, and a return type: int.",
        "code_before": "def get_odd_occurrence(lst):\n    counts = {}\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    for num, count in counts.items():\n        if count % 2 != 0:\n            return num\n    return None\n",
        "base_tests": [
            "assert get_odd_occurrence([1,2,3,1,2,3,1],7) == 1",
            "assert get_odd_occurrence([1,2,3,2,3,1,3],7) == 3",
            "assert get_odd_occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"
        ],
        "tests": [
            "assert get_odd_occurrence.__annotations__ == {'arr': list, 'arr_size': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function 'get_odd_occurrence' to find the element occurring odd number of times.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def get_odd_occurrence(lst):\n    counts = {}\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    for num, count in counts.items():\n        if count % 2 != 0:\n            return num\n    return None\n",
        "base_tests": [
            "assert get_odd_occurrence([1,2,3,1,2,3,1],7) == 1",
            "assert get_odd_occurrence([1,2,3,2,3,1,3],7) == 3",
            "assert get_odd_occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(get_odd_occurrence)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'count_substring_with_equal_ends' to count all the substrings starting and ending with same characters.",
        "instruction": "The function should accept a string input and return an integer representing the count of substrings starting and ending with the same character.",
        "code_before": "def count_substring_with_equal_ends(input_string):\n    count = 0\n    n = len(input_string)\n    for i in range(n):\n        for j in range(i, n):\n            if input_string[i] == input_string[j]:\n                count += 1\n    return count\n",
        "base_tests": [
            "assert count_substring_with_equal_ends(\"abc\") == 3",
            "assert count_substring_with_equal_ends(\"abcda\") == 6",
            "assert count_substring_with_equal_ends(\"ab\") == 2"
        ],
        "tests": [
            "assert isinstance(count_substring_with_equal_ends('abc'), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'count_substring_with_equal_ends' to count all the substrings starting and ending with same characters.",
        "instruction": "The function should raise a TypeError if the input is not a string.",
        "code_before": "def count_substring_with_equal_ends(input_string):\n    count = 0\n    n = len(input_string)\n    for i in range(n):\n        for j in range(i, n):\n            if input_string[i] == input_string[j]:\n                count += 1\n    return count\n",
        "base_tests": [
            "assert count_substring_with_equal_ends(\"abc\") == 3",
            "assert count_substring_with_equal_ends(\"abcda\") == 6",
            "assert count_substring_with_equal_ends(\"ab\") == 2"
        ],
        "tests": [
            "try: count_substring_with_equal_ends(123)\n    assert False, 'Expected TypeError'\nexcept TypeError: pass"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'count_substring_with_equal_ends' to count all the substrings starting and ending with same characters.",
        "instruction": "The function should return 0 for an empty string input.",
        "code_before": "def count_substring_with_equal_ends(input_string):\n    count = 0\n    n = len(input_string)\n    for i in range(n):\n        for j in range(i, n):\n            if input_string[i] == input_string[j]:\n                count += 1\n    return count\n",
        "base_tests": [
            "assert count_substring_with_equal_ends(\"abc\") == 3",
            "assert count_substring_with_equal_ends(\"abcda\") == 6",
            "assert count_substring_with_equal_ends(\"ab\") == 2"
        ],
        "tests": [
            "assert count_substring_with_equal_ends('') == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'count_substring_with_equal_ends' to count all the substrings starting and ending with same characters.",
        "instruction": "Extend the function to handle strings with special characters and spaces, but only count alphabetic characters.",
        "code_before": "def count_substring_with_equal_ends(input_string):\n    count = 0\n    n = len(input_string)\n    for i in range(n):\n        for j in range(i, n):\n            if input_string[i] == input_string[j]:\n                count += 1\n    return count\n",
        "base_tests": [
            "assert count_substring_with_equal_ends(\"abc\") == 3",
            "assert count_substring_with_equal_ends(\"abcda\") == 6",
            "assert count_substring_with_equal_ends(\"ab\") == 2"
        ],
        "tests": [
            "assert count_substring_with_equal_ends('a b a') == 4"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'count_substring_with_equal_ends' to count all the substrings starting and ending with same characters.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 's': str, and the return type should be annotated as int.",
        "code_before": "def count_substring_with_equal_ends(input_string):\n    count = 0\n    n = len(input_string)\n    for i in range(n):\n        for j in range(i, n):\n            if input_string[i] == input_string[j]:\n                count += 1\n    return count\n",
        "base_tests": [
            "assert count_substring_with_equal_ends(\"abc\") == 3",
            "assert count_substring_with_equal_ends(\"abcda\") == 6",
            "assert count_substring_with_equal_ends(\"ab\") == 2"
        ],
        "tests": [
            "assert count_substring_with_equal_ends.__annotations__ == {'s': str, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'count_substring_with_equal_ends' to count all the substrings starting and ending with same characters.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def count_substring_with_equal_ends(input_string):\n    count = 0\n    n = len(input_string)\n    for i in range(n):\n        for j in range(i, n):\n            if input_string[i] == input_string[j]:\n                count += 1\n    return count\n",
        "base_tests": [
            "assert count_substring_with_equal_ends(\"abc\") == 3",
            "assert count_substring_with_equal_ends(\"abcda\") == 6",
            "assert count_substring_with_equal_ends(\"ab\") == 2"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(count_substring_with_equal_ends)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function named 'func' to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.",
        "instruction": "The function should raise a ValueError as 'k cannot be greater than the number of distinct integers' if k is greater than the total number of distinct integers across all lists.",
        "code_before": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n    \n    # Count the frequency of each integer\n    counter = Counter(flat_list)\n    \n    # Use a heap to find the top k integers\n    heap = []\n    for num, freq in counter.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        else:\n            if freq > heap[0][0]:\n                heapq.heapreplace(heap, (freq, num))\n    \n    # Return the top k integers\n    return [num for freq, num in heap]\n",
        "base_tests": [
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"
        ],
        "tests": [
            "try:\n    func([[1, 2], [3, 4]], 5)\nexcept ValueError as e:\n    assert str(e) == 'k cannot be greater than the number of distinct integers'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function named 'func' to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.",
        "instruction": "The function should return an empty list if all input lists are empty.",
        "code_before": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n    \n    # Count the frequency of each integer\n    counter = Counter(flat_list)\n    \n    # Use a heap to find the top k integers\n    heap = []\n    for num, freq in counter.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        else:\n            if freq > heap[0][0]:\n                heapq.heapreplace(heap, (freq, num))\n    \n    # Return the top k integers\n    return [num for freq, num in heap]\n",
        "base_tests": [
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"
        ],
        "tests": [
            "assert func([[], [], []], 0) == []"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function named 'func' to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.",
        "instruction": "Extend the function to handle cases where k is zero, returning an empty list.",
        "code_before": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n    \n    # Count the frequency of each integer\n    counter = Counter(flat_list)\n    \n    # Use a heap to find the top k integers\n    heap = []\n    for num, freq in counter.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        else:\n            if freq > heap[0][0]:\n                heapq.heapreplace(heap, (freq, num))\n    \n    # Return the top k integers\n    return [num for freq, num in heap]\n",
        "base_tests": [
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"
        ],
        "tests": [
            "assert func([[1, 2, 3], [4, 5, 6]], 0) == []"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function named 'func' to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'nums': List[List[int]], 'k': int, and the return type should be annotated as List[int].",
        "code_before": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n    \n    # Count the frequency of each integer\n    counter = Counter(flat_list)\n    \n    # Use a heap to find the top k integers\n    heap = []\n    for num, freq in counter.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        else:\n            if freq > heap[0][0]:\n                heapq.heapreplace(heap, (freq, num))\n    \n    # Return the top k integers\n    return [num for freq, num in heap]\n",
        "base_tests": [
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"
        ],
        "tests": [
            "assert 'def func(nums: List[List[int]], k: int) -> List[int]:' in inspect.getsource(func)"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function named 'func' to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper indentation and spacing.",
        "code_before": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n    \n    # Count the frequency of each integer\n    counter = Counter(flat_list)\n    \n    # Use a heap to find the top k integers\n    heap = []\n    for num, freq in counter.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (freq, num))\n        else:\n            if freq > heap[0][0]:\n                heapq.heapreplace(heap, (freq, num))\n    \n    # Return the top k integers\n    return [num for freq, num in heap]\n",
        "base_tests": [
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(func)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.",
        "instruction": "The function should accept a positive integer as input and return the largest prime factor as an integer.",
        "code_before": "def max_prime_factors(n):\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n    if n > 2:\n        max_prime = n\n    return int(max_prime)\n",
        "base_tests": [
            "assert max_prime_factors(15) == 5",
            "assert max_prime_factors(6) == 3",
            "assert max_prime_factors(2) == 2"
        ],
        "tests": [
            "assert isinstance(max_prime_factors(15), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.",
        "instruction": "The function should raise a ValueError as 'Input must be a positive integer' with a descriptive error message if the input is not a positive integer.",
        "code_before": "def max_prime_factors(n):\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n    if n > 2:\n        max_prime = n\n    return int(max_prime)\n",
        "base_tests": [
            "assert max_prime_factors(15) == 5",
            "assert max_prime_factors(6) == 3",
            "assert max_prime_factors(2) == 2"
        ],
        "tests": [
            "try:\n    max_prime_factors(-10)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a positive integer'\ntry:\n    max_prime_factors(0)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a positive integer' "
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.",
        "instruction": "The function should correctly handle the smallest prime number, which is 2, and return 2 as its largest prime factor.",
        "code_before": "def max_prime_factors(n):\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n    if n > 2:\n        max_prime = n\n    return int(max_prime)\n",
        "base_tests": [
            "assert max_prime_factors(15) == 5",
            "assert max_prime_factors(6) == 3",
            "assert max_prime_factors(2) == 2"
        ],
        "tests": [
            "assert max_prime_factors(2) == 2"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.",
        "instruction": "Extend the function to return a list of prime factors of the given number. Add a parameter return_all (default value False). When return_all is True, return all the prime factors, otherwise return only the largest prime factor.",
        "code_before": "def max_prime_factors(n):\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n    if n > 2:\n        max_prime = n\n    return int(max_prime)\n",
        "base_tests": [
            "assert max_prime_factors(15) == 5",
            "assert max_prime_factors(6) == 3",
            "assert max_prime_factors(2) == 2"
        ],
        "tests": [
            "assert max_prime_factors(15, return_all=True) == [3, 5]",
            "assert max_prime_factors(6, return_all=True) == [2, 3]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as int.",
        "code_before": "def max_prime_factors(n):\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n    if n > 2:\n        max_prime = n\n    return int(max_prime)\n",
        "base_tests": [
            "assert max_prime_factors(15) == 5",
            "assert max_prime_factors(6) == 3",
            "assert max_prime_factors(2) == 2"
        ],
        "tests": [
            "assert max_prime_factors.__annotations__ == {'n': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.",
        "instruction": "The function should have a cyclomatic complexity of 5 or less.",
        "code_before": "def max_prime_factors(n):\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n    if n > 2:\n        max_prime = n\n    return int(max_prime)\n",
        "base_tests": [
            "assert max_prime_factors(15) == 5",
            "assert max_prime_factors(6) == 3",
            "assert max_prime_factors(2) == 2"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(max_prime_factors))[0].complexity <= 5"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def max_prime_factors(n):\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n >>= 1\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n    if n > 2:\n        max_prime = n\n    return int(max_prime)\n",
        "base_tests": [
            "assert max_prime_factors(15) == 5",
            "assert max_prime_factors(6) == 3",
            "assert max_prime_factors(2) == 2"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(max_prime_factors)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'decimal_to_binary' to convert a decimal number to binary number.",
        "instruction": "The function should raise a ValueError if the input is not a non-negative integer.",
        "code_before": "def decimal_to_binary(n):\n    return bin(n).replace(\"0b\", \"\")\n",
        "base_tests": [
            "assert decimal_to_binary(10) == 1010",
            "assert decimal_to_binary(1) == 1",
            "assert decimal_to_binary(20) == 10100"
        ],
        "tests": [
            "try: decimal_to_binary(-1)\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError'",
            "try: decimal_to_binary('10')\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'decimal_to_binary' to convert a decimal number to binary number.",
        "instruction": "The function should correctly handle the edge case where the input is zero.",
        "code_before": "def decimal_to_binary(n):\n    return bin(n).replace(\"0b\", \"\")\n",
        "base_tests": [
            "assert decimal_to_binary(10) == 1010",
            "assert decimal_to_binary(1) == 1",
            "assert decimal_to_binary(20) == 10100"
        ],
        "tests": [
            "assert decimal_to_binary(0) == '0'"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'decimal_to_binary' to convert a decimal number to binary number.",
        "instruction": "Extend the function to handle a list of decimal numbers, returning a list of binary strings.",
        "code_before": "def decimal_to_binary(n):\n    return bin(n).replace(\"0b\", \"\")\n",
        "base_tests": [
            "assert decimal_to_binary(10) == 1010",
            "assert decimal_to_binary(1) == 1",
            "assert decimal_to_binary(20) == 10100"
        ],
        "tests": [
            "assert decimal_to_binary([10, 1, 20]) == ['1010', '1', '10100']",
            "assert decimal_to_binary([0, 5]) == ['0', '101']"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'decimal_to_binary' to convert a decimal number to binary number.",
        "instruction": "The function should include type annotations for input parameters and return type. The parameter should be annotated as 'N': int, and the return type should be annotated as str.",
        "code_before": "def decimal_to_binary(n):\n    return bin(n).replace(\"0b\", \"\")\n",
        "base_tests": [
            "assert decimal_to_binary(10) == 1010",
            "assert decimal_to_binary(1) == 1",
            "assert decimal_to_binary(20) == 10100"
        ],
        "tests": [
            "assert 'def decimal_to_binary(N: int) -> str:' in inspect.getsource(decimal_to_binary)"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'decimal_to_binary' to convert a decimal number to binary number.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple linear function.",
        "code_before": "def decimal_to_binary(n):\n    return bin(n).replace(\"0b\", \"\")\n",
        "base_tests": [
            "assert decimal_to_binary(10) == 1010",
            "assert decimal_to_binary(1) == 1",
            "assert decimal_to_binary(20) == 10100"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(decimal_to_binary))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'decimal_to_binary' to convert a decimal number to binary number.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def decimal_to_binary(n):\n    return bin(n).replace(\"0b\", \"\")\n",
        "base_tests": [
            "assert decimal_to_binary(10) == 1010",
            "assert decimal_to_binary(1) == 1",
            "assert decimal_to_binary(20) == 10100"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(decimal_to_binary)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'find_missing' to find the missing number in a sorted array.",
        "instruction": "The function should raise a ValueError with a descriptive message as 'Input list must be sorted.' if the input list is not sorted.",
        "code_before": "def find_missing(arr):\n    n = len(arr)\n    total = ((n + 1) * (n + 2)) / 2\n    sum_of_arr = sum(arr)\n    return total - sum_of_arr\n",
        "base_tests": [
            "assert find_missing([1,2,3,5],4) == 4",
            "assert find_missing([1,3,4,5],4) == 2",
            "assert find_missing([1,2,3,5,6,7],5) == 4"
        ],
        "tests": [
            "try:\n    find_missing([3,1,2,4], 4)\nexcept ValueError as e:\n    assert str(e) == 'Input list must be sorted.'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'find_missing' to find the missing number in a sorted array.",
        "instruction": "The function should correctly handle the edge case where the missing number is the smallest number in the sequence.",
        "code_before": "def find_missing(arr):\n    n = len(arr)\n    total = ((n + 1) * (n + 2)) / 2\n    sum_of_arr = sum(arr)\n    return total - sum_of_arr\n",
        "base_tests": [
            "assert find_missing([1,2,3,5],4) == 4",
            "assert find_missing([1,3,4,5],4) == 2",
            "assert find_missing([1,2,3,5,6,7],5) == 4"
        ],
        "tests": [
            "assert find_missing([2,3,4,5], 4) == 1"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'find_missing' to find the missing number in a sorted array.",
        "instruction": "Extend the function to handle cases where multiple numbers are missing, returning a list of all missing numbers.",
        "code_before": "def find_missing(arr):\n    n = len(arr)\n    total = ((n + 1) * (n + 2)) / 2\n    sum_of_arr = sum(arr)\n    return total - sum_of_arr\n",
        "base_tests": [
            "assert find_missing([1,2,3,5],4) == 4",
            "assert find_missing([1,3,4,5],4) == 2",
            "assert find_missing([1,2,3,5,6,7],5) == 4"
        ],
        "tests": [
            "assert find_missing([1,3,6], 3) == [2, 4, 5]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'find_missing' to find the missing number in a sorted array.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'ar': list, 'N': int, and the return type should be annotated as int.",
        "code_before": "def find_missing(arr):\n    n = len(arr)\n    total = ((n + 1) * (n + 2)) / 2\n    sum_of_arr = sum(arr)\n    return total - sum_of_arr\n",
        "base_tests": [
            "assert find_missing([1,2,3,5],4) == 4",
            "assert find_missing([1,3,4,5],4) == 2",
            "assert find_missing([1,2,3,5,6,7],5) == 4"
        ],
        "tests": [
            "assert find_missing.__annotations__ == {'ar': list, 'N': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'find_missing' to find the missing number in a sorted array.",
        "instruction": "The function should follow PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def find_missing(arr):\n    n = len(arr)\n    total = ((n + 1) * (n + 2)) / 2\n    sum_of_arr = sum(arr)\n    return total - sum_of_arr\n",
        "base_tests": [
            "assert find_missing([1,2,3,5],4) == 4",
            "assert find_missing([1,3,4,5],4) == 2",
            "assert find_missing([1,2,3,5,6,7],5) == 4"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_missing)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.",
        "instruction": "The function should accept a single integer input and return an integer output representing the n-th rectangular number.",
        "code_before": "def find_rect_num(n):\n    return n * (n + 1) * (2 * n + 1) // 6\n",
        "base_tests": [
            "assert find_rect_num(4) == 20",
            "assert find_rect_num(5) == 30",
            "assert find_rect_num(6) == 42"
        ],
        "tests": [
            "assert isinstance(find_rect_num(7), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.",
        "instruction": "The function should raise a ValueError if the input is not a positive integer.",
        "code_before": "def find_rect_num(n):\n    return n * (n + 1) * (2 * n + 1) // 6\n",
        "base_tests": [
            "assert find_rect_num(4) == 20",
            "assert find_rect_num(5) == 30",
            "assert find_rect_num(6) == 42"
        ],
        "tests": [
            "try: find_rect_num(-1)\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError for negative input'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.",
        "instruction": "The function should correctly handle the edge case where n is 1, returning 2 as the first rectangular number.",
        "code_before": "def find_rect_num(n):\n    return n * (n + 1) * (2 * n + 1) // 6\n",
        "base_tests": [
            "assert find_rect_num(4) == 20",
            "assert find_rect_num(5) == 30",
            "assert find_rect_num(6) == 42"
        ],
        "tests": [
            "assert find_rect_num(1) == 2"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.",
        "instruction": "Extend the function to handle a list of integers, returning a list of corresponding rectangular numbers.",
        "code_before": "def find_rect_num(n):\n    return n * (n + 1) * (2 * n + 1) // 6\n",
        "base_tests": [
            "assert find_rect_num(4) == 20",
            "assert find_rect_num(5) == 30",
            "assert find_rect_num(6) == 42"
        ],
        "tests": [
            "assert find_rect_num([1, 2, 3]) == [2, 6, 12]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as int.",
        "code_before": "def find_rect_num(n):\n    return n * (n + 1) * (2 * n + 1) // 6\n",
        "base_tests": [
            "assert find_rect_num(4) == 20",
            "assert find_rect_num(5) == 30",
            "assert find_rect_num(6) == 42"
        ],
        "tests": [
            "assert find_rect_num.__annotations__ == {'n': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a straightforward implementation without unnecessary branching.",
        "code_before": "def find_rect_num(n):\n    return n * (n + 1) * (2 * n + 1) // 6\n",
        "base_tests": [
            "assert find_rect_num(4) == 20",
            "assert find_rect_num(5) == 30",
            "assert find_rect_num(6) == 42"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(find_rect_num))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def find_rect_num(n):\n    return n * (n + 1) * (2 * n + 1) // 6\n",
        "base_tests": [
            "assert find_rect_num(4) == 20",
            "assert find_rect_num(5) == 30",
            "assert find_rect_num(6) == 42"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_rect_num)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.",
        "instruction": "The function should accept two integers as input and return an integer representing the nth digit of the decimal representation of the fraction.",
        "code_before": "def find_nth_digit(num1, num2, n):\n    fraction = num1 / num2\n    fraction_str = str(fraction)\n    if n <= len(fraction_str):\n        return int(fraction_str[n])\n    else:\n        return 0\n",
        "base_tests": [
            "assert find_nth_digit(1,2,1) == 5",
            "assert find_nth_digit(3,5,1) == 6",
            "assert find_nth_digit(5,6,5) == 3"
        ],
        "tests": [
            "assert isinstance(find_nth_digit(1, 2, 1), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.",
        "instruction": "The function should raise a ValueError as 'Denominator cannot be zero' if the denominator is zero, as division by zero is undefined.",
        "code_before": "def find_nth_digit(num1, num2, n):\n    fraction = num1 / num2\n    fraction_str = str(fraction)\n    if n <= len(fraction_str):\n        return int(fraction_str[n])\n    else:\n        return 0\n",
        "base_tests": [
            "assert find_nth_digit(1,2,1) == 5",
            "assert find_nth_digit(3,5,1) == 6",
            "assert find_nth_digit(5,6,5) == 3"
        ],
        "tests": [
            "try:\n    find_nth_digit(1, 0, 1)\nexcept ValueError as e:\n    assert str(e) == 'Denominator cannot be zero'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.",
        "instruction": "The function should correctly handle the case where the numerator is zero, returning 0 for any nth digit.",
        "code_before": "def find_nth_digit(num1, num2, n):\n    fraction = num1 / num2\n    fraction_str = str(fraction)\n    if n <= len(fraction_str):\n        return int(fraction_str[n])\n    else:\n        return 0\n",
        "base_tests": [
            "assert find_nth_digit(1,2,1) == 5",
            "assert find_nth_digit(3,5,1) == 6",
            "assert find_nth_digit(5,6,5) == 3"
        ],
        "tests": [
            "assert find_nth_digit(0, 5, 1) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.",
        "instruction": "Extend the function to handle negative numerators and denominators, returning the nth digit of the absolute value of the fraction.",
        "code_before": "def find_nth_digit(num1, num2, n):\n    fraction = num1 / num2\n    fraction_str = str(fraction)\n    if n <= len(fraction_str):\n        return int(fraction_str[n])\n    else:\n        return 0\n",
        "base_tests": [
            "assert find_nth_digit(1,2,1) == 5",
            "assert find_nth_digit(3,5,1) == 6",
            "assert find_nth_digit(5,6,5) == 3"
        ],
        "tests": [
            "assert find_nth_digit(-1, 2, 1) == 5"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.",
        "instruction": "The function should include type annotations for all parameters and the return type. The parameter should be annotated as 'p': int, 'q': int, 'N': int, and the return type should be annotated as int.",
        "code_before": "def find_nth_digit(num1, num2, n):\n    fraction = num1 / num2\n    fraction_str = str(fraction)\n    if n <= len(fraction_str):\n        return int(fraction_str[n])\n    else:\n        return 0\n",
        "base_tests": [
            "assert find_nth_digit(1,2,1) == 5",
            "assert find_nth_digit(3,5,1) == 6",
            "assert find_nth_digit(5,6,5) == 3"
        ],
        "tests": [
            "assert find_nth_digit.__annotations__ == {'p': int, 'q': int, 'N': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.",
        "instruction": "The function should have a cyclomatic complexity of 5 or less to ensure maintainability.",
        "code_before": "def find_nth_digit(num1, num2, n):\n    fraction = num1 / num2\n    fraction_str = str(fraction)\n    if n <= len(fraction_str):\n        return int(fraction_str[n])\n    else:\n        return 0\n",
        "base_tests": [
            "assert find_nth_digit(1,2,1) == 5",
            "assert find_nth_digit(3,5,1) == 6",
            "assert find_nth_digit(5,6,5) == 3"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(find_nth_digit))[0].complexity <= 5"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation, naming conventions, and spacing.",
        "code_before": "def find_nth_digit(num1, num2, n):\n    fraction = num1 / num2\n    fraction_str = str(fraction)\n    if n <= len(fraction_str):\n        return int(fraction_str[n])\n    else:\n        return 0\n",
        "base_tests": [
            "assert find_nth_digit(1,2,1) == 5",
            "assert find_nth_digit(3,5,1) == 6",
            "assert find_nth_digit(5,6,5) == 3"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_nth_digit)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'sort_mixed_list' to sort a given mixed list of integers and strings.",
        "instruction": "The function should raise a TypeError if the input is not a list or if the list contains elements that are neither integers nor strings.",
        "code_before": "def sort_mixed_list(mixed_list):\n    int_list = sorted([i for i in mixed_list if isinstance(i, int)])\n    str_list = sorted([s for s in mixed_list if isinstance(s, str)])\n    return int_list + str_list\n",
        "base_tests": [
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"
        ],
        "tests": [
            "try:\n    sort_mixed_list('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'Expected TypeError'\n\ntry:\n    sort_mixed_list([1, 'apple', 3.5])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'Expected TypeError'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'sort_mixed_list' to sort a given mixed list of integers and strings.",
        "instruction": "The function should correctly handle an empty list by returning an empty list.",
        "code_before": "def sort_mixed_list(mixed_list):\n    int_list = sorted([i for i in mixed_list if isinstance(i, int)])\n    str_list = sorted([s for s in mixed_list if isinstance(s, str)])\n    return int_list + str_list\n",
        "base_tests": [
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"
        ],
        "tests": [
            "assert sort_mixed_list([]) == []"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'sort_mixed_list' to sort a given mixed list of integers and strings.",
        "instruction": "Extend the function to optionally sort strings in reverse lexicographical order if a parameter 'reverse_strings' is set to True.",
        "code_before": "def sort_mixed_list(mixed_list):\n    int_list = sorted([i for i in mixed_list if isinstance(i, int)])\n    str_list = sorted([s for s in mixed_list if isinstance(s, str)])\n    return int_list + str_list\n",
        "base_tests": [
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"
        ],
        "tests": [
            "assert sort_mixed_list([3, 'banana', 2, 'apple', 1, 'cherry'], reverse_strings=True) == [1, 2, 3, 'cherry', 'banana', 'apple']"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'sort_mixed_list' to sort a given mixed list of integers and strings.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'mixed_list': list[Union[int, str]], and the return type should be annotated as list[Union[int, str]].",
        "code_before": "def sort_mixed_list(mixed_list):\n    int_list = sorted([i for i in mixed_list if isinstance(i, int)])\n    str_list = sorted([s for s in mixed_list if isinstance(s, str)])\n    return int_list + str_list\n",
        "base_tests": [
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"
        ],
        "tests": [
            "from typing import Union\nassert sort_mixed_list.__annotations__ == {'mixed_list': list[Union[int, str]], 'return' : list}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'sort_mixed_list' to sort a given mixed list of integers and strings.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def sort_mixed_list(mixed_list):\n    int_list = sorted([i for i in mixed_list if isinstance(i, int)])\n    str_list = sorted([s for s in mixed_list if isinstance(s, str)])\n    return int_list + str_list\n",
        "base_tests": [
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(sort_mixed_list)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.",
        "instruction": "The function should accept a list of integers and return a float or integer representing the division of the first even number by the first odd number.",
        "code_before": "def div_even_odd(lst):\n    even = None\n    odd = None\n    for num in lst:\n        if num % 2 == 0:\n            even = num\n            if odd is not None:\n                break\n        else:\n            odd = num\n            if even is not None:\n                break\n    if even is None or odd is None:\n        return None\n    return even / odd\n",
        "base_tests": [
            "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
            "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
            "assert div_even_odd([1,5,7,9,10])==10"
        ],
        "tests": [
            "assert isinstance(div_even_odd([2, 3, 4, 5]), (int, float))"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.",
        "instruction": "The function should raise a ValueError with a descriptive message as 'List must contain at least one even and one odd number.' if the list does not contain at least one even and one odd number.",
        "code_before": "def div_even_odd(lst):\n    even = None\n    odd = None\n    for num in lst:\n        if num % 2 == 0:\n            even = num\n            if odd is not None:\n                break\n        else:\n            odd = num\n            if even is not None:\n                break\n    if even is None or odd is None:\n        return None\n    return even / odd\n",
        "base_tests": [
            "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
            "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
            "assert div_even_odd([1,5,7,9,10])==10"
        ],
        "tests": [
            "try:\n    div_even_odd([2, 4, 6])\n    assert False\nexcept ValueError as e: assert str(e) == 'List must contain at least one even and one odd number.'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.",
        "instruction": "The function should correctly handle lists where the first even or odd number is zero, returning zero if the first even number is zero.",
        "code_before": "def div_even_odd(lst):\n    even = None\n    odd = None\n    for num in lst:\n        if num % 2 == 0:\n            even = num\n            if odd is not None:\n                break\n        else:\n            odd = num\n            if even is not None:\n                break\n    if even is None or odd is None:\n        return None\n    return even / odd\n",
        "base_tests": [
            "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
            "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
            "assert div_even_odd([1,5,7,9,10])==10"
        ],
        "tests": [
            "assert div_even_odd([0, 1, 2, 3]) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.",
        "instruction": "Extend the function to handle lists with negative numbers, correctly performing division with negative values.",
        "code_before": "def div_even_odd(lst):\n    even = None\n    odd = None\n    for num in lst:\n        if num % 2 == 0:\n            even = num\n            if odd is not None:\n                break\n        else:\n            odd = num\n            if even is not None:\n                break\n    if even is None or odd is None:\n        return None\n    return even / odd\n",
        "base_tests": [
            "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
            "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
            "assert div_even_odd([1,5,7,9,10])==10"
        ],
        "tests": [
            "assert div_even_odd([-2, 3, 4, 5]) == -2 / 3"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'list1': list, and a return type: (int, float).",
        "code_before": "def div_even_odd(lst):\n    even = None\n    odd = None\n    for num in lst:\n        if num % 2 == 0:\n            even = num\n            if odd is not None:\n                break\n        else:\n            odd = num\n            if even is not None:\n                break\n    if even is None or odd is None:\n        return None\n    return even / odd\n",
        "base_tests": [
            "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
            "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
            "assert div_even_odd([1,5,7,9,10])==10"
        ],
        "tests": [
            "assert div_even_odd.__annotations__ == {'list1': list, 'return': (int, float)}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.",
        "instruction": "The function should have a cyclomatic complexity of 3 or less.",
        "code_before": "def div_even_odd(lst):\n    even = None\n    odd = None\n    for num in lst:\n        if num % 2 == 0:\n            even = num\n            if odd is not None:\n                break\n        else:\n            odd = num\n            if even is not None:\n                break\n    if even is None or odd is None:\n        return None\n    return even / odd\n",
        "base_tests": [
            "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
            "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
            "assert div_even_odd([1,5,7,9,10])==10"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(div_even_odd))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation and spacing.",
        "code_before": "def div_even_odd(lst):\n    even = None\n    odd = None\n    for num in lst:\n        if num % 2 == 0:\n            even = num\n            if odd is not None:\n                break\n        else:\n            odd = num\n            if even is not None:\n                break\n    if even is None or odd is None:\n        return None\n    return even / odd\n",
        "base_tests": [
            "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
            "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
            "assert div_even_odd([1,5,7,9,10])==10"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(div_even_odd)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function  called 'rearange_string' to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
        "instruction": "The function should accept a string as input and return a string where no two adjacent characters are the same. The input should be a non-empty string consisting only of lowercase letters.",
        "code_before": "def rearange_string(s):\n    freq = [0]*26\n    for char in s:\n        freq[ord(char) - ord('a')] += 1\n    max_freq = max(freq)\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    res = [None]*len(s)\n    idx = 0\n    for i in range(26):\n        while freq[i] > 0:\n            if idx >= len(s):\n                idx = 1\n            res[idx] = chr(i + ord('a'))\n            idx += 2\n            freq[i] -= 1\n    return \"\".join(res)\n",
        "base_tests": [
            "assert rearange_string(\"aab\")==('aba')",
            "assert rearange_string(\"aabb\")==('abab')",
            "assert rearange_string(\"abccdd\")==('cdabcd')"
        ],
        "tests": [
            "assert isinstance(rearange_string('abc'), str)\nassert rearange_string('') == ''"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function  called 'rearange_string' to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
        "instruction": "The function should raise a ValueError if the input is not a string or if it contains characters other than lowercase letters.",
        "code_before": "def rearange_string(s):\n    freq = [0]*26\n    for char in s:\n        freq[ord(char) - ord('a')] += 1\n    max_freq = max(freq)\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    res = [None]*len(s)\n    idx = 0\n    for i in range(26):\n        while freq[i] > 0:\n            if idx >= len(s):\n                idx = 1\n            res[idx] = chr(i + ord('a'))\n            idx += 2\n            freq[i] -= 1\n    return \"\".join(res)\n",
        "base_tests": [
            "assert rearange_string(\"aab\")==('aba')",
            "assert rearange_string(\"aabb\")==('abab')",
            "assert rearange_string(\"abccdd\")==('cdabcd')"
        ],
        "tests": [
            "try:\n    rearange_string(123)\nexcept ValueError:\n    pass\nelse:\n    assert False\ntry:\n    rearange_string('abc123')\nexcept ValueError:\n    pass\nelse:\n    assert False"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function  called 'rearange_string' to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
        "instruction": "The function should handle edge cases such as strings with all identical characters by returning an empty string, as rearrangement is not possible.",
        "code_before": "def rearange_string(s):\n    freq = [0]*26\n    for char in s:\n        freq[ord(char) - ord('a')] += 1\n    max_freq = max(freq)\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    res = [None]*len(s)\n    idx = 0\n    for i in range(26):\n        while freq[i] > 0:\n            if idx >= len(s):\n                idx = 1\n            res[idx] = chr(i + ord('a'))\n            idx += 2\n            freq[i] -= 1\n    return \"\".join(res)\n",
        "base_tests": [
            "assert rearange_string(\"aab\")==('aba')",
            "assert rearange_string(\"aabb\")==('abab')",
            "assert rearange_string(\"abccdd\")==('cdabcd')"
        ],
        "tests": [
            "assert rearange_string('aaaa') == ''\nassert rearange_string('') == ''"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function  called 'rearange_string' to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
        "instruction": "Extend the function to return all possible valid rearrangements if more than one exists.",
        "code_before": "def rearange_string(s):\n    freq = [0]*26\n    for char in s:\n        freq[ord(char) - ord('a')] += 1\n    max_freq = max(freq)\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    res = [None]*len(s)\n    idx = 0\n    for i in range(26):\n        while freq[i] > 0:\n            if idx >= len(s):\n                idx = 1\n            res[idx] = chr(i + ord('a'))\n            idx += 2\n            freq[i] -= 1\n    return \"\".join(res)\n",
        "base_tests": [
            "assert rearange_string(\"aab\")==('aba')",
            "assert rearange_string(\"aabb\")==('abab')",
            "assert rearange_string(\"abccdd\")==('cdabcd')"
        ],
        "tests": [
            "assert set(rearange_string('aabb')) == {'abab', 'baba'}"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function  called 'rearange_string' to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'S': str, and a return type: str, and should have a docstring explaining its purpose and usage: 'Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.'",
        "code_before": "def rearange_string(s):\n    freq = [0]*26\n    for char in s:\n        freq[ord(char) - ord('a')] += 1\n    max_freq = max(freq)\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    res = [None]*len(s)\n    idx = 0\n    for i in range(26):\n        while freq[i] > 0:\n            if idx >= len(s):\n                idx = 1\n            res[idx] = chr(i + ord('a'))\n            idx += 2\n            freq[i] -= 1\n    return \"\".join(res)\n",
        "base_tests": [
            "assert rearange_string(\"aab\")==('aba')",
            "assert rearange_string(\"aabb\")==('abab')",
            "assert rearange_string(\"abccdd\")==('cdabcd')"
        ],
        "tests": [
            "assert rearange_string.__annotations__ == {'S': str, 'return': str}\nassert rearange_string.__doc__ == 'Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.'"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function  called 'rearange_string' to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
        "instruction": "The code should adhere to PEP 8 standards, including proper indentation, spacing, and naming conventions.",
        "code_before": "def rearange_string(s):\n    freq = [0]*26\n    for char in s:\n        freq[ord(char) - ord('a')] += 1\n    max_freq = max(freq)\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    res = [None]*len(s)\n    idx = 0\n    for i in range(26):\n        while freq[i] > 0:\n            if idx >= len(s):\n                idx = 1\n            res[idx] = chr(i + ord('a'))\n            idx += 2\n            freq[i] -= 1\n    return \"\".join(res)\n",
        "base_tests": [
            "assert rearange_string(\"aab\")==('aba')",
            "assert rearange_string(\"aabb\")==('abab')",
            "assert rearange_string(\"abccdd\")==('cdabcd')"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(rearange_string)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'freq_element' to find frequency of the elements in a given list of lists using collections module.",
        "instruction": "The function should raise a TypeError if the input is not a list of lists.",
        "code_before": "from collections import Counter\n\ndef freq_element(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    freq_dict = dict(Counter(flat_list))\n    return freq_dict\n",
        "base_tests": [
            "assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})",
            "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})",
            "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"
        ],
        "tests": [
            "try\n    freq_element('not a list')\n    assert False\nexcept TypeError: assert True"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'freq_element' to find frequency of the elements in a given list of lists using collections module.",
        "instruction": "The function should return an empty dictionary if the input is an empty list.",
        "code_before": "from collections import Counter\n\ndef freq_element(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    freq_dict = dict(Counter(flat_list))\n    return freq_dict\n",
        "base_tests": [
            "assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})",
            "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})",
            "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"
        ],
        "tests": [
            "assert freq_element([]) == {}"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'freq_element' to find frequency of the elements in a given list of lists using collections module.",
        "instruction": "Extend the function to handle nested lists of arbitrary depth and return the frequency of all integers.",
        "code_before": "from collections import Counter\n\ndef freq_element(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    freq_dict = dict(Counter(flat_list))\n    return freq_dict\n",
        "base_tests": [
            "assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})",
            "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})",
            "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"
        ],
        "tests": [
            "assert freq_element([[1, [2, [3, 2]], 2], [4, 5, [6, 2]], [7, 1, [9, 5]]]) == {1: 2, 2: 4, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 9: 1}"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'freq_element' to find frequency of the elements in a given list of lists using collections module.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'nums': list[list[int]], and the return type should be annotated as dict[int, int].",
        "code_before": "from collections import Counter\n\ndef freq_element(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    freq_dict = dict(Counter(flat_list))\n    return freq_dict\n",
        "base_tests": [
            "assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})",
            "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})",
            "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"
        ],
        "tests": [
            "assert freq_element.__annotations__ == {'nums': 'list[list[int]]', 'return': 'dict[int, int]'}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'freq_element' to find frequency of the elements in a given list of lists using collections module.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a single path through the code.",
        "code_before": "from collections import Counter\n\ndef freq_element(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    freq_dict = dict(Counter(flat_list))\n    return freq_dict\n",
        "base_tests": [
            "assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})",
            "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})",
            "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(freq_element))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'freq_element' to find frequency of the elements in a given list of lists using collections module.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation and spacing.",
        "code_before": "from collections import Counter\n\ndef freq_element(lst):\n    flat_list = [item for sublist in lst for item in sublist]\n    freq_dict = dict(Counter(flat_list))\n    return freq_dict\n",
        "base_tests": [
            "assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})",
            "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})",
            "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(freq_element)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'filter_evennumbers' to filter even numbers using lambda function.",
        "instruction": "The function should raise a TypeError if the input is not a list of integers.",
        "code_before": "def filter_evennumbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n",
        "base_tests": [
            "assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]",
            "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]",
            "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]"
        ],
        "tests": [
            "try: filter_evennumbers('not a list')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'filter_evennumbers' to filter even numbers using lambda function.",
        "instruction": "The function should return an empty list if the input list is empty.",
        "code_before": "def filter_evennumbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n",
        "base_tests": [
            "assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]",
            "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]",
            "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]"
        ],
        "tests": [
            "assert filter_evennumbers([]) == []"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'filter_evennumbers' to filter even numbers using lambda function.",
        "instruction": "Extend the function to handle lists containing non-integer types by filtering them out before processing.",
        "code_before": "def filter_evennumbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n",
        "base_tests": [
            "assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]",
            "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]",
            "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]"
        ],
        "tests": [
            "assert filter_evennumbers([2, 'a', 4.5, 6, 'b']) == [2, 6]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'filter_evennumbers' to filter even numbers using lambda function.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'nums': list, and a return type: list.",
        "code_before": "def filter_evennumbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n",
        "base_tests": [
            "assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]",
            "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]",
            "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]"
        ],
        "tests": [
            "assert filter_evennumbers.__annotations__ == {'nums': list, 'return': list}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'filter_evennumbers' to filter even numbers using lambda function.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def filter_evennumbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n",
        "base_tests": [
            "assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]",
            "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]",
            "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(filter_evennumbers)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.",
        "instruction": "The function should return 0 if there are no repeated elements in the array.",
        "code_before": "def find_sum(arr):\n    sum_dict = {}\n    for num in arr:\n        if num in sum_dict:\n            sum_dict[num] += num\n        else:\n            sum_dict[num] = num\n    return sum(sum_dict.values())\n",
        "base_tests": [
            "assert find_sum([1,2,3,1,1,4,5,6],8) == 3",
            "assert find_sum([1,2,3,1,1],5) == 3",
            "assert find_sum([1,1,2],3) == 2"
        ],
        "tests": [
            "assert find_sum([1, 2, 3, 4, 5], 5) == 0"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.",
        "instruction": "The function should raise a TypeError if the input is not a list.",
        "code_before": "def find_sum(arr):\n    sum_dict = {}\n    for num in arr:\n        if num in sum_dict:\n            sum_dict[num] += num\n        else:\n            sum_dict[num] = num\n    return sum(sum_dict.values())\n",
        "base_tests": [
            "assert find_sum([1,2,3,1,1,4,5,6],8) == 3",
            "assert find_sum([1,2,3,1,1],5) == 3",
            "assert find_sum([1,1,2],3) == 2"
        ],
        "tests": [
            "try:\n    find_sum('not a list', 5)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.",
        "instruction": "The function should handle an empty array and return 0.",
        "code_before": "def find_sum(arr):\n    sum_dict = {}\n    for num in arr:\n        if num in sum_dict:\n            sum_dict[num] += num\n        else:\n            sum_dict[num] = num\n    return sum(sum_dict.values())\n",
        "base_tests": [
            "assert find_sum([1,2,3,1,1,4,5,6],8) == 3",
            "assert find_sum([1,2,3,1,1],5) == 3",
            "assert find_sum([1,1,2],3) == 2"
        ],
        "tests": [
            "assert find_sum([], 0) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.",
        "instruction": "The function should be able to handle arrays with negative numbers and return the correct sum of repeated elements.",
        "code_before": "def find_sum(arr):\n    sum_dict = {}\n    for num in arr:\n        if num in sum_dict:\n            sum_dict[num] += num\n        else:\n            sum_dict[num] = num\n    return sum(sum_dict.values())\n",
        "base_tests": [
            "assert find_sum([1,2,3,1,1,4,5,6],8) == 3",
            "assert find_sum([1,2,3,1,1],5) == 3",
            "assert find_sum([1,1,2],3) == 2"
        ],
        "tests": [
            "assert find_sum([-1, -2, -3, -1, -1], 5) == -2"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'arr': list, 'n': int, and the return type should be annotated as int.",
        "code_before": "def find_sum(arr):\n    sum_dict = {}\n    for num in arr:\n        if num in sum_dict:\n            sum_dict[num] += num\n        else:\n            sum_dict[num] = num\n    return sum(sum_dict.values())\n",
        "base_tests": [
            "assert find_sum([1,2,3,1,1,4,5,6],8) == 3",
            "assert find_sum([1,2,3,1,1],5) == 3",
            "assert find_sum([1,1,2],3) == 2"
        ],
        "tests": [
            "assert 'def find_sum(arr: list, n: int) -> int:' in inspect.getsource(find_sum)"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.",
        "instruction": "The function should have a cyclomatic complexity of 5 or less.",
        "code_before": "def find_sum(arr):\n    sum_dict = {}\n    for num in arr:\n        if num in sum_dict:\n            sum_dict[num] += num\n        else:\n            sum_dict[num] = num\n    return sum(sum_dict.values())\n",
        "base_tests": [
            "assert find_sum([1,2,3,1,1,4,5,6],8) == 3",
            "assert find_sum([1,2,3,1,1],5) == 3",
            "assert find_sum([1,1,2],3) == 2"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(find_sum))[0].complexity <=5"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.",
        "instruction": "The function should adhere to PEP 8 style guidelines.",
        "code_before": "def find_sum(arr):\n    sum_dict = {}\n    for num in arr:\n        if num in sum_dict:\n            sum_dict[num] += num\n        else:\n            sum_dict[num] = num\n    return sum(sum_dict.values())\n",
        "base_tests": [
            "assert find_sum([1,2,3,1,1,4,5,6],8) == 3",
            "assert find_sum([1,2,3,1,1],5) == 3",
            "assert find_sum([1,1,2],3) == 2"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_sum)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.",
        "instruction": "The function should return 'Not matched!' for any input that does not contain sequences of lowercase letters joined by an underscore.",
        "code_before": "import re\n\ndef text_match(text):\n    pattern = '^[a-z]+_[a-z]+$'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n",
        "base_tests": [
            "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
            "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
            "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
        ],
        "tests": [
            "assert text_match('123_456') == 'Not matched!'"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.",
        "instruction": "The function should raise a TypeError if the input is not a string.",
        "code_before": "import re\n\ndef text_match(text):\n    pattern = '^[a-z]+_[a-z]+$'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n",
        "base_tests": [
            "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
            "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
            "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
        ],
        "tests": [
            "try:\n    text_match(12345)\nexcept TypeError:\n    assert True\nelse:\n    assert False"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.",
        "instruction": "The function should return 'Not matched!' for an empty string input.",
        "code_before": "import re\n\ndef text_match(text):\n    pattern = '^[a-z]+_[a-z]+$'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n",
        "base_tests": [
            "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
            "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
            "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
        ],
        "tests": [
            "assert text_match('') == 'Not matched!'"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.",
        "instruction": "Extend the function to handle sequences of lowercase letters joined by multiple underscores.",
        "code_before": "import re\n\ndef text_match(text):\n    pattern = '^[a-z]+_[a-z]+$'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n",
        "base_tests": [
            "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
            "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
            "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
        ],
        "tests": [
            "assert text_match('abc_def_ghi') == 'Found a match!'"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'text': str, and the return type should be annotated as str.",
        "code_before": "import re\n\ndef text_match(text):\n    pattern = '^[a-z]+_[a-z]+$'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n",
        "base_tests": [
            "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
            "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
            "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
        ],
        "tests": [
            "assert text_match.__annotations__ == {'text': str, 'return': str}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple linear flow.",
        "code_before": "import re\n\ndef text_match(text):\n    pattern = '^[a-z]+_[a-z]+$'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n",
        "base_tests": [
            "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
            "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
            "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(text_match))[0].complexity ==1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper indentation and spacing.",
        "code_before": "import re\n\ndef text_match(text):\n    pattern = '^[a-z]+_[a-z]+$'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n",
        "base_tests": [
            "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
            "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
            "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(cc_visit)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'text_match_string' that matches a word at the beginning of a string.",
        "instruction": "The function should raise a TypeError if the input is not a string.",
        "code_before": "import re\n\ndef text_match_string(text):\n    pattern = '^The'\n    if re.search(pattern,  text):\n        return 'Found a match!'\n    else:\n        return('Not matched')\n\nprint(text_match_string(\"The quick brown fox\"))\nprint(text_match_string(\"Python Exercises\"))\n",
        "base_tests": [
            "assert text_match_string(\" python\")==('Not matched!')",
            "assert text_match_string(\"python\")==('Found a match!')",
            "assert text_match_string(\"  lang\")==('Not matched!')"
        ],
        "tests": [
            "try: text_match_string(123); assert False, 'TypeError not raised' except TypeError: pass",
            "try: text_match_string(None); assert False, 'TypeError not raised' except TypeError: pass"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'text_match_string' that matches a word at the beginning of a string.",
        "instruction": "The function should correctly handle edge cases such as an empty string or a string with only spaces.",
        "code_before": "import re\n\ndef text_match_string(text):\n    pattern = '^The'\n    if re.search(pattern,  text):\n        return 'Found a match!'\n    else:\n        return('Not matched')\n\nprint(text_match_string(\"The quick brown fox\"))\nprint(text_match_string(\"Python Exercises\"))\n",
        "base_tests": [
            "assert text_match_string(\" python\")==('Not matched!')",
            "assert text_match_string(\"python\")==('Found a match!')",
            "assert text_match_string(\"  lang\")==('Not matched!')"
        ],
        "tests": [
            "assert text_match_string('') == 'Not matched!'",
            "assert text_match_string('   ') == 'Not matched!'"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'text_match_string' that matches a word at the beginning of a string.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'text': str, and the return type should be annotated as str.",
        "code_before": "import re\n\ndef text_match_string(text):\n    pattern = '^The'\n    if re.search(pattern,  text):\n        return 'Found a match!'\n    else:\n        return('Not matched')\n\nprint(text_match_string(\"The quick brown fox\"))\nprint(text_match_string(\"Python Exercises\"))\n",
        "base_tests": [
            "assert text_match_string(\" python\")==('Not matched!')",
            "assert text_match_string(\"python\")==('Found a match!')",
            "assert text_match_string(\"  lang\")==('Not matched!')"
        ],
        "tests": [
            "assert text_match_string.__annotations__ == {'text': str, 'return': str}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'text_match_string' that matches a word at the beginning of a string.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "import re\n\ndef text_match_string(text):\n    pattern = '^The'\n    if re.search(pattern,  text):\n        return 'Found a match!'\n    else:\n        return('Not matched')\n\nprint(text_match_string(\"The quick brown fox\"))\nprint(text_match_string(\"Python Exercises\"))\n",
        "base_tests": [
            "assert text_match_string(\" python\")==('Not matched!')",
            "assert text_match_string(\"python\")==('Found a match!')",
            "assert text_match_string(\"  lang\")==('Not matched!')"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(text_match_string)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'get_gcd' to find the gcd of the given array elements.",
        "instruction": "The function should raise a ValueError with error message 'Input list cannot be empty.' if the input list is empty.",
        "code_before": "def get_gcd(arr):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    num1 = arr[0]\n    num2 = arr[1]\n    result = gcd(num1, num2)\n\n    for i in range(2, len(arr)):\n        result = gcd(result, arr[i])\n\n    return result\n",
        "base_tests": [
            "assert get_gcd([2, 4, 6, 8, 16]) == 2",
            "assert get_gcd([1, 2, 3]) == 1",
            "assert get_gcd([2, 4, 6, 8]) == 2 "
        ],
        "tests": [
            "try: get_gcd([])\nexcept ValueError as e: assert str(e) == 'Input list cannot be empty.'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'get_gcd' to find the gcd of the given array elements.",
        "instruction": "Extend the function to handle lists containing zero, returning the GCD of the non-zero elements.",
        "code_before": "def get_gcd(arr):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    num1 = arr[0]\n    num2 = arr[1]\n    result = gcd(num1, num2)\n\n    for i in range(2, len(arr)):\n        result = gcd(result, arr[i])\n\n    return result\n",
        "base_tests": [
            "assert get_gcd([2, 4, 6, 8, 16]) == 2",
            "assert get_gcd([1, 2, 3]) == 1",
            "assert get_gcd([2, 4, 6, 8]) == 2 "
        ],
        "tests": [
            "assert get_gcd([0, 0, 6, 9]) == 3"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'get_gcd' to find the gcd of the given array elements.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'numbers': list, and the return type should be annotated as int.",
        "code_before": "def get_gcd(arr):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    num1 = arr[0]\n    num2 = arr[1]\n    result = gcd(num1, num2)\n\n    for i in range(2, len(arr)):\n        result = gcd(result, arr[i])\n\n    return result\n",
        "base_tests": [
            "assert get_gcd([2, 4, 6, 8, 16]) == 2",
            "assert get_gcd([1, 2, 3]) == 1",
            "assert get_gcd([2, 4, 6, 8]) == 2 "
        ],
        "tests": [
            "assert get_gcd.__annotations__ == {'numbers': list, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'get_gcd' to find the gcd of the given array elements.",
        "instruction": "The function should have a cyclomatic complexity of no more than 5.",
        "code_before": "def get_gcd(arr):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    num1 = arr[0]\n    num2 = arr[1]\n    result = gcd(num1, num2)\n\n    for i in range(2, len(arr)):\n        result = gcd(result, arr[i])\n\n    return result\n",
        "base_tests": [
            "assert get_gcd([2, 4, 6, 8, 16]) == 2",
            "assert get_gcd([1, 2, 3]) == 1",
            "assert get_gcd([2, 4, 6, 8]) == 2 "
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(get_gcd))[0].complexity <=1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'get_gcd' to find the gcd of the given array elements.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def get_gcd(arr):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    num1 = arr[0]\n    num2 = arr[1]\n    result = gcd(num1, num2)\n\n    for i in range(2, len(arr)):\n        result = gcd(result, arr[i])\n\n    return result\n",
        "base_tests": [
            "assert get_gcd([2, 4, 6, 8, 16]) == 2",
            "assert get_gcd([1, 2, 3]) == 1",
            "assert get_gcd([2, 4, 6, 8]) == 2 "
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(get_gcd)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'test_distinct' to determine whether all the numbers are different from each other are not.",
        "instruction": "The function should accept a list of integers as input and return a boolean indicating whether all numbers are distinct.",
        "code_before": "def test_distinct(data):\n    if len(data) == len(set(data)):\n        return True\n    else:\n        return False\n",
        "base_tests": [
            "assert test_distinct([1,5,7,9]) == True",
            "assert test_distinct([2,4,5,5,7,9]) == False",
            "assert test_distinct([1,2,3]) == True"
        ],
        "tests": [
            "assert test_distinct([1, 2, 3, 4]) == True\nassert test_distinct([1, 1, 2, 3]) == False"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'test_distinct' to determine whether all the numbers are different from each other are not.",
        "instruction": "The function should raise a TypeError if the input is not a list or if the list contains non-integer elements.",
        "code_before": "def test_distinct(data):\n    if len(data) == len(set(data)):\n        return True\n    else:\n        return False\n",
        "base_tests": [
            "assert test_distinct([1,5,7,9]) == True",
            "assert test_distinct([2,4,5,5,7,9]) == False",
            "assert test_distinct([1,2,3]) == True"
        ],
        "tests": [
            "try:\n    test_distinct('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    test_distinct([1, 'a', 3])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'test_distinct' to determine whether all the numbers are different from each other are not.",
        "instruction": "The function should correctly handle edge cases such as an empty list or a list with a single element.",
        "code_before": "def test_distinct(data):\n    if len(data) == len(set(data)):\n        return True\n    else:\n        return False\n",
        "base_tests": [
            "assert test_distinct([1,5,7,9]) == True",
            "assert test_distinct([2,4,5,5,7,9]) == False",
            "assert test_distinct([1,2,3]) == True"
        ],
        "tests": [
            "assert test_distinct([]) == True\nassert test_distinct([42]) == True"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'test_distinct' to determine whether all the numbers are different from each other are not.",
        "instruction": "Extend the function to handle lists of floating-point numbers and return whether all numbers are distinct.",
        "code_before": "def test_distinct(data):\n    if len(data) == len(set(data)):\n        return True\n    else:\n        return False\n",
        "base_tests": [
            "assert test_distinct([1,5,7,9]) == True",
            "assert test_distinct([2,4,5,5,7,9]) == False",
            "assert test_distinct([1,2,3]) == True"
        ],
        "tests": [
            "assert test_distinct([1.1, 2.2, 3.3]) == True\nassert test_distinct([1.1, 2.2, 2.2]) == False"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'test_distinct' to determine whether all the numbers are different from each other are not.",
        "instruction": "The function should include type annotations for its parameters called 'numbers' and return type. The parameter should be annotated as 'numbers': list, and the return type should be annotated as bool.",
        "code_before": "def test_distinct(data):\n    if len(data) == len(set(data)):\n        return True\n    else:\n        return False\n",
        "base_tests": [
            "assert test_distinct([1,5,7,9]) == True",
            "assert test_distinct([2,4,5,5,7,9]) == False",
            "assert test_distinct([1,2,3]) == True"
        ],
        "tests": [
            "assert test_distinct.__annotations__ == {'numbers': list, 'return': bool}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'test_distinct' to determine whether all the numbers are different from each other are not.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def test_distinct(data):\n    if len(data) == len(set(data)):\n        return True\n    else:\n        return False\n",
        "base_tests": [
            "assert test_distinct([1,5,7,9]) == True",
            "assert test_distinct([2,4,5,5,7,9]) == False",
            "assert test_distinct([1,2,3]) == True"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(test_distinct)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'compute_last_digit' to find the last digit when factorial of a divides factorial of b.",
        "instruction": "The function should raise a ValueError with a descriptive message 'a should not be greater than b' if a is greater than b.",
        "code_before": "def compute_last_digit(a, b):\n    factorial = 1\n    for i in range(1, a+1):\n        factorial *= i\n    last_digit = factorial % 10\n\n    factorial = 1\n    for i in range(1, b+1):\n        factorial *= i\n    last_digit_b = factorial % 10\n\n    return last_digit, last_digit_b\n",
        "base_tests": [
            "assert compute_last_digit(2,4) == 2",
            "assert compute_last_digit(6,8) == 6",
            "assert compute_last_digit(1,2) == 2"
        ],
        "tests": [
            "try:\n    compute_last_digit(5, 3)\nexcept ValueError as e:\n    assert str(e) == 'a should not be greater than b'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'compute_last_digit' to find the last digit when factorial of a divides factorial of b.",
        "instruction": "The function should correctly handle the edge case where a equals b, returning 1 since factorial(a) divided by factorial(b) is 1.",
        "code_before": "def compute_last_digit(a, b):\n    factorial = 1\n    for i in range(1, a+1):\n        factorial *= i\n    last_digit = factorial % 10\n\n    factorial = 1\n    for i in range(1, b+1):\n        factorial *= i\n    last_digit_b = factorial % 10\n\n    return last_digit, last_digit_b\n",
        "base_tests": [
            "assert compute_last_digit(2,4) == 2",
            "assert compute_last_digit(6,8) == 6",
            "assert compute_last_digit(1,2) == 2"
        ],
        "tests": [
            "assert compute_last_digit(5, 5) == 1"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'compute_last_digit' to find the last digit when factorial of a divides factorial of b.",
        "instruction": "Extend the function to handle cases where a or b is zero, returning 1 since factorial(0) is 1.",
        "code_before": "def compute_last_digit(a, b):\n    factorial = 1\n    for i in range(1, a+1):\n        factorial *= i\n    last_digit = factorial % 10\n\n    factorial = 1\n    for i in range(1, b+1):\n        factorial *= i\n    last_digit_b = factorial % 10\n\n    return last_digit, last_digit_b\n",
        "base_tests": [
            "assert compute_last_digit(2,4) == 2",
            "assert compute_last_digit(6,8) == 6",
            "assert compute_last_digit(1,2) == 2"
        ],
        "tests": [
            "assert compute_last_digit(0, 5) == 1"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'compute_last_digit' to find the last digit when factorial of a divides factorial of b.",
        "instruction": "The function should include type annotations for its parameters 'a','b' and return type, indicating that both parameters are integers and the return type is an integer.",
        "code_before": "def compute_last_digit(a, b):\n    factorial = 1\n    for i in range(1, a+1):\n        factorial *= i\n    last_digit = factorial % 10\n\n    factorial = 1\n    for i in range(1, b+1):\n        factorial *= i\n    last_digit_b = factorial % 10\n\n    return last_digit, last_digit_b\n",
        "base_tests": [
            "assert compute_last_digit(2,4) == 2",
            "assert compute_last_digit(6,8) == 6",
            "assert compute_last_digit(1,2) == 2"
        ],
        "tests": [
            "assert compute_last_digit.__annotations__ == {'a': int, 'b': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'compute_last_digit' to find the last digit when factorial of a divides factorial of b.",
        "instruction": "The function should have a cyclomatic complexity of 3 or less, ensuring that the logic is straightforward and easy to follow.",
        "code_before": "def compute_last_digit(a, b):\n    factorial = 1\n    for i in range(1, a+1):\n        factorial *= i\n    last_digit = factorial % 10\n\n    factorial = 1\n    for i in range(1, b+1):\n        factorial *= i\n    last_digit_b = factorial % 10\n\n    return last_digit, last_digit_b\n",
        "base_tests": [
            "assert compute_last_digit(2,4) == 2",
            "assert compute_last_digit(6,8) == 6",
            "assert compute_last_digit(1,2) == 2"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(compute_last_digit))[0].complexity <=3"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'odd_bit_set_number' to set all odd bits of a given number.",
        "instruction": "The function should accept an integer as input and return an integer with all odd bits set.",
        "code_before": "def odd_bit_set_number(n):\n    binary = bin(n)[2:]\n    binary = binary.zfill(32)\n    binary_list = list(binary)\n    for i in range(len(binary_list)):\n        if i % 2 != 0:\n            binary_list[i] = '1'\n    return int(''.join(binary_list), 2)\n",
        "base_tests": [
            "assert odd_bit_set_number(10) == 15",
            "assert odd_bit_set_number(20) == 21",
            "assert odd_bit_set_number(30) == 31"
        ],
        "tests": [
            "assert isinstance(odd_bit_set_number(10), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'odd_bit_set_number' to set all odd bits of a given number.",
        "instruction": "The function should raise a TypeError if the input is not an integer.",
        "code_before": "def odd_bit_set_number(n):\n    binary = bin(n)[2:]\n    binary = binary.zfill(32)\n    binary_list = list(binary)\n    for i in range(len(binary_list)):\n        if i % 2 != 0:\n            binary_list[i] = '1'\n    return int(''.join(binary_list), 2)\n",
        "base_tests": [
            "assert odd_bit_set_number(10) == 15",
            "assert odd_bit_set_number(20) == 21",
            "assert odd_bit_set_number(30) == 31"
        ],
        "tests": [
            "try: odd_bit_set_number('10')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'odd_bit_set_number' to set all odd bits of a given number.",
        "instruction": "The function should correctly handle the edge case where the input is 0, returning 1.",
        "code_before": "def odd_bit_set_number(n):\n    binary = bin(n)[2:]\n    binary = binary.zfill(32)\n    binary_list = list(binary)\n    for i in range(len(binary_list)):\n        if i % 2 != 0:\n            binary_list[i] = '1'\n    return int(''.join(binary_list), 2)\n",
        "base_tests": [
            "assert odd_bit_set_number(10) == 15",
            "assert odd_bit_set_number(20) == 21",
            "assert odd_bit_set_number(30) == 31"
        ],
        "tests": [
            "assert odd_bit_set_number(0) == 1"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'odd_bit_set_number' to set all odd bits of a given number.",
        "instruction": "Extend the function to handle negative integers by setting all odd bits in their absolute value.",
        "code_before": "def odd_bit_set_number(n):\n    binary = bin(n)[2:]\n    binary = binary.zfill(32)\n    binary_list = list(binary)\n    for i in range(len(binary_list)):\n        if i % 2 != 0:\n            binary_list[i] = '1'\n    return int(''.join(binary_list), 2)\n",
        "base_tests": [
            "assert odd_bit_set_number(10) == 15",
            "assert odd_bit_set_number(20) == 21",
            "assert odd_bit_set_number(30) == 31"
        ],
        "tests": [
            "assert odd_bit_set_number(-10) == 15"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'odd_bit_set_number' to set all odd bits of a given number.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as int.",
        "code_before": "def odd_bit_set_number(n):\n    binary = bin(n)[2:]\n    binary = binary.zfill(32)\n    binary_list = list(binary)\n    for i in range(len(binary_list)):\n        if i % 2 != 0:\n            binary_list[i] = '1'\n    return int(''.join(binary_list), 2)\n",
        "base_tests": [
            "assert odd_bit_set_number(10) == 15",
            "assert odd_bit_set_number(20) == 21",
            "assert odd_bit_set_number(30) == 31"
        ],
        "tests": [
            "assert odd_bit_set_number.__annotations__ == {'n': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'odd_bit_set_number' to set all odd bits of a given number.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def odd_bit_set_number(n):\n    binary = bin(n)[2:]\n    binary = binary.zfill(32)\n    binary_list = list(binary)\n    for i in range(len(binary_list)):\n        if i % 2 != 0:\n            binary_list[i] = '1'\n    return int(''.join(binary_list), 2)\n",
        "base_tests": [
            "assert odd_bit_set_number(10) == 15",
            "assert odd_bit_set_number(20) == 21",
            "assert odd_bit_set_number(30) == 31"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(odd_bit_set_number)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'specified_element' to extract every first or specified element from a given two-dimensional list.",
        "instruction": "The function should accept a two-dimensional list and an integer index, returning a list of elements from each sublist at the specified index. The function should return an empty list if the input list is empty.",
        "code_before": "def specified_element(two_d_list, index=0):\n    return [sublist[index] for sublist in two_d_list]\n",
        "base_tests": [
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]"
        ],
        "tests": [
            "assert specified_element([], 0) == []"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'specified_element' to extract every first or specified element from a given two-dimensional list.",
        "instruction": "The function should raise an IndexError with a descriptive message 'Index out of range for sublist' if the specified index is out of range for any sublist.",
        "code_before": "def specified_element(two_d_list, index=0):\n    return [sublist[index] for sublist in two_d_list]\n",
        "base_tests": [
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]"
        ],
        "tests": [
            "try: specified_element([[1, 2], [3, 4]], 3)\nexcept IndexError as e: assert str(e) == 'Index out of range for sublist'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'specified_element' to extract every first or specified element from a given two-dimensional list.",
        "instruction": "The function should handle cases where sublists are of varying lengths, extracting elements only from sublists where the index is valid.",
        "code_before": "def specified_element(two_d_list, index=0):\n    return [sublist[index] for sublist in two_d_list]\n",
        "base_tests": [
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]"
        ],
        "tests": [
            "assert specified_element([[1, 2], [3], [4, 5, 6]], 1) == [2, 5]"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'specified_element' to extract every first or specified element from a given two-dimensional list.",
        "instruction": "Extend the function to allow negative indices, which should extract elements from the end of each sublist.",
        "code_before": "def specified_element(two_d_list, index=0):\n    return [sublist[index] for sublist in two_d_list]\n",
        "base_tests": [
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]"
        ],
        "tests": [
            "assert specified_element([[1, 2, 3], [4, 5, 6], [7, 8, 9]], -1) == [3, 6, 9]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'specified_element' to extract every first or specified element from a given two-dimensional list.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation, spacing, and naming conventions.",
        "code_before": "def specified_element(two_d_list, index=0):\n    return [sublist[index] for sublist in two_d_list]\n",
        "base_tests": [
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(specified_element)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'min_length_list' to find the list with minimum length using lambda function.",
        "instruction": "The function should accept a list of lists and return a tuple containing the length of the shortest list and the list itself.",
        "code_before": "def min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n",
        "base_tests": [
            "assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])",
            "assert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1,[1])",
            "assert min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])==(2,[1,2])"
        ],
        "tests": [
            "assert min_length_list([[1, 2], [3, 4, 5], [6]]) == (1, [6])"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'min_length_list' to find the list with minimum length using lambda function.",
        "instruction": "The function should raise a ValueError with a descriptive message 'Input must be a list of lists.' if the input is not a list of lists.",
        "code_before": "def min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n",
        "base_tests": [
            "assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])",
            "assert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1,[1])",
            "assert min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])==(2,[1,2])"
        ],
        "tests": [
            "try: min_length_list('not a list of lists')\nexcept ValueError as e: assert str(e) == 'Input must be a list of lists.'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'min_length_list' to find the list with minimum length using lambda function.",
        "instruction": "The function should correctly handle an edge case where all lists are of the same length, returning the first such list.",
        "code_before": "def min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n",
        "base_tests": [
            "assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])",
            "assert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1,[1])",
            "assert min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])==(2,[1,2])"
        ],
        "tests": [
            "assert min_length_list([[1, 2], [3, 4], [5, 6]]) == (2, [1, 2])"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'min_length_list' to find the list with minimum length using lambda function.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'lists': list[list], and the return type should be annotated as tuple[int, list].",
        "code_before": "def min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n",
        "base_tests": [
            "assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])",
            "assert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1,[1])",
            "assert min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])==(2,[1,2])"
        ],
        "tests": [
            "assert min_length_list.__annotations__ == {'lists': 'list[list]', 'return': 'tuple[int, list]'}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'check_equilateral' to print check if the triangle is equilateral or not.",
        "instruction": "The function should raise a ValueError if any of the inputs are non-positive integers.",
        "code_before": "def check_equilateral(a, b, c):\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n",
        "base_tests": [
            "assert check_equilateral(6,8,12)==False ",
            "assert check_equilateral(6,6,12)==False",
            "assert check_equilateral(6,6,6)==True"
        ],
        "tests": [
            "try:\n    check_equilateral(-1, 3, 3)\nexcept ValueError:\n    pass\nelse:\n    assert False, 'Expected ValueError'\n\ntry:\n    check_equilateral(0, 3, 3)\nexcept ValueError:\n    pass\nelse:\n    assert False, 'Expected ValueError'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'check_equilateral' to print check if the triangle is equilateral or not.",
        "instruction": "The function should correctly handle the case where all sides are zero, returning False.",
        "code_before": "def check_equilateral(a, b, c):\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n",
        "base_tests": [
            "assert check_equilateral(6,8,12)==False ",
            "assert check_equilateral(6,6,12)==False",
            "assert check_equilateral(6,6,6)==True"
        ],
        "tests": [
            "assert check_equilateral(0, 0, 0) == False"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'check_equilateral' to print check if the triangle is equilateral or not.",
        "instruction": "Extend the function to also check if the triangle is isosceles, returning 'isosceles' if true.",
        "code_before": "def check_equilateral(a, b, c):\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n",
        "base_tests": [
            "assert check_equilateral(6,8,12)==False ",
            "assert check_equilateral(6,6,12)==False",
            "assert check_equilateral(6,6,6)==True"
        ],
        "tests": [
            "assert check_equilateral(5, 5, 3) == 'isosceles'"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'check_equilateral' to print check if the triangle is equilateral or not.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'a': int, 'b': int, 'c': int, and the return type should be annotated as bool.",
        "code_before": "def check_equilateral(a, b, c):\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n",
        "base_tests": [
            "assert check_equilateral(6,8,12)==False ",
            "assert check_equilateral(6,6,12)==False",
            "assert check_equilateral(6,6,6)==True"
        ],
        "tests": [
            "assert check_equilateral.__annotations__ == {'a': int, 'b': int, 'c': int, 'return': bool}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'check_equilateral' to print check if the triangle is equilateral or not.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple conditional check.",
        "code_before": "def check_equilateral(a, b, c):\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n",
        "base_tests": [
            "assert check_equilateral(6,8,12)==False ",
            "assert check_equilateral(6,6,12)==False",
            "assert check_equilateral(6,6,6)==True"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(check_equilateral))[0].complexity ==1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'check_equilateral' to print check if the triangle is equilateral or not.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation and spacing.",
        "code_before": "def check_equilateral(a, b, c):\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n",
        "base_tests": [
            "assert check_equilateral(6,8,12)==False ",
            "assert check_equilateral(6,6,12)==False",
            "assert check_equilateral(6,6,6)==True"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(check_equilateral)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.",
        "instruction": "The function should accept two positive numerical inputs representing the base and height of the parallelogram and return a positive numerical output representing the area.",
        "code_before": "def parallelogram_area(base, height):\n    return base * height\n",
        "base_tests": [
            "assert parallelogram_area(10,20)==200",
            "assert parallelogram_area(15,20)==300",
            "assert parallelogram_area(8,9)==72"
        ],
        "tests": [
            "assert parallelogram_area(5, 10) == 50",
            "assert parallelogram_area(0, 10) == 0",
            "assert parallelogram_area(10, 0) == 0",
            "assert parallelogram_area(0, 0) == 0"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.",
        "instruction": "The function should raise a TypeError if the inputs are not numerical.",
        "code_before": "def parallelogram_area(base, height):\n    return base * height\n",
        "base_tests": [
            "assert parallelogram_area(10,20)==200",
            "assert parallelogram_area(15,20)==300",
            "assert parallelogram_area(8,9)==72"
        ],
        "tests": [
            "try:\n    parallelogram_area('10', 20)\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass",
            "try:\n    parallelogram_area(10, '20')\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass",
            "try:\n    parallelogram_area('10', '20')\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.",
        "instruction": "The function should correctly handle edge cases where the base or height is zero, returning an area of zero.",
        "code_before": "def parallelogram_area(base, height):\n    return base * height\n",
        "base_tests": [
            "assert parallelogram_area(10,20)==200",
            "assert parallelogram_area(15,20)==300",
            "assert parallelogram_area(8,9)==72"
        ],
        "tests": [
            "assert parallelogram_area(0, 10) == 0",
            "assert parallelogram_area(10, 0) == 0",
            "assert parallelogram_area(0, 0) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.",
        "instruction": "Extend the function to accept a list of tuples where each tuple contains the base and height of a parallelogram, and return a list of areas.",
        "code_before": "def parallelogram_area(base, height):\n    return base * height\n",
        "base_tests": [
            "assert parallelogram_area(10,20)==200",
            "assert parallelogram_area(15,20)==300",
            "assert parallelogram_area(8,9)==72"
        ],
        "tests": [
            "assert parallelogram_area_list([(10, 20), (15, 20), (8, 9)]) == [200, 300, 72]",
            "assert parallelogram_area_list([(0, 10), (10, 0), (0, 0)]) == [0, 0, 0]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'base': float, 'height': float, and the return type should be annotated as float.",
        "code_before": "def parallelogram_area(base, height):\n    return base * height\n",
        "base_tests": [
            "assert parallelogram_area(10,20)==200",
            "assert parallelogram_area(15,20)==300",
            "assert parallelogram_area(8,9)==72"
        ],
        "tests": [
            "assert parallelogram_area.__annotations__ == {'base': float, 'height': float, 'return': float}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple, linear function.",
        "code_before": "def parallelogram_area(base, height):\n    return base * height\n",
        "base_tests": [
            "assert parallelogram_area(10,20)==200",
            "assert parallelogram_area(15,20)==300",
            "assert parallelogram_area(8,9)==72"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(parallelogram_area))[0].complexity ==1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def parallelogram_area(base, height):\n    return base * height\n",
        "base_tests": [
            "assert parallelogram_area(10,20)==200",
            "assert parallelogram_area(15,20)==300",
            "assert parallelogram_area(8,9)==72"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(parallelogram_area)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.",
        "instruction": "The function should accept only strings as input and return 'Equal' if the first and last characters are the same, otherwise 'Not Equal'.",
        "code_before": "def check_equality(s):\n    return s[0] == s[-1]\n",
        "base_tests": [
            "assert check_equality(\"abcda\") == \"Equal\"",
            "assert check_equality(\"ab\") == \"Not Equal\"",
            "assert check_equality(\"mad\") == \"Not Equal\""
        ],
        "tests": [
            "assert check_equality('racecar') == 'Equal'\nassert check_equality('hello') == 'Not Equal'\nassert check_equality('a') == 'Equal'"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.",
        "instruction": "The function should raise a TypeError with a descriptive message as 'Input must be a string' if the input is not a string.",
        "code_before": "def check_equality(s):\n    return s[0] == s[-1]\n",
        "base_tests": [
            "assert check_equality(\"abcda\") == \"Equal\"",
            "assert check_equality(\"ab\") == \"Not Equal\"",
            "assert check_equality(\"mad\") == \"Not Equal\""
        ],
        "tests": [
            "try:\n    check_equality(123)\nexcept TypeError as e:\n    assert str(e) == 'Input must be a string'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.",
        "instruction": "The function should correctly handle empty strings by returning 'Equal'.",
        "code_before": "def check_equality(s):\n    return s[0] == s[-1]\n",
        "base_tests": [
            "assert check_equality(\"abcda\") == \"Equal\"",
            "assert check_equality(\"ab\") == \"Not Equal\"",
            "assert check_equality(\"mad\") == \"Not Equal\""
        ],
        "tests": [
            "assert check_equality('') == 'Equal'"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.",
        "instruction": "Extend the function to ignore case sensitivity when comparing the first and last characters.",
        "code_before": "def check_equality(s):\n    return s[0] == s[-1]\n",
        "base_tests": [
            "assert check_equality(\"abcda\") == \"Equal\"",
            "assert check_equality(\"ab\") == \"Not Equal\"",
            "assert check_equality(\"mad\") == \"Not Equal\""
        ],
        "tests": [
            "assert check_equality('Abca') == 'Equal'\nassert check_equality('AbC') == 'Not Equal'"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 's': str, and the return type should be annotated as str.",
        "code_before": "def check_equality(s):\n    return s[0] == s[-1]\n",
        "base_tests": [
            "assert check_equality(\"abcda\") == \"Equal\"",
            "assert check_equality(\"ab\") == \"Not Equal\"",
            "assert check_equality(\"mad\") == \"Not Equal\""
        ],
        "tests": [
            "assert check_equality.__annotations__ == {'s': str, 'return': str}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple linear control flow.",
        "code_before": "def check_equality(s):\n    return s[0] == s[-1]\n",
        "base_tests": [
            "assert check_equality(\"abcda\") == \"Equal\"",
            "assert check_equality(\"ab\") == \"Not Equal\"",
            "assert check_equality(\"mad\") == \"Not Equal\""
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(check_equality))[0].complexity <=3"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation and spacing.",
        "code_before": "def check_equality(s):\n    return s[0] == s[-1]\n",
        "base_tests": [
            "assert check_equality(\"abcda\") == \"Equal\"",
            "assert check_equality(\"ab\") == \"Not Equal\"",
            "assert check_equality(\"mad\") == \"Not Equal\""
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(check_equality)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'counting_sort' to sort the given array by using counting sort.",
        "instruction": "The function should accept only a list of non-negative integers as input and return a sorted list of integers.",
        "code_before": "def counting_sort(array):\n    # Find the maximum element in the array\n    max_val = max(array)\n\n    # Initialize a count array with zeros\n    count = [0] * (max_val + 1)\n\n    # Count the occurrence of each element in the array\n    for num in array:\n        count[num] += 1\n\n    # Modify the count array to reflect the actual position of each element in the output\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n\n    # Create the output array\n    output = [0] * len(array)\n\n    # Build the output array\n    for num in array:\n        output[count[num] - 1] = num\n        count[num] -= 1\n\n    return output\n",
        "base_tests": [
            "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
            "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
            "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"
        ],
        "tests": [
            "assert counting_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]\nassert counting_sort([10, 0, 5, 5]) == [0, 5, 5, 10]"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'counting_sort' to sort the given array by using counting sort.",
        "instruction": "The function should raise a TypeError if the input is not a list or contains non-integer elements.",
        "code_before": "def counting_sort(array):\n    # Find the maximum element in the array\n    max_val = max(array)\n\n    # Initialize a count array with zeros\n    count = [0] * (max_val + 1)\n\n    # Count the occurrence of each element in the array\n    for num in array:\n        count[num] += 1\n\n    # Modify the count array to reflect the actual position of each element in the output\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n\n    # Create the output array\n    output = [0] * len(array)\n\n    # Build the output array\n    for num in array:\n        output[count[num] - 1] = num\n        count[num] -= 1\n\n    return output\n",
        "base_tests": [
            "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
            "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
            "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"
        ],
        "tests": [
            "try:\n    counting_sort('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    counting_sort([1, 'a', 3])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'counting_sort' to sort the given array by using counting sort.",
        "instruction": "The function should correctly handle edge cases such as an empty list or a list with a single element.",
        "code_before": "def counting_sort(array):\n    # Find the maximum element in the array\n    max_val = max(array)\n\n    # Initialize a count array with zeros\n    count = [0] * (max_val + 1)\n\n    # Count the occurrence of each element in the array\n    for num in array:\n        count[num] += 1\n\n    # Modify the count array to reflect the actual position of each element in the output\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n\n    # Create the output array\n    output = [0] * len(array)\n\n    # Build the output array\n    for num in array:\n        output[count[num] - 1] = num\n        count[num] -= 1\n\n    return output\n",
        "base_tests": [
            "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
            "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
            "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"
        ],
        "tests": [
            "assert counting_sort([]) == []\nassert counting_sort([42]) == [42]"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'counting_sort' to sort the given array by using counting sort.",
        "instruction": "Extend the function to handle lists containing negative integers by sorting them correctly.",
        "code_before": "def counting_sort(array):\n    # Find the maximum element in the array\n    max_val = max(array)\n\n    # Initialize a count array with zeros\n    count = [0] * (max_val + 1)\n\n    # Count the occurrence of each element in the array\n    for num in array:\n        count[num] += 1\n\n    # Modify the count array to reflect the actual position of each element in the output\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n\n    # Create the output array\n    output = [0] * len(array)\n\n    # Build the output array\n    for num in array:\n        output[count[num] - 1] = num\n        count[num] -= 1\n\n    return output\n",
        "base_tests": [
            "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
            "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
            "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"
        ],
        "tests": [
            "assert counting_sort([-5, -1, -3, 0, 2, 1]) == [-5, -3, -1, 0, 1, 2]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'counting_sort' to sort the given array by using counting sort.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'arr': list, and the return type should be annotated as list.",
        "code_before": "def counting_sort(array):\n    # Find the maximum element in the array\n    max_val = max(array)\n\n    # Initialize a count array with zeros\n    count = [0] * (max_val + 1)\n\n    # Count the occurrence of each element in the array\n    for num in array:\n        count[num] += 1\n\n    # Modify the count array to reflect the actual position of each element in the output\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n\n    # Create the output array\n    output = [0] * len(array)\n\n    # Build the output array\n    for num in array:\n        output[count[num] - 1] = num\n        count[num] -= 1\n\n    return output\n",
        "base_tests": [
            "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
            "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
            "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"
        ],
        "tests": [
            "def test_annotations():\n    from typing import get_type_hints\n    hints = get_type_hints(counting_sort)\n    assert hints == {'arr': list, 'return': list}\ntest_annotations()"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'counting_sort' to sort the given array by using counting sort.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def counting_sort(array):\n    # Find the maximum element in the array\n    max_val = max(array)\n\n    # Initialize a count array with zeros\n    count = [0] * (max_val + 1)\n\n    # Count the occurrence of each element in the array\n    for num in array:\n        count[num] += 1\n\n    # Modify the count array to reflect the actual position of each element in the output\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n\n    # Create the output array\n    output = [0] * len(array)\n\n    # Build the output array\n    for num in array:\n        output[count[num] - 1] = num\n        count[num] -= 1\n\n    return output\n",
        "base_tests": [
            "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
            "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
            "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(counting_sort)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'tn_gp' to find t-nth term of geometric series.",
        "instruction": "The function should raise a ValueError with the message 'Term number must be greater than 0' if the term number (n) is less than 1, as it is not possible to have a non-positive term number in a geometric series.",
        "code_before": "def tn_gp(a, r, n):\n    \"\"\"\n    This function calculates the nth term of a geometric progression.\n\n    Parameters:\n    a (int or float): The first term of the geometric progression.\n    r (int or float): The common ratio of the geometric progression.\n    n (int): The term to be calculated.\n\n    Returns:\n    int or float: The nth term of the geometric progression.\n    \"\"\"\n    return a * r ** (n - 1)\n",
        "base_tests": [
            "assert tn_gp(1,5,2)==16",
            "assert tn_gp(1,5,4)==256",
            "assert tn_gp(2,6,3)==486"
        ],
        "tests": [
            "try:\n    tn_gp(1, 5, 0)\nexcept ValueError as e:\n    assert str(e) == 'Term number must be greater than 0'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'tn_gp' to find t-nth term of geometric series.",
        "instruction": "The function should correctly handle the edge case where the common ratio (r) is zero, returning zero for all terms beyond the first.",
        "code_before": "def tn_gp(a, r, n):\n    \"\"\"\n    This function calculates the nth term of a geometric progression.\n\n    Parameters:\n    a (int or float): The first term of the geometric progression.\n    r (int or float): The common ratio of the geometric progression.\n    n (int): The term to be calculated.\n\n    Returns:\n    int or float: The nth term of the geometric progression.\n    \"\"\"\n    return a * r ** (n - 1)\n",
        "base_tests": [
            "assert tn_gp(1,5,2)==16",
            "assert tn_gp(1,5,4)==256",
            "assert tn_gp(2,6,3)==486"
        ],
        "tests": [
            "assert tn_gp(3, 0, 5) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'tn_gp' to find t-nth term of geometric series.",
        "instruction": "Extend the function to handle floating-point numbers for the first term and common ratio, returning a floating-point number for the n-th term.",
        "code_before": "def tn_gp(a, r, n):\n    \"\"\"\n    This function calculates the nth term of a geometric progression.\n\n    Parameters:\n    a (int or float): The first term of the geometric progression.\n    r (int or float): The common ratio of the geometric progression.\n    n (int): The term to be calculated.\n\n    Returns:\n    int or float: The nth term of the geometric progression.\n    \"\"\"\n    return a * r ** (n - 1)\n",
        "base_tests": [
            "assert tn_gp(1,5,2)==16",
            "assert tn_gp(1,5,4)==256",
            "assert tn_gp(2,6,3)==486"
        ],
        "tests": [
            "assert tn_gp(1.5, 2.5, 3) == 9.375"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'tn_gp' to find t-nth term of geometric series.",
        "instruction": "The function should include type annotations for all parameters and the return type to improve code readability and maintainability. The parameter should be annotated as 'a': int, 'r': int, 'n': int, and the return type should be annotated as int.",
        "code_before": "def tn_gp(a, r, n):\n    \"\"\"\n    This function calculates the nth term of a geometric progression.\n\n    Parameters:\n    a (int or float): The first term of the geometric progression.\n    r (int or float): The common ratio of the geometric progression.\n    n (int): The term to be calculated.\n\n    Returns:\n    int or float: The nth term of the geometric progression.\n    \"\"\"\n    return a * r ** (n - 1)\n",
        "base_tests": [
            "assert tn_gp(1,5,2)==16",
            "assert tn_gp(1,5,4)==256",
            "assert tn_gp(2,6,3)==486"
        ],
        "tests": [
            "assert tn_gp.__annotations__ == {'a': int, 'r': int, 'n': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'tn_gp' to find t-nth term of geometric series.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation, spacing, and naming conventions.",
        "code_before": "def tn_gp(a, r, n):\n    \"\"\"\n    This function calculates the nth term of a geometric progression.\n\n    Parameters:\n    a (int or float): The first term of the geometric progression.\n    r (int or float): The common ratio of the geometric progression.\n    n (int): The term to be calculated.\n\n    Returns:\n    int or float: The nth term of the geometric progression.\n    \"\"\"\n    return a * r ** (n - 1)\n",
        "base_tests": [
            "assert tn_gp(1,5,2)==16",
            "assert tn_gp(1,5,4)==256",
            "assert tn_gp(2,6,3)==486"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(tn_gp)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'check' to check if a given number is one less than twice its reverse.",
        "instruction": "The function should raise a TypeError if the input is not an integer.",
        "code_before": "def check(n):\n    # Convert the number to a string\n    str_n = str(n)\n    # Reverse the string\n    rev_str_n = str_n[::-1]\n    # Convert the reversed string back to a number\n    rev_n = int(rev_str_n)\n    # Check if the number is one less than twice its reverse\n    return n == 2 * rev_n - 1\n",
        "base_tests": [
            "assert check(70) == False",
            "assert check(23) == False",
            "assert check(73) == True"
        ],
        "tests": [
            "try:\n    check('73')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for non-integer input'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'check' to check if a given number is one less than twice its reverse.",
        "instruction": "The function should correctly handle edge cases such as single-digit numbers and zero.",
        "code_before": "def check(n):\n    # Convert the number to a string\n    str_n = str(n)\n    # Reverse the string\n    rev_str_n = str_n[::-1]\n    # Convert the reversed string back to a number\n    rev_n = int(rev_str_n)\n    # Check if the number is one less than twice its reverse\n    return n == 2 * rev_n - 1\n",
        "base_tests": [
            "assert check(70) == False",
            "assert check(23) == False",
            "assert check(73) == True"
        ],
        "tests": [
            "assert check(0) == False\nassert check(1) == False\nassert check(9) == False"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'check' to check if a given number is one less than twice its reverse.",
        "instruction": "Extend the function to handle negative numbers correctly, considering the reverse of a negative number as negative.",
        "code_before": "def check(n):\n    # Convert the number to a string\n    str_n = str(n)\n    # Reverse the string\n    rev_str_n = str_n[::-1]\n    # Convert the reversed string back to a number\n    rev_n = int(rev_str_n)\n    # Check if the number is one less than twice its reverse\n    return n == 2 * rev_n - 1\n",
        "base_tests": [
            "assert check(70) == False",
            "assert check(23) == False",
            "assert check(73) == True"
        ],
        "tests": [
            "assert check(-73) == False\nassert check(-37) == True"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'check' to check if a given number is one less than twice its reverse.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as bool.",
        "code_before": "def check(n):\n    # Convert the number to a string\n    str_n = str(n)\n    # Reverse the string\n    rev_str_n = str_n[::-1]\n    # Convert the reversed string back to a number\n    rev_n = int(rev_str_n)\n    # Check if the number is one less than twice its reverse\n    return n == 2 * rev_n - 1\n",
        "base_tests": [
            "assert check(70) == False",
            "assert check(23) == False",
            "assert check(73) == True"
        ],
        "tests": [
            "assert check.__annotations__ == {'n': int, 'return': bool}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'check' to check if a given number is one less than twice its reverse.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple, linear control flow.",
        "code_before": "def check(n):\n    # Convert the number to a string\n    str_n = str(n)\n    # Reverse the string\n    rev_str_n = str_n[::-1]\n    # Convert the reversed string back to a number\n    rev_n = int(rev_str_n)\n    # Check if the number is one less than twice its reverse\n    return n == 2 * rev_n - 1\n",
        "base_tests": [
            "assert check(70) == False",
            "assert check(23) == False",
            "assert check(73) == True"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(check))[0].complexity <=3"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'check' to check if a given number is one less than twice its reverse.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def check(n):\n    # Convert the number to a string\n    str_n = str(n)\n    # Reverse the string\n    rev_str_n = str_n[::-1]\n    # Convert the reversed string back to a number\n    rev_n = int(rev_str_n)\n    # Check if the number is one less than twice its reverse\n    return n == 2 * rev_n - 1\n",
        "base_tests": [
            "assert check(70) == False",
            "assert check(23) == False",
            "assert check(73) == True"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(check)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'find_max_num' to find the largest number that can be formed with the given digits.",
        "instruction": "The function should accept a list of integers and an integer representing the number of digits, and return an integer representing the largest number that can be formed.",
        "code_before": "def find_max_num(digits):\n    digits.sort(reverse=True)\n    return int(''.join(map(str, digits)))\n",
        "base_tests": [
            "assert find_max_num([1,2,3],3) == 321",
            "assert find_max_num([4,5,6,1],4) == 6541",
            "assert find_max_num([1,2,3,9],4) == 9321"
        ],
        "tests": [
            "assert find_max_num([7, 8, 9], 3) == 987"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'find_max_num' to find the largest number that can be formed with the given digits.",
        "instruction": "The function should raise a ValueError with the message 'Number of digits exceeds the length of the list.' if the number of digits specified is greater than the length of the list of digits.",
        "code_before": "def find_max_num(digits):\n    digits.sort(reverse=True)\n    return int(''.join(map(str, digits)))\n",
        "base_tests": [
            "assert find_max_num([1,2,3],3) == 321",
            "assert find_max_num([4,5,6,1],4) == 6541",
            "assert find_max_num([1,2,3,9],4) == 9321"
        ],
        "tests": [
            "try:\n    find_max_num([1, 2], 3)\nexcept ValueError as e:\n    assert str(e) == 'Number of digits exceeds the length of the list.'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'find_max_num' to find the largest number that can be formed with the given digits.",
        "instruction": "The function should correctly handle the edge case where the list of digits is empty, returning 0.",
        "code_before": "def find_max_num(digits):\n    digits.sort(reverse=True)\n    return int(''.join(map(str, digits)))\n",
        "base_tests": [
            "assert find_max_num([1,2,3],3) == 321",
            "assert find_max_num([4,5,6,1],4) == 6541",
            "assert find_max_num([1,2,3,9],4) == 9321"
        ],
        "tests": [
            "assert find_max_num([], 0) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'find_max_num' to find the largest number that can be formed with the given digits.",
        "instruction": "Extend the function to handle a list of digits containing duplicate numbers, ensuring the largest number is still formed.",
        "code_before": "def find_max_num(digits):\n    digits.sort(reverse=True)\n    return int(''.join(map(str, digits)))\n",
        "base_tests": [
            "assert find_max_num([1,2,3],3) == 321",
            "assert find_max_num([4,5,6,1],4) == 6541",
            "assert find_max_num([1,2,3,9],4) == 9321"
        ],
        "tests": [
            "assert find_max_num([1, 1, 2, 2], 4) == 2211"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'find_max_num' to find the largest number that can be formed with the given digits.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'digits': list, 'n': int, and the return type should be annotated as int.",
        "code_before": "def find_max_num(digits):\n    digits.sort(reverse=True)\n    return int(''.join(map(str, digits)))\n",
        "base_tests": [
            "assert find_max_num([1,2,3],3) == 321",
            "assert find_max_num([4,5,6,1],4) == 6541",
            "assert find_max_num([1,2,3,9],4) == 9321"
        ],
        "tests": [
            "assert find_max_num.__annotations__ == {'digits': list, 'n': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'find_max_num' to find the largest number that can be formed with the given digits.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def find_max_num(digits):\n    digits.sort(reverse=True)\n    return int(''.join(map(str, digits)))\n",
        "base_tests": [
            "assert find_max_num([1,2,3],3) == 321",
            "assert find_max_num([4,5,6,1],4) == 6541",
            "assert find_max_num([1,2,3,9],4) == 9321"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_max_num)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.",
        "instruction": "The function should accept only integer inputs and return a boolean value indicating whether the integers have opposite signs.",
        "code_before": "def opposite_signs(x, y):\n    return (x >= 0 and y < 0) or (x < 0 and y >= 0)\n",
        "base_tests": [
            "assert opposite_signs(1,-2) == True",
            "assert opposite_signs(3,2) == False",
            "assert opposite_signs(-10,-10) == False"
        ],
        "tests": [
            "assert opposite_signs(5, -5) == True",
            "assert opposite_signs(0, 0) == False",
            "assert opposite_signs(-7, 7) == True"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.",
        "instruction": "The function should raise a TypeError if the inputs are not integers.",
        "code_before": "def opposite_signs(x, y):\n    return (x >= 0 and y < 0) or (x < 0 and y >= 0)\n",
        "base_tests": [
            "assert opposite_signs(1,-2) == True",
            "assert opposite_signs(3,2) == False",
            "assert opposite_signs(-10,-10) == False"
        ],
        "tests": [
            "try:\n    opposite_signs(1.5, -2)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for float input'",
            "try:\n    opposite_signs('a', 2)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for string input'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.",
        "instruction": "The function should correctly handle edge cases such as zero and large integers.",
        "code_before": "def opposite_signs(x, y):\n    return (x >= 0 and y < 0) or (x < 0 and y >= 0)\n",
        "base_tests": [
            "assert opposite_signs(1,-2) == True",
            "assert opposite_signs(3,2) == False",
            "assert opposite_signs(-10,-10) == False"
        ],
        "tests": [
            "assert opposite_signs(0, -1) == True",
            "assert opposite_signs(0, 1) == True",
            "assert opposite_signs(0, 0) == False",
            "assert opposite_signs(2147483647, -2147483648) == True"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.",
        "instruction": "Extend the function to handle a list of integer pairs and return a list of boolean values indicating opposite signs for each pair.",
        "code_before": "def opposite_signs(x, y):\n    return (x >= 0 and y < 0) or (x < 0 and y >= 0)\n",
        "base_tests": [
            "assert opposite_signs(1,-2) == True",
            "assert opposite_signs(3,2) == False",
            "assert opposite_signs(-10,-10) == False"
        ],
        "tests": [
            "assert opposite_signs_list([(1, -2), (3, 2), (-10, -10)]) == [True, False, False]",
            "assert opposite_signs_list([(0, 0), (0, -1), (1, 1)]) == [False, True, False]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'a': int, 'b': int, and the return type should be annotated as bool.",
        "code_before": "def opposite_signs(x, y):\n    return (x >= 0 and y < 0) or (x < 0 and y >= 0)\n",
        "base_tests": [
            "assert opposite_signs(1,-2) == True",
            "assert opposite_signs(3,2) == False",
            "assert opposite_signs(-10,-10) == False"
        ],
        "tests": [
            "assert opposite_signs.__annotations__ == {'a': int, 'b': int, 'return': bool}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple, linear control flow.",
        "code_before": "def opposite_signs(x, y):\n    return (x >= 0 and y < 0) or (x < 0 and y >= 0)\n",
        "base_tests": [
            "assert opposite_signs(1,-2) == True",
            "assert opposite_signs(3,2) == False",
            "assert opposite_signs(-10,-10) == False"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(opposite_signs))[0].complexity <=3"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def opposite_signs(x, y):\n    return (x >= 0 and y < 0) or (x < 0 and y >= 0)\n",
        "base_tests": [
            "assert opposite_signs(1,-2) == True",
            "assert opposite_signs(3,2) == False",
            "assert opposite_signs(-10,-10) == False"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(opposite_signs)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'is_octagonal' to find the nth octagonal number.",
        "instruction": "The function should raise a ValueError as 'Input must be a positive integer' if the input is not a positive integer.",
        "code_before": "def is_octagonal(n):\n    return n * (3*n - 2)\n",
        "base_tests": [
            "assert is_octagonal(5) == 65",
            "assert is_octagonal(10) == 280",
            "assert is_octagonal(15) == 645"
        ],
        "tests": [
            "try:\n    is_octagonal(-1)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a positive integer'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'is_octagonal' to find the nth octagonal number.",
        "instruction": "The function should correctly handle the edge case where n is 1, returning the first octagonal number.",
        "code_before": "def is_octagonal(n):\n    return n * (3*n - 2)\n",
        "base_tests": [
            "assert is_octagonal(5) == 65",
            "assert is_octagonal(10) == 280",
            "assert is_octagonal(15) == 645"
        ],
        "tests": [
            "assert is_octagonal(1) == 1"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'is_octagonal' to find the nth octagonal number.",
        "instruction": "Extend the function to return a list of the first n octagonal numbers if n is a list.",
        "code_before": "def is_octagonal(n):\n    return n * (3*n - 2)\n",
        "base_tests": [
            "assert is_octagonal(5) == 65",
            "assert is_octagonal(10) == 280",
            "assert is_octagonal(15) == 645"
        ],
        "tests": [
            "assert is_octagonal([1, 2, 3]) == [1, 8, 21]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'is_octagonal' to find the nth octagonal number.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as int.",
        "code_before": "def is_octagonal(n):\n    return n * (3*n - 2)\n",
        "base_tests": [
            "assert is_octagonal(5) == 65",
            "assert is_octagonal(10) == 280",
            "assert is_octagonal(15) == 645"
        ],
        "tests": [
            "assert is_octagonal.__annotations__ == {'n': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'is_octagonal' to find the nth octagonal number.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def is_octagonal(n):\n    return n * (3*n - 2)\n",
        "base_tests": [
            "assert is_octagonal(5) == 65",
            "assert is_octagonal(10) == 280",
            "assert is_octagonal(15) == 645"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(is_octagonal)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'max_len_sub' to find the maximum length of the subsequence with difference between adjacent elements for the given array.",
        "instruction": "The function should accept an array of integers and an integer as input, and return an integer representing the maximum length of the subsequence.",
        "code_before": "def max_len_sub(arr):\n    n = len(arr)\n    dp = [1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) <= 1 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n",
        "base_tests": [
            "assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5",
            "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4",
            "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"
        ],
        "tests": [
            "assert isinstance(max_len_sub([1, 2, 3], 3), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'max_len_sub' to find the maximum length of the subsequence with difference between adjacent elements for the given array.",
        "instruction": "The function should raise a TypeError if the input array is not a list or if the second parameter is not an integer.",
        "code_before": "def max_len_sub(arr):\n    n = len(arr)\n    dp = [1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) <= 1 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n",
        "base_tests": [
            "assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5",
            "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4",
            "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"
        ],
        "tests": [
            "try: max_len_sub('not a list', 3)\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'\ntry: max_len_sub([1, 2, 3], 'not an int')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'max_len_sub' to find the maximum length of the subsequence with difference between adjacent elements for the given array.",
        "instruction": "The function should return 0 if the input array is empty, as there are no subsequences possible.",
        "code_before": "def max_len_sub(arr):\n    n = len(arr)\n    dp = [1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) <= 1 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n",
        "base_tests": [
            "assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5",
            "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4",
            "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"
        ],
        "tests": [
            "assert max_len_sub([], 3) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'max_len_sub' to find the maximum length of the subsequence with difference between adjacent elements for the given array.",
        "instruction": "Extend the function to handle cases where the difference between adjacent elements can be negative, and still find the maximum length of the subsequence.",
        "code_before": "def max_len_sub(arr):\n    n = len(arr)\n    dp = [1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) <= 1 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n",
        "base_tests": [
            "assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5",
            "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4",
            "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"
        ],
        "tests": [
            "assert max_len_sub([10, 7, 4, 1, -2], -3) == 5"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'max_len_sub' to find the maximum length of the subsequence with difference between adjacent elements for the given array.",
        "instruction": "The function should include type annotations for its parameters and return type, indicating that it accepts a list of integers and an integer, and returns an integer.",
        "code_before": "def max_len_sub(arr):\n    n = len(arr)\n    dp = [1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) <= 1 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n",
        "base_tests": [
            "assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5",
            "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4",
            "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"
        ],
        "tests": [
            "assert max_len_sub.__annotations__ == {'arr': list, 'diff': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'max_len_sub' to find the maximum length of the subsequence with difference between adjacent elements for the given array.",
        "instruction": "The function should follow PEP 8 guidelines, including proper naming conventions, indentation, and spacing.",
        "code_before": "def max_len_sub(arr):\n    n = len(arr)\n    dp = [1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) <= 1 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n",
        "base_tests": [
            "assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5",
            "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4",
            "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(max_len_sub)"
        ],
        "ins_type": "Code Standard"
    }
]