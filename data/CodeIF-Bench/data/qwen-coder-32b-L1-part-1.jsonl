[
    {
        "prompt": "Write a python function called 'remove_occ' to remove first and last occurrence of a given character from the string.",
        "instruction": "The function should raise a ValueError with the message 'Second parameter must be a single character.' if the second parameter is not a single character.",
        "code_before": "def remove_occ(s, ch):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The input string.\n    ch (str): The character to be removed.\n\n    Returns:\n    str: The modified string with the first and last occurrence of ch removed.\n    \"\"\"\n    # Find the first occurrence of the character\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        # If the character is not found, return the original string\n        return s\n\n    # Find the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    if last_occurrence == -1 or first_occurrence == last_occurrence:\n        # If the character is not found or there's only one occurrence, return the string without the first occurrence\n        return s[:first_occurrence] + s[first_occurrence+1:]\n\n    # Remove the first and last occurrence of the character\n    return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n\n# Example usage:\nprint(remove_occ(\"banana\", \"a\"))  # Output: \"banan\"\nprint(remove_occ(\"hello world\", \"l\"))  # Output: \"helo world\"\nprint(remove_occ(\"abcde\", \"f\"))  # Output: \"abcde\"\nprint(remove_occ(\"abcde\", \"a\"))  # Output: \"bcde\"\nprint(remove_occ(\"abcde\", \"e\"))  # Output: \"abcd\"\n\n\n",
        "base_tests": [
            "assert remove_occ(\"hello\",\"l\") == \"heo\"",
            "assert remove_occ(\"abcda\",\"a\") == \"bcd\"",
            "assert remove_occ(\"PHP\",\"P\") == \"H\""
        ],
        "tests": [
            "try: remove_occ('hello', 'll')\nexcept ValueError as e: assert str(e) == 'Second parameter must be a single character.'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'remove_occ' to remove first and last occurrence of a given character from the string.",
        "instruction": "The function should return the original string if the character to be removed does not exist in the string.",
        "code_before": "def remove_occ(s, ch):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The input string.\n    ch (str): The character to be removed.\n\n    Returns:\n    str: The modified string with the first and last occurrence of ch removed.\n    \"\"\"\n    # Find the first occurrence of the character\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        # If the character is not found, return the original string\n        return s\n\n    # Find the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    if last_occurrence == -1 or first_occurrence == last_occurrence:\n        # If the character is not found or there's only one occurrence, return the string without the first occurrence\n        return s[:first_occurrence] + s[first_occurrence+1:]\n\n    # Remove the first and last occurrence of the character\n    return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n\n# Example usage:\nprint(remove_occ(\"banana\", \"a\"))  # Output: \"banan\"\nprint(remove_occ(\"hello world\", \"l\"))  # Output: \"helo world\"\nprint(remove_occ(\"abcde\", \"f\"))  # Output: \"abcde\"\nprint(remove_occ(\"abcde\", \"a\"))  # Output: \"bcde\"\nprint(remove_occ(\"abcde\", \"e\"))  # Output: \"abcd\"\n\n\n",
        "base_tests": [
            "assert remove_occ(\"hello\",\"l\") == \"heo\"",
            "assert remove_occ(\"abcda\",\"a\") == \"bcd\"",
            "assert remove_occ(\"PHP\",\"P\") == \"H\""
        ],
        "tests": [
            "assert remove_occ('hello', 'x') == 'hello'"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'remove_occ' to remove first and last occurrence of a given character from the string.",
        "instruction": "Extend the function to remove all occurrences of the character if a third parameter 'all' is set to True.",
        "code_before": "def remove_occ(s, ch):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The input string.\n    ch (str): The character to be removed.\n\n    Returns:\n    str: The modified string with the first and last occurrence of ch removed.\n    \"\"\"\n    # Find the first occurrence of the character\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        # If the character is not found, return the original string\n        return s\n\n    # Find the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    if last_occurrence == -1 or first_occurrence == last_occurrence:\n        # If the character is not found or there's only one occurrence, return the string without the first occurrence\n        return s[:first_occurrence] + s[first_occurrence+1:]\n\n    # Remove the first and last occurrence of the character\n    return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n\n# Example usage:\nprint(remove_occ(\"banana\", \"a\"))  # Output: \"banan\"\nprint(remove_occ(\"hello world\", \"l\"))  # Output: \"helo world\"\nprint(remove_occ(\"abcde\", \"f\"))  # Output: \"abcde\"\nprint(remove_occ(\"abcde\", \"a\"))  # Output: \"bcde\"\nprint(remove_occ(\"abcde\", \"e\"))  # Output: \"abcd\"\n\n\n",
        "base_tests": [
            "assert remove_occ(\"hello\",\"l\") == \"heo\"",
            "assert remove_occ(\"abcda\",\"a\") == \"bcd\"",
            "assert remove_occ(\"PHP\",\"P\") == \"H\""
        ],
        "tests": [
            "assert remove_occ('banana', 'a', all=True) == 'bnn'"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'remove_occ' to remove first and last occurrence of a given character from the string.",
        "instruction": "The function should include type annotations for its parameters and return type, including two parameters: 's': str, 'ch': str, and a return type: str.",
        "code_before": "def remove_occ(s, ch):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The input string.\n    ch (str): The character to be removed.\n\n    Returns:\n    str: The modified string with the first and last occurrence of ch removed.\n    \"\"\"\n    # Find the first occurrence of the character\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        # If the character is not found, return the original string\n        return s\n\n    # Find the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    if last_occurrence == -1 or first_occurrence == last_occurrence:\n        # If the character is not found or there's only one occurrence, return the string without the first occurrence\n        return s[:first_occurrence] + s[first_occurrence+1:]\n\n    # Remove the first and last occurrence of the character\n    return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n\n# Example usage:\nprint(remove_occ(\"banana\", \"a\"))  # Output: \"banan\"\nprint(remove_occ(\"hello world\", \"l\"))  # Output: \"helo world\"\nprint(remove_occ(\"abcde\", \"f\"))  # Output: \"abcde\"\nprint(remove_occ(\"abcde\", \"a\"))  # Output: \"bcde\"\nprint(remove_occ(\"abcde\", \"e\"))  # Output: \"abcd\"\n\n\n",
        "base_tests": [
            "assert remove_occ(\"hello\",\"l\") == \"heo\"",
            "assert remove_occ(\"abcda\",\"a\") == \"bcd\"",
            "assert remove_occ(\"PHP\",\"P\") == \"H\""
        ],
        "tests": [
            "assert remove_occ.__annotations__ == {'s': str, 'ch': str, 'return': str}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'remove_occ' to remove first and last occurrence of a given character from the string.",
        "instruction": "The function should have a cyclomatic complexity of 3 or less.",
        "code_before": "def remove_occ(s, ch):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The input string.\n    ch (str): The character to be removed.\n\n    Returns:\n    str: The modified string with the first and last occurrence of ch removed.\n    \"\"\"\n    # Find the first occurrence of the character\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        # If the character is not found, return the original string\n        return s\n\n    # Find the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    if last_occurrence == -1 or first_occurrence == last_occurrence:\n        # If the character is not found or there's only one occurrence, return the string without the first occurrence\n        return s[:first_occurrence] + s[first_occurrence+1:]\n\n    # Remove the first and last occurrence of the character\n    return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n\n# Example usage:\nprint(remove_occ(\"banana\", \"a\"))  # Output: \"banan\"\nprint(remove_occ(\"hello world\", \"l\"))  # Output: \"helo world\"\nprint(remove_occ(\"abcde\", \"f\"))  # Output: \"abcde\"\nprint(remove_occ(\"abcde\", \"a\"))  # Output: \"bcde\"\nprint(remove_occ(\"abcde\", \"e\"))  # Output: \"abcd\"\n\n\n",
        "base_tests": [
            "assert remove_occ(\"hello\",\"l\") == \"heo\"",
            "assert remove_occ(\"abcda\",\"a\") == \"bcd\"",
            "assert remove_occ(\"PHP\",\"P\") == \"H\""
        ],
        "tests": [
            "from mccabe import get_code_complexity\nimport inspect\nsource_code = inspect.getsource(remove_occ)\nassert get_code_complexity(source_code) <= 3"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'remove_occ' to remove first and last occurrence of a given character from the string.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper indentation and spacing.",
        "code_before": "def remove_occ(s, ch):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The input string.\n    ch (str): The character to be removed.\n\n    Returns:\n    str: The modified string with the first and last occurrence of ch removed.\n    \"\"\"\n    # Find the first occurrence of the character\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        # If the character is not found, return the original string\n        return s\n\n    # Find the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    if last_occurrence == -1 or first_occurrence == last_occurrence:\n        # If the character is not found or there's only one occurrence, return the string without the first occurrence\n        return s[:first_occurrence] + s[first_occurrence+1:]\n\n    # Remove the first and last occurrence of the character\n    return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n\n# Example usage:\nprint(remove_occ(\"banana\", \"a\"))  # Output: \"banan\"\nprint(remove_occ(\"hello world\", \"l\"))  # Output: \"helo world\"\nprint(remove_occ(\"abcde\", \"f\"))  # Output: \"abcde\"\nprint(remove_occ(\"abcde\", \"a\"))  # Output: \"bcde\"\nprint(remove_occ(\"abcde\", \"e\"))  # Output: \"abcd\"\n\n\n",
        "base_tests": [
            "assert remove_occ(\"hello\",\"l\") == \"heo\"",
            "assert remove_occ(\"abcda\",\"a\") == \"bcd\"",
            "assert remove_occ(\"PHP\",\"P\") == \"H\""
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(remove_occ)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'sort_matrix' to sort a given matrix in ascending order according to the sum of its rows.",
        "instruction": "The function should raise a TypeError if the input is not a list of lists or if any element in the matrix is not an integer.",
        "code_before": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): A 2D list representing the matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix\n\n# Example usage:\nmatrix = [\n    [3, 2, 1],\n    [1, 2, 3],\n    [4, 5, 6],\n    [0, 0, 0]\n]\n\nsorted_matrix = sort_matrix(matrix)\nprint(sorted_matrix)\n\n\n",
        "base_tests": [
            "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
            "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
            "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
        ],
        "tests": [
            "try: sort_matrix('not a matrix')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'\ntry: sort_matrix([[1, 2], [3, 'a']])\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'sort_matrix' to sort a given matrix in ascending order according to the sum of its rows.",
        "instruction": "The function should correctly handle an empty matrix by returning an empty matrix.",
        "code_before": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): A 2D list representing the matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix\n\n# Example usage:\nmatrix = [\n    [3, 2, 1],\n    [1, 2, 3],\n    [4, 5, 6],\n    [0, 0, 0]\n]\n\nsorted_matrix = sort_matrix(matrix)\nprint(sorted_matrix)\n\n\n",
        "base_tests": [
            "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
            "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
            "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
        ],
        "tests": [
            "assert sort_matrix([]) == []"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'sort_matrix' to sort a given matrix in ascending order according to the sum of its rows.",
        "instruction": "Extend the function to handle matrices with rows of varying lengths by treating missing values as zeros.",
        "code_before": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): A 2D list representing the matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix\n\n# Example usage:\nmatrix = [\n    [3, 2, 1],\n    [1, 2, 3],\n    [4, 5, 6],\n    [0, 0, 0]\n]\n\nsorted_matrix = sort_matrix(matrix)\nprint(sorted_matrix)\n\n\n",
        "base_tests": [
            "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
            "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
            "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
        ],
        "tests": [
            "assert sort_matrix([[1, 2, 3], [4, 5], [6]]) == [[6], [4, 5], [1, 2, 3]]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'sort_matrix' to sort a given matrix in ascending order according to the sum of its rows.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'matrix': 'list[list[int]]', and a return type: 'list[list[int]]'.",
        "code_before": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): A 2D list representing the matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix\n\n# Example usage:\nmatrix = [\n    [3, 2, 1],\n    [1, 2, 3],\n    [4, 5, 6],\n    [0, 0, 0]\n]\n\nsorted_matrix = sort_matrix(matrix)\nprint(sorted_matrix)\n\n\n",
        "base_tests": [
            "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
            "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
            "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
        ],
        "tests": [
            "def test_annotations():\n    from typing import get_type_hints\n    hints = get_type_hints(sort_matrix)\n    assert hints == {'matrix': 'list[list[int]]', 'return': 'list[list[int]]'}\ntest_annotations()"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'sort_matrix' to sort a given matrix in ascending order according to the sum of its rows.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation, spacing, and naming conventions.",
        "code_before": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): A 2D list representing the matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix\n\n# Example usage:\nmatrix = [\n    [3, 2, 1],\n    [1, 2, 3],\n    [4, 5, 6],\n    [0, 0, 0]\n]\n\nsorted_matrix = sort_matrix(matrix)\nprint(sorted_matrix)\n\n\n",
        "base_tests": [
            "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
            "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
            "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    code_string = inspect.getsource(function_name)\n    with open(filename, \"w\") as file:\n        file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=True)\n        result = style.check_files([filename])\n        if result.total_errors > 0:\n            print(f\"PEP 8 violations found: {result.total_errors} errors.\")\n        if result.total_errors > 0:\n            print(f\"PEP 8 violations found: {result.total_errors} errors.\")\n        os.remove(filename)\n    assert result.total_errors == 0\ncheck_code_style(sort_matrix)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'count_common' to count the most common words in a dictionary.",
        "instruction": "The function should raise a TypeError if the input is not a list of strings.",
        "code_before": "from collections import Counter\n\ndef count_common(word_dict, n=1):\n    \"\"\"\n    Count the n most common words in a dictionary.\n\n    :param word_dict: A dictionary where keys are words and values are their counts.\n    :param n: The number of most common words to return.\n    :return: A list of tuples, where each tuple contains a word and its count.\n    \"\"\"\n    # Create a Counter object from the dictionary\n    counter = Counter(word_dict)\n    \n    # Get the n most common words\n    most_common_words = counter.most_common(n)\n    \n    return most_common_words\n\n# Example usage:\nword_counts = {\n    'apple': 4,\n    'banana': 2,\n    'orange': 5,\n    'pear': 3,\n    'grape': 1\n}\n\nprint(count_common(word_counts, 3))  # Output: [('orange', 5), ('apple', 4), ('pear', 3)]\n\n\n",
        "base_tests": [
            "assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]",
            "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]",
            "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"
        ],
        "tests": [
            "try: count_common('not a list')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'\ntry: count_common([123, 'word'])\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'count_common' to count the most common words in a dictionary.",
        "instruction": "The function should handle an empty list input by returning an empty list.",
        "code_before": "from collections import Counter\n\ndef count_common(word_dict, n=1):\n    \"\"\"\n    Count the n most common words in a dictionary.\n\n    :param word_dict: A dictionary where keys are words and values are their counts.\n    :param n: The number of most common words to return.\n    :return: A list of tuples, where each tuple contains a word and its count.\n    \"\"\"\n    # Create a Counter object from the dictionary\n    counter = Counter(word_dict)\n    \n    # Get the n most common words\n    most_common_words = counter.most_common(n)\n    \n    return most_common_words\n\n# Example usage:\nword_counts = {\n    'apple': 4,\n    'banana': 2,\n    'orange': 5,\n    'pear': 3,\n    'grape': 1\n}\n\nprint(count_common(word_counts, 3))  # Output: [('orange', 5), ('apple', 4), ('pear', 3)]\n\n\n",
        "base_tests": [
            "assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]",
            "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]",
            "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"
        ],
        "tests": [
            "assert count_common([]) == []"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'count_common' to count the most common words in a dictionary.",
        "instruction": "Extend the function to allow an optional parameter that specifies the number of top frequent words to return.",
        "code_before": "from collections import Counter\n\ndef count_common(word_dict, n=1):\n    \"\"\"\n    Count the n most common words in a dictionary.\n\n    :param word_dict: A dictionary where keys are words and values are their counts.\n    :param n: The number of most common words to return.\n    :return: A list of tuples, where each tuple contains a word and its count.\n    \"\"\"\n    # Create a Counter object from the dictionary\n    counter = Counter(word_dict)\n    \n    # Get the n most common words\n    most_common_words = counter.most_common(n)\n    \n    return most_common_words\n\n# Example usage:\nword_counts = {\n    'apple': 4,\n    'banana': 2,\n    'orange': 5,\n    'pear': 3,\n    'grape': 1\n}\n\nprint(count_common(word_counts, 3))  # Output: [('orange', 5), ('apple', 4), ('pear', 3)]\n\n\n",
        "base_tests": [
            "assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]",
            "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]",
            "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"
        ],
        "tests": [
            "assert count_common(['apple', 'banana', 'apple', 'orange', 'banana', 'banana'], 2) == [('banana', 3), ('apple', 2)]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'count_common' to count the most common words in a dictionary.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'words': list, and a return type: list.",
        "code_before": "from collections import Counter\n\ndef count_common(word_dict, n=1):\n    \"\"\"\n    Count the n most common words in a dictionary.\n\n    :param word_dict: A dictionary where keys are words and values are their counts.\n    :param n: The number of most common words to return.\n    :return: A list of tuples, where each tuple contains a word and its count.\n    \"\"\"\n    # Create a Counter object from the dictionary\n    counter = Counter(word_dict)\n    \n    # Get the n most common words\n    most_common_words = counter.most_common(n)\n    \n    return most_common_words\n\n# Example usage:\nword_counts = {\n    'apple': 4,\n    'banana': 2,\n    'orange': 5,\n    'pear': 3,\n    'grape': 1\n}\n\nprint(count_common(word_counts, 3))  # Output: [('orange', 5), ('apple', 4), ('pear', 3)]\n\n\n",
        "base_tests": [
            "assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]",
            "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]",
            "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"
        ],
        "tests": [
            "assert count_common.__annotations__ == {'words': list, 'return': list}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.",
        "instruction": "The function should accept three positive numerical inputs representing the base area, height, and length of the triangular prism, and return a positive numerical output representing the volume.The inputs can be either integers or floating-point numbers.",
        "code_before": "def find_volume(base_length, base_height, prism_height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base_length (float): The length of the base of the triangular face.\n    base_height (float): The height of the triangular face.\n    prism_height (float): The height (or length) of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the triangular base\n    base_area = 0.5 * base_length * base_height\n    \n    # Calculate the volume of the prism\n    volume = base_area * prism_height\n    \n    return volume\n\n# Example usage:\n# base_length = 5, base_height = 4, prism_height = 10\n# Expected volume = 0.5 * 5 * 4 * 10 = 100\nprint(find_volume(5, 4, 10))  # Output: 100.0\n\n\n",
        "base_tests": [
            "assert find_volume(10,8,6) == 240",
            "assert find_volume(3,2,2) == 6",
            "assert find_volume(1,2,1) == 1"
        ],
        "tests": [
            "assert find_volume(5.5, 3.2, 4.1) == 72.16",
            "assert find_volume(7, 2, 3) == 42"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.",
        "instruction": "The function should raise a ValueError with error message 'All dimensions must be positive numbers.' if any of the inputs are non-positive or non-numeric.",
        "code_before": "def find_volume(base_length, base_height, prism_height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base_length (float): The length of the base of the triangular face.\n    base_height (float): The height of the triangular face.\n    prism_height (float): The height (or length) of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the triangular base\n    base_area = 0.5 * base_length * base_height\n    \n    # Calculate the volume of the prism\n    volume = base_area * prism_height\n    \n    return volume\n\n# Example usage:\n# base_length = 5, base_height = 4, prism_height = 10\n# Expected volume = 0.5 * 5 * 4 * 10 = 100\nprint(find_volume(5, 4, 10))  # Output: 100.0\n\n\n",
        "base_tests": [
            "assert find_volume(10,8,6) == 240",
            "assert find_volume(3,2,2) == 6",
            "assert find_volume(1,2,1) == 1"
        ],
        "tests": [
            "try: find_volume(-1, 2, 3)\nexcept ValueError as e: assert str(e) == 'All dimensions must be positive numbers.'\nelse: assert False, 'TypeError not raised'",
            "try: find_volume('a', 2, 3)\nexcept ValueError as e: assert str(e) == 'All dimensions must be positive numbers.'\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.",
        "instruction": "The function should correctly handle edge cases where one or more dimensions are at their minimum positive value.",
        "code_before": "def find_volume(base_length, base_height, prism_height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base_length (float): The length of the base of the triangular face.\n    base_height (float): The height of the triangular face.\n    prism_height (float): The height (or length) of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the triangular base\n    base_area = 0.5 * base_length * base_height\n    \n    # Calculate the volume of the prism\n    volume = base_area * prism_height\n    \n    return volume\n\n# Example usage:\n# base_length = 5, base_height = 4, prism_height = 10\n# Expected volume = 0.5 * 5 * 4 * 10 = 100\nprint(find_volume(5, 4, 10))  # Output: 100.0\n\n\n",
        "base_tests": [
            "assert find_volume(10,8,6) == 240",
            "assert find_volume(3,2,2) == 6",
            "assert find_volume(1,2,1) == 1"
        ],
        "tests": [
            "assert find_volume(0.0001, 0.0001, 0.0001) == 5e-13",
            "assert find_volume(1, 1, 1) == 0.5"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.",
        "instruction": "Extend the function to handle inputs as a list or tuple of three elements, representing the base area, height, and length.",
        "code_before": "def find_volume(base_length, base_height, prism_height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base_length (float): The length of the base of the triangular face.\n    base_height (float): The height of the triangular face.\n    prism_height (float): The height (or length) of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the triangular base\n    base_area = 0.5 * base_length * base_height\n    \n    # Calculate the volume of the prism\n    volume = base_area * prism_height\n    \n    return volume\n\n# Example usage:\n# base_length = 5, base_height = 4, prism_height = 10\n# Expected volume = 0.5 * 5 * 4 * 10 = 100\nprint(find_volume(5, 4, 10))  # Output: 100.0\n\n\n",
        "base_tests": [
            "assert find_volume(10,8,6) == 240",
            "assert find_volume(3,2,2) == 6",
            "assert find_volume(1,2,1) == 1"
        ],
        "tests": [
            "assert find_volume([10, 8, 6]) == 240",
            "assert find_volume((3, 2, 2)) == 6"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.",
        "instruction": "The function should include type annotations for its parameters and return type, including three parameters: 'base_area': float, 'height': float, 'length': float, and a return type: float, and have a docstring explaining its purpose and usage: 'Calculate the volume of a triangular prism.'",
        "code_before": "def find_volume(base_length, base_height, prism_height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base_length (float): The length of the base of the triangular face.\n    base_height (float): The height of the triangular face.\n    prism_height (float): The height (or length) of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the triangular base\n    base_area = 0.5 * base_length * base_height\n    \n    # Calculate the volume of the prism\n    volume = base_area * prism_height\n    \n    return volume\n\n# Example usage:\n# base_length = 5, base_height = 4, prism_height = 10\n# Expected volume = 0.5 * 5 * 4 * 10 = 100\nprint(find_volume(5, 4, 10))  # Output: 100.0\n\n\n",
        "base_tests": [
            "assert find_volume(10,8,6) == 240",
            "assert find_volume(3,2,2) == 6",
            "assert find_volume(1,2,1) == 1"
        ],
        "tests": [
            "assert find_volume.__annotations__ == {'base_area': float, 'height': float, 'length': float, 'return': float}",
            "assert 'Calculate the volume of a triangular prism' in find_volume.__doc__"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.",
        "instruction": "The function should maintain a cyclomatic complexity of 1, indicating a straightforward calculation without any branching.",
        "code_before": "def find_volume(base_length, base_height, prism_height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base_length (float): The length of the base of the triangular face.\n    base_height (float): The height of the triangular face.\n    prism_height (float): The height (or length) of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the triangular base\n    base_area = 0.5 * base_length * base_height\n    \n    # Calculate the volume of the prism\n    volume = base_area * prism_height\n    \n    return volume\n\n# Example usage:\n# base_length = 5, base_height = 4, prism_height = 10\n# Expected volume = 0.5 * 5 * 4 * 10 = 100\nprint(find_volume(5, 4, 10))  # Output: 100.0\n\n\n",
        "base_tests": [
            "assert find_volume(10,8,6) == 240",
            "assert find_volume(3,2,2) == 6",
            "assert find_volume(1,2,1) == 1"
        ],
        "tests": [
            "from mccabe import get_code_complexity\nimport inspect\nsource_code = inspect.getsource(find_volume)\nassert get_code_complexity(source_code) <= 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def find_volume(base_length, base_height, prism_height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base_length (float): The length of the base of the triangular face.\n    base_height (float): The height of the triangular face.\n    prism_height (float): The height (or length) of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the triangular base\n    base_area = 0.5 * base_length * base_height\n    \n    # Calculate the volume of the prism\n    volume = base_area * prism_height\n    \n    return volume\n\n# Example usage:\n# base_length = 5, base_height = 4, prism_height = 10\n# Expected volume = 0.5 * 5 * 4 * 10 = 100\nprint(find_volume(5, 4, 10))  # Output: 100.0\n\n\n",
        "base_tests": [
            "assert find_volume(10,8,6) == 240",
            "assert find_volume(3,2,2) == 6",
            "assert find_volume(1,2,1) == 1"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_volume)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.",
        "instruction": "The function should accept a single string input and return a list of strings, each representing a segment of the original string split at lowercase letters.",
        "code_before": "import re\n\ndef split_lowerstring(s):\n    \"\"\"\n    Splits a string at lowercase letters and returns a list of substrings.\n    \n    Parameters:\n    s (str): The string to be split.\n    \n    Returns:\n    list: A list of substrings split at lowercase letters.\n    \"\"\"\n    # Use regular expression to split the string at lowercase letters\n    substrings = re.split('[a-z]', s)\n    \n    # Filter out any empty strings that may result from consecutive lowercase letters\n    substrings = [substring for substring in substrings if substring]\n    \n    return substrings\n\n# Example usage:\nprint(split_lowerstring(\"HelloWorld\"))  # Output: ['H', 'W']\nprint(split_lowerstring(\"aBcDeFg\"))     # Output: ['B', 'D', 'F', 'G']\nprint(split_lowerstring(\"Python3.8\"))   # Output: ['P', '3.8']\n\n\n",
        "base_tests": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "tests": [
            "assert isinstance(split_lowerstring('Test'), list) and all(isinstance(i, str) for i in split_lowerstring('Test'))"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.",
        "instruction": "The function should raise a TypeError if the input is not a string.",
        "code_before": "import re\n\ndef split_lowerstring(s):\n    \"\"\"\n    Splits a string at lowercase letters and returns a list of substrings.\n    \n    Parameters:\n    s (str): The string to be split.\n    \n    Returns:\n    list: A list of substrings split at lowercase letters.\n    \"\"\"\n    # Use regular expression to split the string at lowercase letters\n    substrings = re.split('[a-z]', s)\n    \n    # Filter out any empty strings that may result from consecutive lowercase letters\n    substrings = [substring for substring in substrings if substring]\n    \n    return substrings\n\n# Example usage:\nprint(split_lowerstring(\"HelloWorld\"))  # Output: ['H', 'W']\nprint(split_lowerstring(\"aBcDeFg\"))     # Output: ['B', 'D', 'F', 'G']\nprint(split_lowerstring(\"Python3.8\"))   # Output: ['P', '3.8']\n\n\n",
        "base_tests": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "tests": [
            "try: split_lowerstring(123); assert False, 'Expected TypeError' except TypeError: pass"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.",
        "instruction": "The function should return an empty list if the input string contains no lowercase letters.",
        "code_before": "import re\n\ndef split_lowerstring(s):\n    \"\"\"\n    Splits a string at lowercase letters and returns a list of substrings.\n    \n    Parameters:\n    s (str): The string to be split.\n    \n    Returns:\n    list: A list of substrings split at lowercase letters.\n    \"\"\"\n    # Use regular expression to split the string at lowercase letters\n    substrings = re.split('[a-z]', s)\n    \n    # Filter out any empty strings that may result from consecutive lowercase letters\n    substrings = [substring for substring in substrings if substring]\n    \n    return substrings\n\n# Example usage:\nprint(split_lowerstring(\"HelloWorld\"))  # Output: ['H', 'W']\nprint(split_lowerstring(\"aBcDeFg\"))     # Output: ['B', 'D', 'F', 'G']\nprint(split_lowerstring(\"Python3.8\"))   # Output: ['P', '3.8']\n\n\n",
        "base_tests": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "tests": [
            "assert split_lowerstring('ABC') == []"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.",
        "instruction": "Extend the function to optionally include the uppercase letters at the start of each segment in the output list when include_lower = True",
        "code_before": "import re\n\ndef split_lowerstring(s):\n    \"\"\"\n    Splits a string at lowercase letters and returns a list of substrings.\n    \n    Parameters:\n    s (str): The string to be split.\n    \n    Returns:\n    list: A list of substrings split at lowercase letters.\n    \"\"\"\n    # Use regular expression to split the string at lowercase letters\n    substrings = re.split('[a-z]', s)\n    \n    # Filter out any empty strings that may result from consecutive lowercase letters\n    substrings = [substring for substring in substrings if substring]\n    \n    return substrings\n\n# Example usage:\nprint(split_lowerstring(\"HelloWorld\"))  # Output: ['H', 'W']\nprint(split_lowerstring(\"aBcDeFg\"))     # Output: ['B', 'D', 'F', 'G']\nprint(split_lowerstring(\"Python3.8\"))   # Output: ['P', '3.8']\n\n\n",
        "base_tests": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "tests": [
            "assert split_lowerstring('AbCd', include_lower=True) == ['Ab', 'Cd']"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'text': str, and a return type: list.",
        "code_before": "import re\n\ndef split_lowerstring(s):\n    \"\"\"\n    Splits a string at lowercase letters and returns a list of substrings.\n    \n    Parameters:\n    s (str): The string to be split.\n    \n    Returns:\n    list: A list of substrings split at lowercase letters.\n    \"\"\"\n    # Use regular expression to split the string at lowercase letters\n    substrings = re.split('[a-z]', s)\n    \n    # Filter out any empty strings that may result from consecutive lowercase letters\n    substrings = [substring for substring in substrings if substring]\n    \n    return substrings\n\n# Example usage:\nprint(split_lowerstring(\"HelloWorld\"))  # Output: ['H', 'W']\nprint(split_lowerstring(\"aBcDeFg\"))     # Output: ['B', 'D', 'F', 'G']\nprint(split_lowerstring(\"Python3.8\"))   # Output: ['P', '3.8']\n\n\n",
        "base_tests": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "tests": [
            "assert 'def split_lowerstring(text: str) -> list:' in inspect.getsource(split_lowerstring)"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a single path through the code.",
        "code_before": "import re\n\ndef split_lowerstring(s):\n    \"\"\"\n    Splits a string at lowercase letters and returns a list of substrings.\n    \n    Parameters:\n    s (str): The string to be split.\n    \n    Returns:\n    list: A list of substrings split at lowercase letters.\n    \"\"\"\n    # Use regular expression to split the string at lowercase letters\n    substrings = re.split('[a-z]', s)\n    \n    # Filter out any empty strings that may result from consecutive lowercase letters\n    substrings = [substring for substring in substrings if substring]\n    \n    return substrings\n\n# Example usage:\nprint(split_lowerstring(\"HelloWorld\"))  # Output: ['H', 'W']\nprint(split_lowerstring(\"aBcDeFg\"))     # Output: ['B', 'D', 'F', 'G']\nprint(split_lowerstring(\"Python3.8\"))   # Output: ['P', '3.8']\n\n\n",
        "base_tests": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "tests": [
            "from mccabe import get_code_complexity\nimport inspect\nsource_code = inspect.getsource(split_lowerstring)\nassert get_code_complexity(source_code) <= 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation and spacing.",
        "code_before": "import re\n\ndef split_lowerstring(s):\n    \"\"\"\n    Splits a string at lowercase letters and returns a list of substrings.\n    \n    Parameters:\n    s (str): The string to be split.\n    \n    Returns:\n    list: A list of substrings split at lowercase letters.\n    \"\"\"\n    # Use regular expression to split the string at lowercase letters\n    substrings = re.split('[a-z]', s)\n    \n    # Filter out any empty strings that may result from consecutive lowercase letters\n    substrings = [substring for substring in substrings if substring]\n    \n    return substrings\n\n# Example usage:\nprint(split_lowerstring(\"HelloWorld\"))  # Output: ['H', 'W']\nprint(split_lowerstring(\"aBcDeFg\"))     # Output: ['B', 'D', 'F', 'G']\nprint(split_lowerstring(\"Python3.8\"))   # Output: ['P', '3.8']\n\n\n",
        "base_tests": [
            "assert split_lowerstring(\"AbCd\")==['bC','d']",
            "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']",
            "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(split_lowerstring)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.",
        "instruction": "The function should accept a string as input and return a string as output, specifically 'Found a match!' or 'Not matched!'.",
        "code_before": "import re\n\ndef text_lowercase_underscore(text):\n    \"\"\"\n    This function takes a string as input and returns a list of all sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    text (str): The input string to search for sequences of lowercase letters joined with an underscore.\n    \n    Returns:\n    list: A list of all sequences of lowercase letters joined with an underscore found in the input string.\n    \"\"\"\n    # Define the regular expression pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    \n    # Use the re.findall() function to find all matches of the pattern in the input string\n    matches = re.findall(pattern, text)\n    \n    return matches\n\n\n",
        "base_tests": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "tests": [
            "assert isinstance(text_lowercase_underscore('abc_def'), str)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.",
        "instruction": "The function should raise a TypeError if the input is not a string.",
        "code_before": "import re\n\ndef text_lowercase_underscore(text):\n    \"\"\"\n    This function takes a string as input and returns a list of all sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    text (str): The input string to search for sequences of lowercase letters joined with an underscore.\n    \n    Returns:\n    list: A list of all sequences of lowercase letters joined with an underscore found in the input string.\n    \"\"\"\n    # Define the regular expression pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    \n    # Use the re.findall() function to find all matches of the pattern in the input string\n    matches = re.findall(pattern, text)\n    \n    return matches\n\n\n",
        "base_tests": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "tests": [
            "try:\n    text_lowercase_underscore(123)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for non-string input'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.",
        "instruction": "The function should correctly handle an empty string input by returning 'Not matched!'.",
        "code_before": "import re\n\ndef text_lowercase_underscore(text):\n    \"\"\"\n    This function takes a string as input and returns a list of all sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    text (str): The input string to search for sequences of lowercase letters joined with an underscore.\n    \n    Returns:\n    list: A list of all sequences of lowercase letters joined with an underscore found in the input string.\n    \"\"\"\n    # Define the regular expression pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    \n    # Use the re.findall() function to find all matches of the pattern in the input string\n    matches = re.findall(pattern, text)\n    \n    return matches\n\n\n",
        "base_tests": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "tests": [
            "assert text_lowercase_underscore('') == 'Not matched!'"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.",
        "instruction": "Extend the function to handle multiple sequences separated by underscores and return 'Found a match!' if at least one sequence matches.",
        "code_before": "import re\n\ndef text_lowercase_underscore(text):\n    \"\"\"\n    This function takes a string as input and returns a list of all sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    text (str): The input string to search for sequences of lowercase letters joined with an underscore.\n    \n    Returns:\n    list: A list of all sequences of lowercase letters joined with an underscore found in the input string.\n    \"\"\"\n    # Define the regular expression pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    \n    # Use the re.findall() function to find all matches of the pattern in the input string\n    matches = re.findall(pattern, text)\n    \n    return matches\n\n\n",
        "base_tests": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "tests": [
            "assert text_lowercase_underscore('abc_def_ghi') == 'Found a match!'"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'text': str, and a return type: str.",
        "code_before": "import re\n\ndef text_lowercase_underscore(text):\n    \"\"\"\n    This function takes a string as input and returns a list of all sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    text (str): The input string to search for sequences of lowercase letters joined with an underscore.\n    \n    Returns:\n    list: A list of all sequences of lowercase letters joined with an underscore found in the input string.\n    \"\"\"\n    # Define the regular expression pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    \n    # Use the re.findall() function to find all matches of the pattern in the input string\n    matches = re.findall(pattern, text)\n    \n    return matches\n\n\n",
        "base_tests": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "tests": [
            "assert text_lowercase_underscore.__annotations__ == {'text': str, 'return': str}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a single decision point.",
        "code_before": "import re\n\ndef text_lowercase_underscore(text):\n    \"\"\"\n    This function takes a string as input and returns a list of all sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    text (str): The input string to search for sequences of lowercase letters joined with an underscore.\n    \n    Returns:\n    list: A list of all sequences of lowercase letters joined with an underscore found in the input string.\n    \"\"\"\n    # Define the regular expression pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    \n    # Use the re.findall() function to find all matches of the pattern in the input string\n    matches = re.findall(pattern, text)\n    \n    return matches\n\n\n",
        "base_tests": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(text_lowercase_underscore))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation and spacing.",
        "code_before": "import re\n\ndef text_lowercase_underscore(text):\n    \"\"\"\n    This function takes a string as input and returns a list of all sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    text (str): The input string to search for sequences of lowercase letters joined with an underscore.\n    \n    Returns:\n    list: A list of all sequences of lowercase letters joined with an underscore found in the input string.\n    \"\"\"\n    # Define the regular expression pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    \n    # Use the re.findall() function to find all matches of the pattern in the input string\n    matches = re.findall(pattern, text)\n    \n    return matches\n\n\n",
        "base_tests": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(text_lowercase_underscore)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.",
        "instruction": "The function should accept only non-negative integers as input and return a non-negative integer as output.",
        "code_before": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    side_length (float): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n    \"\"\"\n    return 4 * side_length\n\n# Example usage:\n# perimeter = square_perimeter(5)\n# print(perimeter)  # Output: 20\n\n\n",
        "base_tests": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "tests": [
            "assert square_perimeter(0) == 0\nassert square_perimeter(15) == 60\ntry:\n    square_perimeter(-5)\nexcept ValueError:\n    pass\nelse:\n    assert False, 'Expected ValueError for negative input'"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.",
        "instruction": "The function should raise a ValueError if the input is negative.",
        "code_before": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    side_length (float): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n    \"\"\"\n    return 4 * side_length\n\n# Example usage:\n# perimeter = square_perimeter(5)\n# print(perimeter)  # Output: 20\n\n\n",
        "base_tests": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "tests": [
            "try:\n    square_perimeter(-1)\nexcept ValueError:\n    pass\nelse:\n    assert False, 'Expected ValueError for negative input'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.",
        "instruction": "The function should correctly handle the edge case where the side length is zero.",
        "code_before": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    side_length (float): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n    \"\"\"\n    return 4 * side_length\n\n# Example usage:\n# perimeter = square_perimeter(5)\n# print(perimeter)  # Output: 20\n\n\n",
        "base_tests": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "tests": [
            "assert square_perimeter(0) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.",
        "instruction": "Extend the function to handle floating-point numbers by rounding them to the nearest integer using the standard rounding rule before calculating the perimeter.",
        "code_before": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    side_length (float): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n    \"\"\"\n    return 4 * side_length\n\n# Example usage:\n# perimeter = square_perimeter(5)\n# print(perimeter)  # Output: 20\n\n\n",
        "base_tests": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "tests": [
            "assert square_perimeter(4.5) == 20\nassert square_perimeter(3.7) == 16"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'a': int, and a return type: int.",
        "code_before": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    side_length (float): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n    \"\"\"\n    return 4 * side_length\n\n# Example usage:\n# perimeter = square_perimeter(5)\n# print(perimeter)  # Output: 20\n\n\n",
        "base_tests": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "tests": [
            "assert square_perimeter.__annotations__ == {'a': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a single path through the code.",
        "code_before": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    side_length (float): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n    \"\"\"\n    return 4 * side_length\n\n# Example usage:\n# perimeter = square_perimeter(5)\n# print(perimeter)  # Output: 20\n\n\n",
        "base_tests": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(square_perimeter))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square.\n\n    Parameters:\n    side_length (float): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n    \"\"\"\n    return 4 * side_length\n\n# Example usage:\n# perimeter = square_perimeter(5)\n# print(perimeter)  # Output: 20\n\n\n",
        "base_tests": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(square_perimeter)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'remove_dirty_chars' to remove characters from the first string which are present in the second string.",
        "instruction": "The function should accept two strings as input and return a string as output. The input strings should only contain alphabetic characters. If the input strings contain non-alphabetic characters, the function should raise a ValueError, and an assertion error should occur with the message: 'Input strings must only contain alphabetic characters.'",
        "code_before": "def remove_dirty_chars(input_string, chars_to_remove):\n    \"\"\"\n    Removes all characters from input_string that are present in chars_to_remove.\n\n    :param input_string: The string from which characters are to be removed.\n    :param chars_to_remove: The string containing characters to be removed from the input_string.\n    :return: A new string with the specified characters removed.\n    \"\"\"\n    # Create a set of characters to remove for faster lookup\n    chars_to_remove_set = set(chars_to_remove)\n    \n    # Use a list comprehension to filter out unwanted characters\n    cleaned_string = ''.join([char for char in input_string if char not in chars_to_remove_set])\n    \n    return cleaned_string\n\n# Example usage:\ninput_str = \"hello world\"\nchars_to_remove = \"lo\"\nresult = remove_dirty_chars(input_str, chars_to_remove)\nprint(result)  # Output: \"he wrd\"\n\n\n",
        "base_tests": [
            "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
            "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
            "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "
        ],
        "tests": [
            "assert remove_dirty_chars('hello', 'world') == 'he', 'The function did not return the expected output for valid inputs.'",
            "try: remove_dirty_chars('hell0', 'world')\nexcept ValueError as e: assert str(e) == 'Input strings must only contain alphabetic characters.'"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'remove_dirty_chars' to remove characters from the first string which are present in the second string.",
        "instruction": "The function should raise a TypeError if either of the inputs is not a string.",
        "code_before": "def remove_dirty_chars(input_string, chars_to_remove):\n    \"\"\"\n    Removes all characters from input_string that are present in chars_to_remove.\n\n    :param input_string: The string from which characters are to be removed.\n    :param chars_to_remove: The string containing characters to be removed from the input_string.\n    :return: A new string with the specified characters removed.\n    \"\"\"\n    # Create a set of characters to remove for faster lookup\n    chars_to_remove_set = set(chars_to_remove)\n    \n    # Use a list comprehension to filter out unwanted characters\n    cleaned_string = ''.join([char for char in input_string if char not in chars_to_remove_set])\n    \n    return cleaned_string\n\n# Example usage:\ninput_str = \"hello world\"\nchars_to_remove = \"lo\"\nresult = remove_dirty_chars(input_str, chars_to_remove)\nprint(result)  # Output: \"he wrd\"\n\n\n",
        "base_tests": [
            "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
            "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
            "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "
        ],
        "tests": [
            "try:\n    remove_dirty_chars(123, 'abc')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for non-string input'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'remove_dirty_chars' to remove characters from the first string which are present in the second string.",
        "instruction": "The function should return the original string if the second string is empty.",
        "code_before": "def remove_dirty_chars(input_string, chars_to_remove):\n    \"\"\"\n    Removes all characters from input_string that are present in chars_to_remove.\n\n    :param input_string: The string from which characters are to be removed.\n    :param chars_to_remove: The string containing characters to be removed from the input_string.\n    :return: A new string with the specified characters removed.\n    \"\"\"\n    # Create a set of characters to remove for faster lookup\n    chars_to_remove_set = set(chars_to_remove)\n    \n    # Use a list comprehension to filter out unwanted characters\n    cleaned_string = ''.join([char for char in input_string if char not in chars_to_remove_set])\n    \n    return cleaned_string\n\n# Example usage:\ninput_str = \"hello world\"\nchars_to_remove = \"lo\"\nresult = remove_dirty_chars(input_str, chars_to_remove)\nprint(result)  # Output: \"he wrd\"\n\n\n",
        "base_tests": [
            "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
            "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
            "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "
        ],
        "tests": [
            "assert remove_dirty_chars('example', '') == 'example', 'Function should return the original string if the second string is empty.'"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'remove_dirty_chars' to remove characters from the first string which are present in the second string.",
        "instruction": "The function should be extended to handle case-insensitive character removal.",
        "code_before": "def remove_dirty_chars(input_string, chars_to_remove):\n    \"\"\"\n    Removes all characters from input_string that are present in chars_to_remove.\n\n    :param input_string: The string from which characters are to be removed.\n    :param chars_to_remove: The string containing characters to be removed from the input_string.\n    :return: A new string with the specified characters removed.\n    \"\"\"\n    # Create a set of characters to remove for faster lookup\n    chars_to_remove_set = set(chars_to_remove)\n    \n    # Use a list comprehension to filter out unwanted characters\n    cleaned_string = ''.join([char for char in input_string if char not in chars_to_remove_set])\n    \n    return cleaned_string\n\n# Example usage:\ninput_str = \"hello world\"\nchars_to_remove = \"lo\"\nresult = remove_dirty_chars(input_str, chars_to_remove)\nprint(result)  # Output: \"he wrd\"\n\n\n",
        "base_tests": [
            "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
            "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
            "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "
        ],
        "tests": [
            "assert remove_dirty_chars('HelloWorld', 'hELLO') == 'World', 'Function should handle case-insensitive character removal.'"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'remove_dirty_chars' to remove characters from the first string which are present in the second string.",
        "instruction": "The function should include type annotations for its parameters and return type.The parameters should be annotated as 'string': str and 'second_string': str, and the return type is str.",
        "code_before": "def remove_dirty_chars(input_string, chars_to_remove):\n    \"\"\"\n    Removes all characters from input_string that are present in chars_to_remove.\n\n    :param input_string: The string from which characters are to be removed.\n    :param chars_to_remove: The string containing characters to be removed from the input_string.\n    :return: A new string with the specified characters removed.\n    \"\"\"\n    # Create a set of characters to remove for faster lookup\n    chars_to_remove_set = set(chars_to_remove)\n    \n    # Use a list comprehension to filter out unwanted characters\n    cleaned_string = ''.join([char for char in input_string if char not in chars_to_remove_set])\n    \n    return cleaned_string\n\n# Example usage:\ninput_str = \"hello world\"\nchars_to_remove = \"lo\"\nresult = remove_dirty_chars(input_str, chars_to_remove)\nprint(result)  # Output: \"he wrd\"\n\n\n",
        "base_tests": [
            "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
            "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
            "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "
        ],
        "tests": [
            "assert remove_dirty_chars.__annotations__ == {'string': str, 'second_string': str, 'return': str}, 'Function should have correct type annotations.'"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'remove_dirty_chars' to remove characters from the first string which are present in the second string.",
        "instruction": "The function should follow PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def remove_dirty_chars(input_string, chars_to_remove):\n    \"\"\"\n    Removes all characters from input_string that are present in chars_to_remove.\n\n    :param input_string: The string from which characters are to be removed.\n    :param chars_to_remove: The string containing characters to be removed from the input_string.\n    :return: A new string with the specified characters removed.\n    \"\"\"\n    # Create a set of characters to remove for faster lookup\n    chars_to_remove_set = set(chars_to_remove)\n    \n    # Use a list comprehension to filter out unwanted characters\n    cleaned_string = ''.join([char for char in input_string if char not in chars_to_remove_set])\n    \n    return cleaned_string\n\n# Example usage:\ninput_str = \"hello world\"\nchars_to_remove = \"lo\"\nresult = remove_dirty_chars(input_str, chars_to_remove)\nprint(result)  # Output: \"he wrd\"\n\n\n",
        "base_tests": [
            "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
            "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
            "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(remove_dirty_chars)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function named 'test_duplicate' to find whether a given array of integers contains any duplicate element.",
        "instruction": "The function should accept a list of integers and return a boolean indicating the presence of duplicates. It should raise a TypeError if the input is not a list.",
        "code_before": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if the given array of integers contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set with the original list\n    return len(unique_elements) != len(arr)\n\n# Example usage:\nprint(test_duplicate([1, 2, 3, 4, 5]))  # Output: False\nprint(test_duplicate([1, 2, 3, 4, 5, 3]))  # Output: True\n\n\n",
        "base_tests": [
            "assert test_duplicate(([1,2,3,4,5]))==False",
            "assert test_duplicate(([1,2,3,4, 4]))==True",
            "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
        ],
        "tests": [
            "assert test_duplicate([1, 2, 3, 4, 5]) == False",
            "assert test_duplicate([1, 2, 3, 4, 4]) == True",
            "assert test_duplicate([1, 1, 2, 2, 3, 3, 4, 4, 5]) == True",
            "try:\n    test_duplicate('12345')\n    assert False, 'TypeError not raised'\nexcept TypeError:\n    pass"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function named 'test_duplicate' to find whether a given array of integers contains any duplicate element.",
        "instruction": "The function should handle exceptions gracefully and raise a ValueError with the message 'Input must be a list of integers' if the input is not a list.",
        "code_before": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if the given array of integers contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set with the original list\n    return len(unique_elements) != len(arr)\n\n# Example usage:\nprint(test_duplicate([1, 2, 3, 4, 5]))  # Output: False\nprint(test_duplicate([1, 2, 3, 4, 5, 3]))  # Output: True\n\n\n",
        "base_tests": [
            "assert test_duplicate(([1,2,3,4,5]))==False",
            "assert test_duplicate(([1,2,3,4, 4]))==True",
            "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
        ],
        "tests": [
            "try:\n    test_duplicate(None)\n    assert False, 'TypeError not raised'\nexcept TypeError as e:\n    assert str(e) == 'Input must be a list of integers'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function named 'test_duplicate' to find whether a given array of integers contains any duplicate element.",
        "instruction": "The function should correctly handle edge cases such as an empty list and a list with one element.",
        "code_before": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if the given array of integers contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set with the original list\n    return len(unique_elements) != len(arr)\n\n# Example usage:\nprint(test_duplicate([1, 2, 3, 4, 5]))  # Output: False\nprint(test_duplicate([1, 2, 3, 4, 5, 3]))  # Output: True\n\n\n",
        "base_tests": [
            "assert test_duplicate(([1,2,3,4,5]))==False",
            "assert test_duplicate(([1,2,3,4, 4]))==True",
            "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
        ],
        "tests": [
            "assert test_duplicate([]) == False",
            "assert test_duplicate([1]) == False"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function named 'test_duplicate' to find whether a given array of integers contains any duplicate element.",
        "instruction": "Extend the function to return the list of duplicate elements if any are found, otherwise return an empty list.",
        "code_before": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if the given array of integers contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set with the original list\n    return len(unique_elements) != len(arr)\n\n# Example usage:\nprint(test_duplicate([1, 2, 3, 4, 5]))  # Output: False\nprint(test_duplicate([1, 2, 3, 4, 5, 3]))  # Output: True\n\n\n",
        "base_tests": [
            "assert test_duplicate(([1,2,3,4,5]))==False",
            "assert test_duplicate(([1,2,3,4, 4]))==True",
            "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
        ],
        "tests": [
            "assert test_duplicate([1, 2, 3, 4, 5]) == []",
            "assert test_duplicate([1, 2, 3, 4, 4]) == [4]",
            "assert test_duplicate([1, 1, 2, 2, 3, 3, 4, 4, 5]) == [1, 2, 3, 4]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function named 'test_duplicate' to find whether a given array of integers contains any duplicate element.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'arraynums': list, and the return type should be annotated as bool.",
        "code_before": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if the given array of integers contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set with the original list\n    return len(unique_elements) != len(arr)\n\n# Example usage:\nprint(test_duplicate([1, 2, 3, 4, 5]))  # Output: False\nprint(test_duplicate([1, 2, 3, 4, 5, 3]))  # Output: True\n\n\n",
        "base_tests": [
            "assert test_duplicate(([1,2,3,4,5]))==False",
            "assert test_duplicate(([1,2,3,4, 4]))==True",
            "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
        ],
        "tests": [
            "assert test_duplicate.__annotations__ == {'arraynums': list, 'return': bool}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function named 'test_duplicate' to find whether a given array of integers contains any duplicate element.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if the given array of integers contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # Compare the length of the set with the original list\n    return len(unique_elements) != len(arr)\n\n# Example usage:\nprint(test_duplicate([1, 2, 3, 4, 5]))  # Output: False\nprint(test_duplicate([1, 2, 3, 4, 5, 3]))  # Output: True\n\n\n",
        "base_tests": [
            "assert test_duplicate(([1,2,3,4,5]))==False",
            "assert test_duplicate(([1,2,3,4, 4]))==True",
            "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(test_duplicate)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.",
        "instruction": "The function should accept an integer as input and return a boolean indicating whether the number is a Woodall number.",
        "code_before": "def is_woodall(n):\n    \"\"\"\n    Check if the given number is a Woodall number.\n    \n    A Woodall number is defined as a number of the form n * 2^n - 1, where n is a positive integer.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is a Woodall number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    \n    # Start with n = 1 and check if we can find a Woodall number equal to the given number\n    i = 1\n    while True:\n        woodall_number = i * (2 ** i) - 1\n        if woodall_number == n:\n            return True\n        elif woodall_number > n:\n            return False\n        i += 1\n\n# Test the function\nprint(is_woodall(7))  # True, because 7 = 2 * 2^2 - 1\nprint(is_woodall(23)) # True, because 23 = 3 * 2^3 - 1\nprint(is_woodall(10)) # False, 10 is not a Woodall number\n\n\n",
        "base_tests": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "tests": [
            "assert isinstance(is_woodall(383), bool)",
            "assert isinstance(is_woodall(254), bool)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.",
        "instruction": "The function should raise a TypeError if the input is not an integer.",
        "code_before": "def is_woodall(n):\n    \"\"\"\n    Check if the given number is a Woodall number.\n    \n    A Woodall number is defined as a number of the form n * 2^n - 1, where n is a positive integer.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is a Woodall number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    \n    # Start with n = 1 and check if we can find a Woodall number equal to the given number\n    i = 1\n    while True:\n        woodall_number = i * (2 ** i) - 1\n        if woodall_number == n:\n            return True\n        elif woodall_number > n:\n            return False\n        i += 1\n\n# Test the function\nprint(is_woodall(7))  # True, because 7 = 2 * 2^2 - 1\nprint(is_woodall(23)) # True, because 23 = 3 * 2^3 - 1\nprint(is_woodall(10)) # False, 10 is not a Woodall number\n\n\n",
        "base_tests": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "tests": [
            "try: is_woodall('383')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'",
            "try: is_woodall(3.83)\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.",
        "instruction": "The function should correctly handle edge cases such as very large integers and zero.",
        "code_before": "def is_woodall(n):\n    \"\"\"\n    Check if the given number is a Woodall number.\n    \n    A Woodall number is defined as a number of the form n * 2^n - 1, where n is a positive integer.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is a Woodall number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    \n    # Start with n = 1 and check if we can find a Woodall number equal to the given number\n    i = 1\n    while True:\n        woodall_number = i * (2 ** i) - 1\n        if woodall_number == n:\n            return True\n        elif woodall_number > n:\n            return False\n        i += 1\n\n# Test the function\nprint(is_woodall(7))  # True, because 7 = 2 * 2^2 - 1\nprint(is_woodall(23)) # True, because 23 = 3 * 2^3 - 1\nprint(is_woodall(10)) # False, 10 is not a Woodall number\n\n\n",
        "base_tests": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "tests": [
            "assert is_woodall(0) == False",
            "assert is_woodall(1) == True",
            "assert is_woodall(999999999999) == False"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.",
        "instruction": "Extend the function to return a list of all Woodall numbers up to a given number if the input is a positive integer.",
        "code_before": "def is_woodall(n):\n    \"\"\"\n    Check if the given number is a Woodall number.\n    \n    A Woodall number is defined as a number of the form n * 2^n - 1, where n is a positive integer.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is a Woodall number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    \n    # Start with n = 1 and check if we can find a Woodall number equal to the given number\n    i = 1\n    while True:\n        woodall_number = i * (2 ** i) - 1\n        if woodall_number == n:\n            return True\n        elif woodall_number > n:\n            return False\n        i += 1\n\n# Test the function\nprint(is_woodall(7))  # True, because 7 = 2 * 2^2 - 1\nprint(is_woodall(23)) # True, because 23 = 3 * 2^3 - 1\nprint(is_woodall(10)) # False, 10 is not a Woodall number\n\n\n",
        "base_tests": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "tests": [
            "assert is_woodall(10) == [1, 7]",
            "assert is_woodall(15) == [1, 7, 15]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'x': int, and the return type should be annotated as bool.",
        "code_before": "def is_woodall(n):\n    \"\"\"\n    Check if the given number is a Woodall number.\n    \n    A Woodall number is defined as a number of the form n * 2^n - 1, where n is a positive integer.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is a Woodall number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    \n    # Start with n = 1 and check if we can find a Woodall number equal to the given number\n    i = 1\n    while True:\n        woodall_number = i * (2 ** i) - 1\n        if woodall_number == n:\n            return True\n        elif woodall_number > n:\n            return False\n        i += 1\n\n# Test the function\nprint(is_woodall(7))  # True, because 7 = 2 * 2^2 - 1\nprint(is_woodall(23)) # True, because 23 = 3 * 2^3 - 1\nprint(is_woodall(10)) # False, 10 is not a Woodall number\n\n\n",
        "base_tests": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "tests": [
            "assert is_woodall.__annotations__ == {'x': int, 'return': bool}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple, linear function.",
        "code_before": "def is_woodall(n):\n    \"\"\"\n    Check if the given number is a Woodall number.\n    \n    A Woodall number is defined as a number of the form n * 2^n - 1, where n is a positive integer.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is a Woodall number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    \n    # Start with n = 1 and check if we can find a Woodall number equal to the given number\n    i = 1\n    while True:\n        woodall_number = i * (2 ** i) - 1\n        if woodall_number == n:\n            return True\n        elif woodall_number > n:\n            return False\n        i += 1\n\n# Test the function\nprint(is_woodall(7))  # True, because 7 = 2 * 2^2 - 1\nprint(is_woodall(23)) # True, because 23 = 3 * 2^3 - 1\nprint(is_woodall(10)) # False, 10 is not a Woodall number\n\n\n",
        "base_tests": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(is_woodall))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def is_woodall(n):\n    \"\"\"\n    Check if the given number is a Woodall number.\n    \n    A Woodall number is defined as a number of the form n * 2^n - 1, where n is a positive integer.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is a Woodall number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    \n    # Start with n = 1 and check if we can find a Woodall number equal to the given number\n    i = 1\n    while True:\n        woodall_number = i * (2 ** i) - 1\n        if woodall_number == n:\n            return True\n        elif woodall_number > n:\n            return False\n        i += 1\n\n# Test the function\nprint(is_woodall(7))  # True, because 7 = 2 * 2^2 - 1\nprint(is_woodall(23)) # True, because 23 = 3 * 2^3 - 1\nprint(is_woodall(10)) # False, 10 is not a Woodall number\n\n\n",
        "base_tests": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(is_woodall)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function named 'multiples_of_num' to find m number of multiples of n.",
        "instruction": "The function should raise a ValueError if either m or n is negative.",
        "code_before": "def multiples_of_num(n, m):\n    \"\"\"\n    This function returns a list of m multiples of n.\n    \n    Parameters:\n    n (int): The number to find multiples of.\n    m (int): The number of multiples to find.\n    \n    Returns:\n    list: A list containing the first m multiples of n.\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n\n# Example usage:\nprint(multiples_of_num(3, 5))  # Output: [3, 6, 9, 12, 15]\n\n\n",
        "base_tests": [
            "assert multiples_of_num(4,3)== [3,6,9,12]",
            "assert multiples_of_num(2,5)== [5,10]",
            "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"
        ],
        "tests": [
            "try: multiples_of_num(-1, 5)\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError'",
            "try: multiples_of_num(3, -2)\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function named 'multiples_of_num' to find m number of multiples of n.",
        "instruction": "The function should handle the edge case where m is zero, returning an empty list.",
        "code_before": "def multiples_of_num(n, m):\n    \"\"\"\n    This function returns a list of m multiples of n.\n    \n    Parameters:\n    n (int): The number to find multiples of.\n    m (int): The number of multiples to find.\n    \n    Returns:\n    list: A list containing the first m multiples of n.\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n\n# Example usage:\nprint(multiples_of_num(3, 5))  # Output: [3, 6, 9, 12, 15]\n\n\n",
        "base_tests": [
            "assert multiples_of_num(4,3)== [3,6,9,12]",
            "assert multiples_of_num(2,5)== [5,10]",
            "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"
        ],
        "tests": [
            "assert multiples_of_num(0, 5) == []",
            "assert multiples_of_num(0, 0) == []"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function named 'multiples_of_num' to find m number of multiples of n.",
        "instruction": "Extend the function to handle cases where n is a floating-point number, returning multiples as floating-point numbers.",
        "code_before": "def multiples_of_num(n, m):\n    \"\"\"\n    This function returns a list of m multiples of n.\n    \n    Parameters:\n    n (int): The number to find multiples of.\n    m (int): The number of multiples to find.\n    \n    Returns:\n    list: A list containing the first m multiples of n.\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n\n# Example usage:\nprint(multiples_of_num(3, 5))  # Output: [3, 6, 9, 12, 15]\n\n\n",
        "base_tests": [
            "assert multiples_of_num(4,3)== [3,6,9,12]",
            "assert multiples_of_num(2,5)== [5,10]",
            "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"
        ],
        "tests": [
            "assert multiples_of_num(3, 2.5) == [2.5, 5.0, 7.5]",
            "assert multiples_of_num(4, 1.1) == [1.1, 2.2, 3.3, 4.4]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function named 'multiples_of_num' to find m number of multiples of n.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'm': int, 'n': int, and the return type should be annotated as list.",
        "code_before": "def multiples_of_num(n, m):\n    \"\"\"\n    This function returns a list of m multiples of n.\n    \n    Parameters:\n    n (int): The number to find multiples of.\n    m (int): The number of multiples to find.\n    \n    Returns:\n    list: A list containing the first m multiples of n.\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n\n# Example usage:\nprint(multiples_of_num(3, 5))  # Output: [3, 6, 9, 12, 15]\n\n\n",
        "base_tests": [
            "assert multiples_of_num(4,3)== [3,6,9,12]",
            "assert multiples_of_num(2,5)== [5,10]",
            "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"
        ],
        "tests": [
            "assert multiples_of_num.__annotations__ == {'m': int, 'n': int, 'return': list}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function named 'multiples_of_num' to find m number of multiples of n.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a single path through the function.",
        "code_before": "def multiples_of_num(n, m):\n    \"\"\"\n    This function returns a list of m multiples of n.\n    \n    Parameters:\n    n (int): The number to find multiples of.\n    m (int): The number of multiples to find.\n    \n    Returns:\n    list: A list containing the first m multiples of n.\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n\n# Example usage:\nprint(multiples_of_num(3, 5))  # Output: [3, 6, 9, 12, 15]\n\n\n",
        "base_tests": [
            "assert multiples_of_num(4,3)== [3,6,9,12]",
            "assert multiples_of_num(2,5)== [5,10]",
            "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(multiples_of_num))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function named 'multiples_of_num' to find m number of multiples of n.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def multiples_of_num(n, m):\n    \"\"\"\n    This function returns a list of m multiples of n.\n    \n    Parameters:\n    n (int): The number to find multiples of.\n    m (int): The number of multiples to find.\n    \n    Returns:\n    list: A list containing the first m multiples of n.\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n\n# Example usage:\nprint(multiples_of_num(3, 5))  # Output: [3, 6, 9, 12, 15]\n\n\n",
        "base_tests": [
            "assert multiples_of_num(4,3)== [3,6,9,12]",
            "assert multiples_of_num(2,5)== [5,10]",
            "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(multiples_of_num)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function 'find_first_duplicate' to find the first duplicate element in a given array of integers.",
        "instruction": "The function should raise a TypeError if the input is not a list of integers.",
        "code_before": "def find_first_duplicate(arr):\n    \"\"\"\n    This function takes an array of integers and returns the first duplicate element.\n    If there are no duplicates, it returns None.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n\n# Example usage:\narr = [2, 5, 1, 2, 3, 5, 1, 2, 4]\nprint(find_first_duplicate(arr))  # Output: 2\n\n\n",
        "base_tests": [
            "assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4",
            "assert find_first_duplicate([1, 2, 3, 4])==-1",
            "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"
        ],
        "tests": [
            "try: find_first_duplicate('not a list')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function 'find_first_duplicate' to find the first duplicate element in a given array of integers.",
        "instruction": "The function should handle an empty list by returning -1.",
        "code_before": "def find_first_duplicate(arr):\n    \"\"\"\n    This function takes an array of integers and returns the first duplicate element.\n    If there are no duplicates, it returns None.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n\n# Example usage:\narr = [2, 5, 1, 2, 3, 5, 1, 2, 4]\nprint(find_first_duplicate(arr))  # Output: 2\n\n\n",
        "base_tests": [
            "assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4",
            "assert find_first_duplicate([1, 2, 3, 4])==-1",
            "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"
        ],
        "tests": [
            "assert find_first_duplicate([]) == -1"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function 'find_first_duplicate' to find the first duplicate element in a given array of integers.",
        "instruction": "Extend the function to return a list of all duplicate elements in the order they first appear, or an empty list if there are no duplicates.",
        "code_before": "def find_first_duplicate(arr):\n    \"\"\"\n    This function takes an array of integers and returns the first duplicate element.\n    If there are no duplicates, it returns None.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n\n# Example usage:\narr = [2, 5, 1, 2, 3, 5, 1, 2, 4]\nprint(find_first_duplicate(arr))  # Output: 2\n\n\n",
        "base_tests": [
            "assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4",
            "assert find_first_duplicate([1, 2, 3, 4])==-1",
            "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"
        ],
        "tests": [
            "assert find_first_duplicate([1, 2, 3, 2, 4, 5, 4]) == [2, 4]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function 'find_first_duplicate' to find the first duplicate element in a given array of integers.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'nums': list, and the return type should be annotated as int.",
        "code_before": "def find_first_duplicate(arr):\n    \"\"\"\n    This function takes an array of integers and returns the first duplicate element.\n    If there are no duplicates, it returns None.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n\n# Example usage:\narr = [2, 5, 1, 2, 3, 5, 1, 2, 4]\nprint(find_first_duplicate(arr))  # Output: 2\n\n\n",
        "base_tests": [
            "assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4",
            "assert find_first_duplicate([1, 2, 3, 4])==-1",
            "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"
        ],
        "tests": [
            "assert find_first_duplicate.__annotations__ == {'nums': list, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function 'find_first_duplicate' to find the first duplicate element in a given array of integers.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper indentation and spacing.",
        "code_before": "def find_first_duplicate(arr):\n    \"\"\"\n    This function takes an array of integers and returns the first duplicate element.\n    If there are no duplicates, it returns None.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n\n# Example usage:\narr = [2, 5, 1, 2, 3, 5, 1, 2, 4]\nprint(find_first_duplicate(arr))  # Output: 2\n\n\n",
        "base_tests": [
            "assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4",
            "assert find_first_duplicate([1, 2, 3, 4])==-1",
            "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_first_duplicate)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function named 'maximum_sum' to find the maximum sum of elements of list in a list of lists.",
        "instruction": "The function should accept a list of lists containing integers and return an integer representing the maximum sum of elements from any sublist.",
        "code_before": "def maximum_sum(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns the maximum sum of elements of any list within it.\n    \n    :param list_of_lists: List of lists containing integers\n    :return: Integer representing the maximum sum of elements of any list within the input list of lists\n    \"\"\"\n    # Initialize the maximum sum to a very small number\n    max_sum = float('-inf')\n    \n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update the maximum sum if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\n",
        "base_tests": [
            "assert maximum_sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
            "assert maximum_sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
            "assert maximum_sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"
        ],
        "tests": [
            "assert isinstance(maximum_sum([[1, 2], [3, 4]]), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function named 'maximum_sum' to find the maximum sum of elements of list in a list of lists.",
        "instruction": "The function should raise a TypeError if the input is not a list of lists or if any sublist contains non-integer elements.",
        "code_before": "def maximum_sum(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns the maximum sum of elements of any list within it.\n    \n    :param list_of_lists: List of lists containing integers\n    :return: Integer representing the maximum sum of elements of any list within the input list of lists\n    \"\"\"\n    # Initialize the maximum sum to a very small number\n    max_sum = float('-inf')\n    \n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update the maximum sum if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\n",
        "base_tests": [
            "assert maximum_sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
            "assert maximum_sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
            "assert maximum_sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"
        ],
        "tests": [
            "try:\n    maximum_sum([[1, 2], [3, 'a']])\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass",
            "try:\n    maximum_sum(123)\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function named 'maximum_sum' to find the maximum sum of elements of list in a list of lists.",
        "instruction": "The function should return 0 if the input list is empty or if all sublists are empty.",
        "code_before": "def maximum_sum(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns the maximum sum of elements of any list within it.\n    \n    :param list_of_lists: List of lists containing integers\n    :return: Integer representing the maximum sum of elements of any list within the input list of lists\n    \"\"\"\n    # Initialize the maximum sum to a very small number\n    max_sum = float('-inf')\n    \n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update the maximum sum if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\n",
        "base_tests": [
            "assert maximum_sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
            "assert maximum_sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
            "assert maximum_sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"
        ],
        "tests": [
            "assert maximum_sum([]) == 0\nassert maximum_sum([[], [], []]) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function named 'maximum_sum' to find the maximum sum of elements of list in a list of lists.",
        "instruction": "Extend the function to handle negative integers and ensure it returns the maximum sum correctly.",
        "code_before": "def maximum_sum(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns the maximum sum of elements of any list within it.\n    \n    :param list_of_lists: List of lists containing integers\n    :return: Integer representing the maximum sum of elements of any list within the input list of lists\n    \"\"\"\n    # Initialize the maximum sum to a very small number\n    max_sum = float('-inf')\n    \n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update the maximum sum if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\n",
        "base_tests": [
            "assert maximum_sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
            "assert maximum_sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
            "assert maximum_sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"
        ],
        "tests": [
            "assert maximum_sum([[-1, -2, -3], [-4, -5, -6], [-10, -11, -12], [-7, -8, -9]]) == -6"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function named 'maximum_sum' to find the maximum sum of elements of list in a list of lists.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'list1': list[list[int]], and the return type should be annotated as int.",
        "code_before": "def maximum_sum(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns the maximum sum of elements of any list within it.\n    \n    :param list_of_lists: List of lists containing integers\n    :return: Integer representing the maximum sum of elements of any list within the input list of lists\n    \"\"\"\n    # Initialize the maximum sum to a very small number\n    max_sum = float('-inf')\n    \n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update the maximum sum if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\n",
        "base_tests": [
            "assert maximum_sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
            "assert maximum_sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
            "assert maximum_sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"
        ],
        "tests": [
            "assert maximum_sum.__annotations__ == {'list1': 'list[list[int]]', 'return': 'int'}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function named 'maximum_sum' to find the maximum sum of elements of list in a list of lists.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def maximum_sum(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns the maximum sum of elements of any list within it.\n    \n    :param list_of_lists: List of lists containing integers\n    :return: Integer representing the maximum sum of elements of any list within the input list of lists\n    \"\"\"\n    # Initialize the maximum sum to a very small number\n    max_sum = float('-inf')\n    \n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update the maximum sum if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    return max_sum\n\n\n",
        "base_tests": [
            "assert maximum_sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33",
            "assert maximum_sum([[0,1,1],[1,1,2],[3,2,1]]) == 6",
            "assert maximum_sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(maximum_sum)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'binary_to_decimal' to convert the given binary number to its decimal equivalent.",
        "instruction": "The function should raise a ValueError with a descriptive error message as 'Invalid binary number' if the input is not a valid binary string.",
        "code_before": "def binary_to_decimal(binary_str):\n    \"\"\"\n    Convert a binary number (given as a string) to its decimal equivalent.\n\n    Parameters:\n    binary_str (str): A string representing a binary number.\n\n    Returns:\n    int: The decimal equivalent of the binary number.\n    \"\"\"\n    decimal_value = 0\n    binary_str = binary_str[::-1]  # Reverse the string to process from least significant bit to most significant bit\n\n    for index, digit in enumerate(binary_str):\n        if digit == '1':\n            decimal_value += 2 ** index\n\n    return decimal_value\n\n# Example usage:\nbinary_number = \"1101\"\ndecimal_number = binary_to_decimal(binary_number)\nprint(f\"The decimal equivalent of binary {binary_number} is {decimal_number}.\")\n\n\n",
        "base_tests": [
            "assert binary_to_decimal(100) == 4",
            "assert binary_to_decimal(1011) == 11",
            "assert binary_to_decimal(1101101) == 109"
        ],
        "tests": [
            "try:\n    binary_to_decimal('102')\n    assert False, 'Expected ValueError'\nexcept ValueError as e:\n    assert str(e) == 'Invalid binary number'",
            "try:\n    binary_to_decimal('abc')\n    assert False, 'Expected ValueError'\nexcept ValueError as e:\n    assert str(e) == 'Invalid binary number'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'binary_to_decimal' to convert the given binary number to its decimal equivalent.",
        "instruction": "The function should correctly handle the edge case of an empty string by returning 0.",
        "code_before": "def binary_to_decimal(binary_str):\n    \"\"\"\n    Convert a binary number (given as a string) to its decimal equivalent.\n\n    Parameters:\n    binary_str (str): A string representing a binary number.\n\n    Returns:\n    int: The decimal equivalent of the binary number.\n    \"\"\"\n    decimal_value = 0\n    binary_str = binary_str[::-1]  # Reverse the string to process from least significant bit to most significant bit\n\n    for index, digit in enumerate(binary_str):\n        if digit == '1':\n            decimal_value += 2 ** index\n\n    return decimal_value\n\n# Example usage:\nbinary_number = \"1101\"\ndecimal_number = binary_to_decimal(binary_number)\nprint(f\"The decimal equivalent of binary {binary_number} is {decimal_number}.\")\n\n\n",
        "base_tests": [
            "assert binary_to_decimal(100) == 4",
            "assert binary_to_decimal(1011) == 11",
            "assert binary_to_decimal(1101101) == 109"
        ],
        "tests": [
            "assert binary_to_decimal('') == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'binary_to_decimal' to convert the given binary number to its decimal equivalent.",
        "instruction": "Extend the function to handle binary numbers with leading zeros correctly.",
        "code_before": "def binary_to_decimal(binary_str):\n    \"\"\"\n    Convert a binary number (given as a string) to its decimal equivalent.\n\n    Parameters:\n    binary_str (str): A string representing a binary number.\n\n    Returns:\n    int: The decimal equivalent of the binary number.\n    \"\"\"\n    decimal_value = 0\n    binary_str = binary_str[::-1]  # Reverse the string to process from least significant bit to most significant bit\n\n    for index, digit in enumerate(binary_str):\n        if digit == '1':\n            decimal_value += 2 ** index\n\n    return decimal_value\n\n# Example usage:\nbinary_number = \"1101\"\ndecimal_number = binary_to_decimal(binary_number)\nprint(f\"The decimal equivalent of binary {binary_number} is {decimal_number}.\")\n\n\n",
        "base_tests": [
            "assert binary_to_decimal(100) == 4",
            "assert binary_to_decimal(1011) == 11",
            "assert binary_to_decimal(1101101) == 109"
        ],
        "tests": [
            "assert binary_to_decimal('000100') == 4",
            "assert binary_to_decimal('0000') == 0"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'binary_to_decimal' to convert the given binary number to its decimal equivalent.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'binary': str, and the return type should be annotated as int.",
        "code_before": "def binary_to_decimal(binary_str):\n    \"\"\"\n    Convert a binary number (given as a string) to its decimal equivalent.\n\n    Parameters:\n    binary_str (str): A string representing a binary number.\n\n    Returns:\n    int: The decimal equivalent of the binary number.\n    \"\"\"\n    decimal_value = 0\n    binary_str = binary_str[::-1]  # Reverse the string to process from least significant bit to most significant bit\n\n    for index, digit in enumerate(binary_str):\n        if digit == '1':\n            decimal_value += 2 ** index\n\n    return decimal_value\n\n# Example usage:\nbinary_number = \"1101\"\ndecimal_number = binary_to_decimal(binary_number)\nprint(f\"The decimal equivalent of binary {binary_number} is {decimal_number}.\")\n\n\n",
        "base_tests": [
            "assert binary_to_decimal(100) == 4",
            "assert binary_to_decimal(1011) == 11",
            "assert binary_to_decimal(1101101) == 109"
        ],
        "tests": [
            "assert 'def binary_to_decimal(binary: str) -> int' in inspect.getsource(binary_to_decimal)"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'binary_to_decimal' to convert the given binary number to its decimal equivalent.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a single path through the code.",
        "code_before": "def binary_to_decimal(binary_str):\n    \"\"\"\n    Convert a binary number (given as a string) to its decimal equivalent.\n\n    Parameters:\n    binary_str (str): A string representing a binary number.\n\n    Returns:\n    int: The decimal equivalent of the binary number.\n    \"\"\"\n    decimal_value = 0\n    binary_str = binary_str[::-1]  # Reverse the string to process from least significant bit to most significant bit\n\n    for index, digit in enumerate(binary_str):\n        if digit == '1':\n            decimal_value += 2 ** index\n\n    return decimal_value\n\n# Example usage:\nbinary_number = \"1101\"\ndecimal_number = binary_to_decimal(binary_number)\nprint(f\"The decimal equivalent of binary {binary_number} is {decimal_number}.\")\n\n\n",
        "base_tests": [
            "assert binary_to_decimal(100) == 4",
            "assert binary_to_decimal(1011) == 11",
            "assert binary_to_decimal(1101101) == 109"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(binary_to_decimal))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'binary_to_decimal' to convert the given binary number to its decimal equivalent.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def binary_to_decimal(binary_str):\n    \"\"\"\n    Convert a binary number (given as a string) to its decimal equivalent.\n\n    Parameters:\n    binary_str (str): A string representing a binary number.\n\n    Returns:\n    int: The decimal equivalent of the binary number.\n    \"\"\"\n    decimal_value = 0\n    binary_str = binary_str[::-1]  # Reverse the string to process from least significant bit to most significant bit\n\n    for index, digit in enumerate(binary_str):\n        if digit == '1':\n            decimal_value += 2 ** index\n\n    return decimal_value\n\n# Example usage:\nbinary_number = \"1101\"\ndecimal_number = binary_to_decimal(binary_number)\nprint(f\"The decimal equivalent of binary {binary_number} is {decimal_number}.\")\n\n\n",
        "base_tests": [
            "assert binary_to_decimal(100) == 4",
            "assert binary_to_decimal(1011) == 11",
            "assert binary_to_decimal(1101101) == 109"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(binary_to_decimal)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'find_product' to find the product of non-repeated elements in a given array.",
        "instruction": "The function should accept a list of integers as input and return an integer as output, representing the product of non-repeated elements.",
        "code_before": "def find_product(arr):\n    # Create a dictionary to count occurrences of each element\n    element_count = {}\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    # Calculate the product of non-repeated elements\n    product = 1\n    for num, count in element_count.items():\n        if count == 1:\n            product *= num\n    \n    return product\n\n# Example usage:\narr = [2, 3, 5, 3, 7, 2, 8]\nprint(find_product(arr))  # Output: 280 (5 * 7 * 8)\n\n\n",
        "base_tests": [
            "assert find_product([1,1,2,3],4) == 6",
            "assert find_product([1,2,3,1,1],5) == 6",
            "assert find_product([1,1,4,5,6],5) == 120"
        ],
        "tests": [
            "assert isinstance(find_product([1, 2, 3], 3), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'find_product' to find the product of non-repeated elements in a given array.",
        "instruction": "The function should raise a TypeError if the input is not a list of integers.",
        "code_before": "def find_product(arr):\n    # Create a dictionary to count occurrences of each element\n    element_count = {}\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    # Calculate the product of non-repeated elements\n    product = 1\n    for num, count in element_count.items():\n        if count == 1:\n            product *= num\n    \n    return product\n\n# Example usage:\narr = [2, 3, 5, 3, 7, 2, 8]\nprint(find_product(arr))  # Output: 280 (5 * 7 * 8)\n\n\n",
        "base_tests": [
            "assert find_product([1,1,2,3],4) == 6",
            "assert find_product([1,2,3,1,1],5) == 6",
            "assert find_product([1,1,4,5,6],5) == 120"
        ],
        "tests": [
            "try: find_product('not a list', 3)\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'find_product' to find the product of non-repeated elements in a given array.",
        "instruction": "The function should return 1 if the input list is empty, as there are no elements to multiply.",
        "code_before": "def find_product(arr):\n    # Create a dictionary to count occurrences of each element\n    element_count = {}\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    # Calculate the product of non-repeated elements\n    product = 1\n    for num, count in element_count.items():\n        if count == 1:\n            product *= num\n    \n    return product\n\n# Example usage:\narr = [2, 3, 5, 3, 7, 2, 8]\nprint(find_product(arr))  # Output: 280 (5 * 7 * 8)\n\n\n",
        "base_tests": [
            "assert find_product([1,1,2,3],4) == 6",
            "assert find_product([1,2,3,1,1],5) == 6",
            "assert find_product([1,1,4,5,6],5) == 120"
        ],
        "tests": [
            "assert find_product([], 0) == 1"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'find_product' to find the product of non-repeated elements in a given array.",
        "instruction": "Extend the function to handle negative numbers correctly, ensuring the product is calculated accurately.",
        "code_before": "def find_product(arr):\n    # Create a dictionary to count occurrences of each element\n    element_count = {}\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    # Calculate the product of non-repeated elements\n    product = 1\n    for num, count in element_count.items():\n        if count == 1:\n            product *= num\n    \n    return product\n\n# Example usage:\narr = [2, 3, 5, 3, 7, 2, 8]\nprint(find_product(arr))  # Output: 280 (5 * 7 * 8)\n\n\n",
        "base_tests": [
            "assert find_product([1,1,2,3],4) == 6",
            "assert find_product([1,2,3,1,1],5) == 6",
            "assert find_product([1,1,4,5,6],5) == 120"
        ],
        "tests": [
            "assert find_product([-1, -2, 3, 3], 4) == 2"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'find_product' to find the product of non-repeated elements in a given array.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'arr': list, 'n': int, and the return type should be annotated as int.",
        "code_before": "def find_product(arr):\n    # Create a dictionary to count occurrences of each element\n    element_count = {}\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    # Calculate the product of non-repeated elements\n    product = 1\n    for num, count in element_count.items():\n        if count == 1:\n            product *= num\n    \n    return product\n\n# Example usage:\narr = [2, 3, 5, 3, 7, 2, 8]\nprint(find_product(arr))  # Output: 280 (5 * 7 * 8)\n\n\n",
        "base_tests": [
            "assert find_product([1,1,2,3],4) == 6",
            "assert find_product([1,2,3,1,1],5) == 6",
            "assert find_product([1,1,4,5,6],5) == 120"
        ],
        "tests": [
            "assert find_product.__annotations__ == {'arr': list, 'n': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'find_product' to find the product of non-repeated elements in a given array.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def find_product(arr):\n    # Create a dictionary to count occurrences of each element\n    element_count = {}\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    # Calculate the product of non-repeated elements\n    product = 1\n    for num, count in element_count.items():\n        if count == 1:\n            product *= num\n    \n    return product\n\n# Example usage:\narr = [2, 3, 5, 3, 7, 2, 8]\nprint(find_product(arr))  # Output: 280 (5 * 7 * 8)\n\n\n",
        "base_tests": [
            "assert find_product([1,1,2,3],4) == 6",
            "assert find_product([1,2,3,1,1],5) == 6",
            "assert find_product([1,1,4,5,6],5) == 120"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_product)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function 'check_k_elements' to check if the given tuple list has all k elements.",
        "instruction": "The function should return a boolean value indicating whether all tuples in the list contain exactly k elements.",
        "code_before": "def check_k_elements(tuple_list, k):\n    \"\"\"\n    Check if the given tuple list has all k elements.\n\n    Args:\n    tuple_list (list of tuples): The list of tuples to check.\n    k (int): The number of unique elements to check for.\n\n    Returns:\n    bool: True if the tuple list has all k unique elements, False otherwise.\n    \"\"\"\n    # Create a set to store unique elements\n    unique_elements = set()\n\n    # Iterate over each tuple in the list\n    for tup in tuple_list:\n        # Add each element of the tuple to the set\n        unique_elements.update(tup)\n\n    # Check if the number of unique elements is equal to k\n    return len(unique_elements) == k\n\n\n",
        "base_tests": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
            "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
            "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"
        ],
        "tests": [
            "assert isinstance(check_k_elements([(1, 2), (3, 4)], 2), bool)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function 'check_k_elements' to check if the given tuple list has all k elements.",
        "instruction": "The function should raise a TypeError if the input is not a list of tuples or if k is not an integer.",
        "code_before": "def check_k_elements(tuple_list, k):\n    \"\"\"\n    Check if the given tuple list has all k elements.\n\n    Args:\n    tuple_list (list of tuples): The list of tuples to check.\n    k (int): The number of unique elements to check for.\n\n    Returns:\n    bool: True if the tuple list has all k unique elements, False otherwise.\n    \"\"\"\n    # Create a set to store unique elements\n    unique_elements = set()\n\n    # Iterate over each tuple in the list\n    for tup in tuple_list:\n        # Add each element of the tuple to the set\n        unique_elements.update(tup)\n\n    # Check if the number of unique elements is equal to k\n    return len(unique_elements) == k\n\n\n",
        "base_tests": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
            "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
            "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"
        ],
        "tests": [
            "try:\n    check_k_elements('not a tuple list', 2)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    check_k_elements([(1, 2), (3, 4)], 'not an integer')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function 'check_k_elements' to check if the given tuple list has all k elements.",
        "instruction": "The function should handle edge cases such as an empty list or tuples with zero elements.",
        "code_before": "def check_k_elements(tuple_list, k):\n    \"\"\"\n    Check if the given tuple list has all k elements.\n\n    Args:\n    tuple_list (list of tuples): The list of tuples to check.\n    k (int): The number of unique elements to check for.\n\n    Returns:\n    bool: True if the tuple list has all k unique elements, False otherwise.\n    \"\"\"\n    # Create a set to store unique elements\n    unique_elements = set()\n\n    # Iterate over each tuple in the list\n    for tup in tuple_list:\n        # Add each element of the tuple to the set\n        unique_elements.update(tup)\n\n    # Check if the number of unique elements is equal to k\n    return len(unique_elements) == k\n\n\n",
        "base_tests": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
            "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
            "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"
        ],
        "tests": [
            "assert check_k_elements([], 0) == True\nassert check_k_elements([()], 0) == True"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function 'check_k_elements' to check if the given tuple list has all k elements.",
        "instruction": "Extend the function to return the count of tuples that have exactly k elements.",
        "code_before": "def check_k_elements(tuple_list, k):\n    \"\"\"\n    Check if the given tuple list has all k elements.\n\n    Args:\n    tuple_list (list of tuples): The list of tuples to check.\n    k (int): The number of unique elements to check for.\n\n    Returns:\n    bool: True if the tuple list has all k unique elements, False otherwise.\n    \"\"\"\n    # Create a set to store unique elements\n    unique_elements = set()\n\n    # Iterate over each tuple in the list\n    for tup in tuple_list:\n        # Add each element of the tuple to the set\n        unique_elements.update(tup)\n\n    # Check if the number of unique elements is equal to k\n    return len(unique_elements) == k\n\n\n",
        "base_tests": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
            "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
            "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"
        ],
        "tests": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == 1"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function 'check_k_elements' to check if the given tuple list has all k elements.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'test_list': list[tuple], 'K': int, and the return type should be annotated as bool.",
        "code_before": "def check_k_elements(tuple_list, k):\n    \"\"\"\n    Check if the given tuple list has all k elements.\n\n    Args:\n    tuple_list (list of tuples): The list of tuples to check.\n    k (int): The number of unique elements to check for.\n\n    Returns:\n    bool: True if the tuple list has all k unique elements, False otherwise.\n    \"\"\"\n    # Create a set to store unique elements\n    unique_elements = set()\n\n    # Iterate over each tuple in the list\n    for tup in tuple_list:\n        # Add each element of the tuple to the set\n        unique_elements.update(tup)\n\n    # Check if the number of unique elements is equal to k\n    return len(unique_elements) == k\n\n\n",
        "base_tests": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
            "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
            "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"
        ],
        "tests": [
            "assert check_k_elements.__annotations__ == {'test_list': list[tuple], 'K': int, 'return': bool}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function 'check_k_elements' to check if the given tuple list has all k elements.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def check_k_elements(tuple_list, k):\n    \"\"\"\n    Check if the given tuple list has all k elements.\n\n    Args:\n    tuple_list (list of tuples): The list of tuples to check.\n    k (int): The number of unique elements to check for.\n\n    Returns:\n    bool: True if the tuple list has all k unique elements, False otherwise.\n    \"\"\"\n    # Create a set to store unique elements\n    unique_elements = set()\n\n    # Iterate over each tuple in the list\n    for tup in tuple_list:\n        # Add each element of the tuple to the set\n        unique_elements.update(tup)\n\n    # Check if the number of unique elements is equal to k\n    return len(unique_elements) == k\n\n\n",
        "base_tests": [
            "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True",
            "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True",
            "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(check_k_elements)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function named 'remove' to remove all digits from a list of strings.",
        "instruction": "The function should raise a TypeError if the input is not a list or if any element in the list is not a string.",
        "code_before": "def remove(strings):\n    \"\"\"\n    This function takes a list of strings and returns a new list where all the digits have been removed from each string.\n    \n    :param strings: List of strings\n    :return: List of strings with all digits removed\n    \"\"\"\n    return [''.join(char for char in string if not char.isdigit()) for string in strings]\n\n# Example usage:\ninput_list = [\"abc123\", \"def456ghi\", \"789jkl0\"]\noutput_list = remove(input_list)\nprint(output_list)  # Output: ['abc', 'defghi', 'jkl']\n\n\n",
        "base_tests": [
            "assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']",
            "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']",
            "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"
        ],
        "tests": [
            "try:\n    remove('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    remove([123, 'valid', 456])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function named 'remove' to remove all digits from a list of strings.",
        "instruction": "The function should handle edge cases such as an empty list or strings with no digits gracefully.",
        "code_before": "def remove(strings):\n    \"\"\"\n    This function takes a list of strings and returns a new list where all the digits have been removed from each string.\n    \n    :param strings: List of strings\n    :return: List of strings with all digits removed\n    \"\"\"\n    return [''.join(char for char in string if not char.isdigit()) for string in strings]\n\n# Example usage:\ninput_list = [\"abc123\", \"def456ghi\", \"789jkl0\"]\noutput_list = remove(input_list)\nprint(output_list)  # Output: ['abc', 'defghi', 'jkl']\n\n\n",
        "base_tests": [
            "assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']",
            "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']",
            "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"
        ],
        "tests": [
            "assert remove([]) == []\nassert remove(['no digits here']) == ['no digits here']"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function named 'remove' to remove all digits from a list of strings.",
        "instruction": "Extend the function to include an additional parameter specifying other characters to be removed, in addition to digits.",
        "code_before": "def remove(strings):\n    \"\"\"\n    This function takes a list of strings and returns a new list where all the digits have been removed from each string.\n    \n    :param strings: List of strings\n    :return: List of strings with all digits removed\n    \"\"\"\n    return [''.join(char for char in string if not char.isdigit()) for string in strings]\n\n# Example usage:\ninput_list = [\"abc123\", \"def456ghi\", \"789jkl0\"]\noutput_list = remove(input_list)\nprint(output_list)  # Output: ['abc', 'defghi', 'jkl']\n\n\n",
        "base_tests": [
            "assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']",
            "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']",
            "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"
        ],
        "tests": [
            "assert remove_extended(['abcd123', '456defg'], 'abcdef') == ['d', 'g']"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function named 'remove' to remove all digits from a list of strings.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'list': list[str], and the return type should be annotated as list[str].",
        "code_before": "def remove(strings):\n    \"\"\"\n    This function takes a list of strings and returns a new list where all the digits have been removed from each string.\n    \n    :param strings: List of strings\n    :return: List of strings with all digits removed\n    \"\"\"\n    return [''.join(char for char in string if not char.isdigit()) for string in strings]\n\n# Example usage:\ninput_list = [\"abc123\", \"def456ghi\", \"789jkl0\"]\noutput_list = remove(input_list)\nprint(output_list)  # Output: ['abc', 'defghi', 'jkl']\n\n\n",
        "base_tests": [
            "assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']",
            "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']",
            "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"
        ],
        "tests": [
            "assert remove.__annotations__ == {'list': list[str], 'return': list[str]}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function named 'remove' to remove all digits from a list of strings.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def remove(strings):\n    \"\"\"\n    This function takes a list of strings and returns a new list where all the digits have been removed from each string.\n    \n    :param strings: List of strings\n    :return: List of strings with all digits removed\n    \"\"\"\n    return [''.join(char for char in string if not char.isdigit()) for string in strings]\n\n# Example usage:\ninput_list = [\"abc123\", \"def456ghi\", \"789jkl0\"]\noutput_list = remove(input_list)\nprint(output_list)  # Output: ['abc', 'defghi', 'jkl']\n\n\n",
        "base_tests": [
            "assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']",
            "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']",
            "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(remove)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'binomial_coeff' to find binomial co-efficient.",
        "instruction": "The function should accept two non-negative integer inputs n and k, and return an integer output representing the binomial coefficient.",
        "code_before": "def binomial_coeff(n, k):\n    \"\"\"\n    Calculate the binomial coefficient, also known as \"n choose k\", which is the number of ways to choose k elements from a set of n elements.\n    \n    Args:\n    n (int): The total number of elements.\n    k (int): The number of elements to choose.\n    \n    Returns:\n    int: The binomial coefficient.\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    # Initialize a list to store binomial coefficients\n    C = [0] * (k + 1)\n    C[0] = 1  # nC0 is 1\n    \n    # Calculate value of Binomial Coefficient in bottom-up manner\n    for i in range(1, n + 1):\n        # Compute next row of pascal triangle using the previous row\n        for j in range(min(i, k), 0, -1):\n            C[j] = C[j] + C[j - 1]\n    \n    return C[k]\n\n# Example usage:\nprint(binomial_coeff(5, 2))  # Output: 10\n\n\n",
        "base_tests": [
            "assert binomial_coeff(5,2) == 10",
            "assert binomial_coeff(4,3) == 4",
            "assert binomial_coeff(3,2) == 3"
        ],
        "tests": [
            "assert isinstance(binomial_coeff(5, 2), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'binomial_coeff' to find binomial co-efficient.",
        "instruction": "The function should raise a ValueError with a descriptive message as 'Inputs must be non-negative and k must not be greater than n' if either input is negative or if k is greater than n.",
        "code_before": "def binomial_coeff(n, k):\n    \"\"\"\n    Calculate the binomial coefficient, also known as \"n choose k\", which is the number of ways to choose k elements from a set of n elements.\n    \n    Args:\n    n (int): The total number of elements.\n    k (int): The number of elements to choose.\n    \n    Returns:\n    int: The binomial coefficient.\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    # Initialize a list to store binomial coefficients\n    C = [0] * (k + 1)\n    C[0] = 1  # nC0 is 1\n    \n    # Calculate value of Binomial Coefficient in bottom-up manner\n    for i in range(1, n + 1):\n        # Compute next row of pascal triangle using the previous row\n        for j in range(min(i, k), 0, -1):\n            C[j] = C[j] + C[j - 1]\n    \n    return C[k]\n\n# Example usage:\nprint(binomial_coeff(5, 2))  # Output: 10\n\n\n",
        "base_tests": [
            "assert binomial_coeff(5,2) == 10",
            "assert binomial_coeff(4,3) == 4",
            "assert binomial_coeff(3,2) == 3"
        ],
        "tests": [
            "try: binomial_coeff(-1, 2)\nexcept ValueError as e: assert str(e) == 'Inputs must be non-negative and k must not be greater than n'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'binomial_coeff' to find binomial co-efficient.",
        "instruction": "The function should correctly handle edge cases such as when n or k is 0, or when n equals k.",
        "code_before": "def binomial_coeff(n, k):\n    \"\"\"\n    Calculate the binomial coefficient, also known as \"n choose k\", which is the number of ways to choose k elements from a set of n elements.\n    \n    Args:\n    n (int): The total number of elements.\n    k (int): The number of elements to choose.\n    \n    Returns:\n    int: The binomial coefficient.\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    # Initialize a list to store binomial coefficients\n    C = [0] * (k + 1)\n    C[0] = 1  # nC0 is 1\n    \n    # Calculate value of Binomial Coefficient in bottom-up manner\n    for i in range(1, n + 1):\n        # Compute next row of pascal triangle using the previous row\n        for j in range(min(i, k), 0, -1):\n            C[j] = C[j] + C[j - 1]\n    \n    return C[k]\n\n# Example usage:\nprint(binomial_coeff(5, 2))  # Output: 10\n\n\n",
        "base_tests": [
            "assert binomial_coeff(5,2) == 10",
            "assert binomial_coeff(4,3) == 4",
            "assert binomial_coeff(3,2) == 3"
        ],
        "tests": [
            "assert binomial_coeff(0, 0) == 1\nassert binomial_coeff(5, 0) == 1\nassert binomial_coeff(5, 5) == 1"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'binomial_coeff' to find binomial co-efficient.",
        "instruction": "Extend the function to handle large values of n and k efficiently using memoization or iterative approach.",
        "code_before": "def binomial_coeff(n, k):\n    \"\"\"\n    Calculate the binomial coefficient, also known as \"n choose k\", which is the number of ways to choose k elements from a set of n elements.\n    \n    Args:\n    n (int): The total number of elements.\n    k (int): The number of elements to choose.\n    \n    Returns:\n    int: The binomial coefficient.\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    # Initialize a list to store binomial coefficients\n    C = [0] * (k + 1)\n    C[0] = 1  # nC0 is 1\n    \n    # Calculate value of Binomial Coefficient in bottom-up manner\n    for i in range(1, n + 1):\n        # Compute next row of pascal triangle using the previous row\n        for j in range(min(i, k), 0, -1):\n            C[j] = C[j] + C[j - 1]\n    \n    return C[k]\n\n# Example usage:\nprint(binomial_coeff(5, 2))  # Output: 10\n\n\n",
        "base_tests": [
            "assert binomial_coeff(5,2) == 10",
            "assert binomial_coeff(4,3) == 4",
            "assert binomial_coeff(3,2) == 3"
        ],
        "tests": [
            "assert binomial_coeff(100, 50) == 100891344545564193334812497256"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'binomial_coeff' to find binomial co-efficient.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, 'k': int, and the return type should be annotated as int.",
        "code_before": "def binomial_coeff(n, k):\n    \"\"\"\n    Calculate the binomial coefficient, also known as \"n choose k\", which is the number of ways to choose k elements from a set of n elements.\n    \n    Args:\n    n (int): The total number of elements.\n    k (int): The number of elements to choose.\n    \n    Returns:\n    int: The binomial coefficient.\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    # Initialize a list to store binomial coefficients\n    C = [0] * (k + 1)\n    C[0] = 1  # nC0 is 1\n    \n    # Calculate value of Binomial Coefficient in bottom-up manner\n    for i in range(1, n + 1):\n        # Compute next row of pascal triangle using the previous row\n        for j in range(min(i, k), 0, -1):\n            C[j] = C[j] + C[j - 1]\n    \n    return C[k]\n\n# Example usage:\nprint(binomial_coeff(5, 2))  # Output: 10\n\n\n",
        "base_tests": [
            "assert binomial_coeff(5,2) == 10",
            "assert binomial_coeff(4,3) == 4",
            "assert binomial_coeff(3,2) == 3"
        ],
        "tests": [
            "assert binomial_coeff.__annotations__ == {'n': int, 'k': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'binomial_coeff' to find binomial co-efficient.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def binomial_coeff(n, k):\n    \"\"\"\n    Calculate the binomial coefficient, also known as \"n choose k\", which is the number of ways to choose k elements from a set of n elements.\n    \n    Args:\n    n (int): The total number of elements.\n    k (int): The number of elements to choose.\n    \n    Returns:\n    int: The binomial coefficient.\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    # Initialize a list to store binomial coefficients\n    C = [0] * (k + 1)\n    C[0] = 1  # nC0 is 1\n    \n    # Calculate value of Binomial Coefficient in bottom-up manner\n    for i in range(1, n + 1):\n        # Compute next row of pascal triangle using the previous row\n        for j in range(min(i, k), 0, -1):\n            C[j] = C[j] + C[j - 1]\n    \n    return C[k]\n\n# Example usage:\nprint(binomial_coeff(5, 2))  # Output: 10\n\n\n",
        "base_tests": [
            "assert binomial_coeff(5,2) == 10",
            "assert binomial_coeff(4,3) == 4",
            "assert binomial_coeff(3,2) == 3"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(binomial_coeff)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function 'get_odd_occurrence' to find the element occurring odd number of times.",
        "instruction": "The function should raise a TypeError if the input is not a list of integers.",
        "code_before": "def get_odd_occurrence(arr):\n    \"\"\"\n    This function finds the element that occurs an odd number of times in a list.\n    \n    :param arr: List of integers\n    :return: Integer that occurs an odd number of times\n    \"\"\"\n    # Dictionary to store the count of each element\n    count_dict = {}\n    \n    # Count the occurrences of each element\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Find the element with an odd count\n    for num, count in count_dict.items():\n        if count % 2 != 0:\n            return num\n    \n    # If no element occurs an odd number of times, return None\n    return None\n\n# Example usage:\narr = [1, 2, 3, 2, 3, 1, 3]\nprint(get_odd_occurrence(arr))  # Output: 3\n\n\n",
        "base_tests": [
            "assert get_odd_occurrence([1,2,3,1,2,3,1],7) == 1",
            "assert get_odd_occurrence([1,2,3,2,3,1,3],7) == 3",
            "assert get_odd_occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"
        ],
        "tests": [
            "try:\n    get_odd_occurrence('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    get_odd_occurrence([1, 'two', 3])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function 'get_odd_occurrence' to find the element occurring odd number of times.",
        "instruction": "The function should handle an empty list by returning None.",
        "code_before": "def get_odd_occurrence(arr):\n    \"\"\"\n    This function finds the element that occurs an odd number of times in a list.\n    \n    :param arr: List of integers\n    :return: Integer that occurs an odd number of times\n    \"\"\"\n    # Dictionary to store the count of each element\n    count_dict = {}\n    \n    # Count the occurrences of each element\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Find the element with an odd count\n    for num, count in count_dict.items():\n        if count % 2 != 0:\n            return num\n    \n    # If no element occurs an odd number of times, return None\n    return None\n\n# Example usage:\narr = [1, 2, 3, 2, 3, 1, 3]\nprint(get_odd_occurrence(arr))  # Output: 3\n\n\n",
        "base_tests": [
            "assert get_odd_occurrence([1,2,3,1,2,3,1],7) == 1",
            "assert get_odd_occurrence([1,2,3,2,3,1,3],7) == 3",
            "assert get_odd_occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"
        ],
        "tests": [
            "assert get_odd_occurrence([]) is None"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function 'get_odd_occurrence' to find the element occurring odd number of times.",
        "instruction": "The function should be able to handle lists with multiple elements occurring an odd number of times and return a list of such elements. The parameter should be annotated as arr: list, arr_size: int, and the return type should be annotated as int.",
        "code_before": "def get_odd_occurrence(arr):\n    \"\"\"\n    This function finds the element that occurs an odd number of times in a list.\n    \n    :param arr: List of integers\n    :return: Integer that occurs an odd number of times\n    \"\"\"\n    # Dictionary to store the count of each element\n    count_dict = {}\n    \n    # Count the occurrences of each element\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Find the element with an odd count\n    for num, count in count_dict.items():\n        if count % 2 != 0:\n            return num\n    \n    # If no element occurs an odd number of times, return None\n    return None\n\n# Example usage:\narr = [1, 2, 3, 2, 3, 1, 3]\nprint(get_odd_occurrence(arr))  # Output: 3\n\n\n",
        "base_tests": [
            "assert get_odd_occurrence([1,2,3,1,2,3,1],7) == 1",
            "assert get_odd_occurrence([1,2,3,2,3,1,3],7) == 3",
            "assert get_odd_occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"
        ],
        "tests": [
            "assert get_odd_occurrence([1, 2, 3, 1, 2, 3, 1, 3]) == [1, 3]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function 'get_odd_occurrence' to find the element occurring odd number of times.",
        "instruction": "The function should include type annotations for its parameters and return type, including two parameters: 'arr': list, 'arr_size': int, and a return type: int.",
        "code_before": "def get_odd_occurrence(arr):\n    \"\"\"\n    This function finds the element that occurs an odd number of times in a list.\n    \n    :param arr: List of integers\n    :return: Integer that occurs an odd number of times\n    \"\"\"\n    # Dictionary to store the count of each element\n    count_dict = {}\n    \n    # Count the occurrences of each element\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Find the element with an odd count\n    for num, count in count_dict.items():\n        if count % 2 != 0:\n            return num\n    \n    # If no element occurs an odd number of times, return None\n    return None\n\n# Example usage:\narr = [1, 2, 3, 2, 3, 1, 3]\nprint(get_odd_occurrence(arr))  # Output: 3\n\n\n",
        "base_tests": [
            "assert get_odd_occurrence([1,2,3,1,2,3,1],7) == 1",
            "assert get_odd_occurrence([1,2,3,2,3,1,3],7) == 3",
            "assert get_odd_occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"
        ],
        "tests": [
            "assert get_odd_occurrence.__annotations__ == {'arr': list, 'arr_size': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function 'get_odd_occurrence' to find the element occurring odd number of times.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def get_odd_occurrence(arr):\n    \"\"\"\n    This function finds the element that occurs an odd number of times in a list.\n    \n    :param arr: List of integers\n    :return: Integer that occurs an odd number of times\n    \"\"\"\n    # Dictionary to store the count of each element\n    count_dict = {}\n    \n    # Count the occurrences of each element\n    for num in arr:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Find the element with an odd count\n    for num, count in count_dict.items():\n        if count % 2 != 0:\n            return num\n    \n    # If no element occurs an odd number of times, return None\n    return None\n\n# Example usage:\narr = [1, 2, 3, 2, 3, 1, 3]\nprint(get_odd_occurrence(arr))  # Output: 3\n\n\n",
        "base_tests": [
            "assert get_odd_occurrence([1,2,3,1,2,3,1],7) == 1",
            "assert get_odd_occurrence([1,2,3,2,3,1,3],7) == 3",
            "assert get_odd_occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(get_odd_occurrence)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'count_substring_with_equal_ends' to count all the substrings starting and ending with same characters.",
        "instruction": "The function should accept a string input and return an integer representing the count of substrings starting and ending with the same character.",
        "code_before": "def count_substring_with_equal_ends(s):\n    \"\"\"\n    Counts all substrings of a given string that start and end with the same character.\n\n    :param s: The input string.\n    :return: The count of substrings starting and ending with the same character.\n    \"\"\"\n    n = len(s)\n    count = 0\n\n    # Iterate over all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            # Check if the first and last characters of the substring are the same\n            if s[i] == s[j]:\n                count += 1\n\n    return count\n\n# Example usage:\ns = \"abcab\"\nprint(count_substring_with_equal_ends(s))  # Output: 7\n\n\n",
        "base_tests": [
            "assert count_substring_with_equal_ends(\"abc\") == 3",
            "assert count_substring_with_equal_ends(\"abcda\") == 6",
            "assert count_substring_with_equal_ends(\"ab\") == 2"
        ],
        "tests": [
            "assert isinstance(count_substring_with_equal_ends('abc'), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'count_substring_with_equal_ends' to count all the substrings starting and ending with same characters.",
        "instruction": "The function should raise a TypeError if the input is not a string.",
        "code_before": "def count_substring_with_equal_ends(s):\n    \"\"\"\n    Counts all substrings of a given string that start and end with the same character.\n\n    :param s: The input string.\n    :return: The count of substrings starting and ending with the same character.\n    \"\"\"\n    n = len(s)\n    count = 0\n\n    # Iterate over all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            # Check if the first and last characters of the substring are the same\n            if s[i] == s[j]:\n                count += 1\n\n    return count\n\n# Example usage:\ns = \"abcab\"\nprint(count_substring_with_equal_ends(s))  # Output: 7\n\n\n",
        "base_tests": [
            "assert count_substring_with_equal_ends(\"abc\") == 3",
            "assert count_substring_with_equal_ends(\"abcda\") == 6",
            "assert count_substring_with_equal_ends(\"ab\") == 2"
        ],
        "tests": [
            "try: count_substring_with_equal_ends(123)\n    assert False, 'Expected TypeError'\nexcept TypeError: pass"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'count_substring_with_equal_ends' to count all the substrings starting and ending with same characters.",
        "instruction": "The function should return 0 for an empty string input.",
        "code_before": "def count_substring_with_equal_ends(s):\n    \"\"\"\n    Counts all substrings of a given string that start and end with the same character.\n\n    :param s: The input string.\n    :return: The count of substrings starting and ending with the same character.\n    \"\"\"\n    n = len(s)\n    count = 0\n\n    # Iterate over all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            # Check if the first and last characters of the substring are the same\n            if s[i] == s[j]:\n                count += 1\n\n    return count\n\n# Example usage:\ns = \"abcab\"\nprint(count_substring_with_equal_ends(s))  # Output: 7\n\n\n",
        "base_tests": [
            "assert count_substring_with_equal_ends(\"abc\") == 3",
            "assert count_substring_with_equal_ends(\"abcda\") == 6",
            "assert count_substring_with_equal_ends(\"ab\") == 2"
        ],
        "tests": [
            "assert count_substring_with_equal_ends('') == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'count_substring_with_equal_ends' to count all the substrings starting and ending with same characters.",
        "instruction": "Extend the function to handle strings with special characters and spaces, but only count alphabetic characters.",
        "code_before": "def count_substring_with_equal_ends(s):\n    \"\"\"\n    Counts all substrings of a given string that start and end with the same character.\n\n    :param s: The input string.\n    :return: The count of substrings starting and ending with the same character.\n    \"\"\"\n    n = len(s)\n    count = 0\n\n    # Iterate over all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            # Check if the first and last characters of the substring are the same\n            if s[i] == s[j]:\n                count += 1\n\n    return count\n\n# Example usage:\ns = \"abcab\"\nprint(count_substring_with_equal_ends(s))  # Output: 7\n\n\n",
        "base_tests": [
            "assert count_substring_with_equal_ends(\"abc\") == 3",
            "assert count_substring_with_equal_ends(\"abcda\") == 6",
            "assert count_substring_with_equal_ends(\"ab\") == 2"
        ],
        "tests": [
            "assert count_substring_with_equal_ends('a b a') == 4"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'count_substring_with_equal_ends' to count all the substrings starting and ending with same characters.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 's': str, and the return type should be annotated as int.",
        "code_before": "def count_substring_with_equal_ends(s):\n    \"\"\"\n    Counts all substrings of a given string that start and end with the same character.\n\n    :param s: The input string.\n    :return: The count of substrings starting and ending with the same character.\n    \"\"\"\n    n = len(s)\n    count = 0\n\n    # Iterate over all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            # Check if the first and last characters of the substring are the same\n            if s[i] == s[j]:\n                count += 1\n\n    return count\n\n# Example usage:\ns = \"abcab\"\nprint(count_substring_with_equal_ends(s))  # Output: 7\n\n\n",
        "base_tests": [
            "assert count_substring_with_equal_ends(\"abc\") == 3",
            "assert count_substring_with_equal_ends(\"abcda\") == 6",
            "assert count_substring_with_equal_ends(\"ab\") == 2"
        ],
        "tests": [
            "assert count_substring_with_equal_ends.__annotations__ == {'s': str, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'count_substring_with_equal_ends' to count all the substrings starting and ending with same characters.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def count_substring_with_equal_ends(s):\n    \"\"\"\n    Counts all substrings of a given string that start and end with the same character.\n\n    :param s: The input string.\n    :return: The count of substrings starting and ending with the same character.\n    \"\"\"\n    n = len(s)\n    count = 0\n\n    # Iterate over all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            # Check if the first and last characters of the substring are the same\n            if s[i] == s[j]:\n                count += 1\n\n    return count\n\n# Example usage:\ns = \"abcab\"\nprint(count_substring_with_equal_ends(s))  # Output: 7\n\n\n",
        "base_tests": [
            "assert count_substring_with_equal_ends(\"abc\") == 3",
            "assert count_substring_with_equal_ends(\"abcda\") == 6",
            "assert count_substring_with_equal_ends(\"ab\") == 2"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(count_substring_with_equal_ends)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function named 'func' to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.",
        "instruction": "The function should raise a ValueError as 'k cannot be greater than the number of distinct integers' if k is greater than the total number of distinct integers across all lists.",
        "code_before": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    \"\"\"\n    Find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.\n    \n    :param lists: List of lists of sorted and distinct integers\n    :param k: Number of top frequent integers to find\n    :return: List of top k frequent integers\n    \"\"\"\n    # Flatten the list of lists into a single list\n    all_numbers = [num for sublist in lists for num in sublist]\n    \n    # Count the frequency of each number\n    frequency = Counter(all_numbers)\n    \n    # Use a heap to find the k most common elements\n    # The nlargest function returns the k largest elements from the dataset defined by the iterable\n    # Here, we use a lambda function to sort by frequency\n    top_k = heapq.nlargest(k, frequency.items(), key=lambda x: x[1])\n    \n    # Extract the numbers from the top_k tuples\n    result = [num for num, freq in top_k]\n    \n    return result\n\n# Example usage:\nlists = [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]\nk = 2\nprint(func(lists, k))  # Output: [3, 4]\n\n\n",
        "base_tests": [
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"
        ],
        "tests": [
            "try:\n    func([[1, 2], [3, 4]], 5)\nexcept ValueError as e:\n    assert str(e) == 'k cannot be greater than the number of distinct integers'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function named 'func' to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.",
        "instruction": "The function should return an empty list if all input lists are empty.",
        "code_before": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    \"\"\"\n    Find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.\n    \n    :param lists: List of lists of sorted and distinct integers\n    :param k: Number of top frequent integers to find\n    :return: List of top k frequent integers\n    \"\"\"\n    # Flatten the list of lists into a single list\n    all_numbers = [num for sublist in lists for num in sublist]\n    \n    # Count the frequency of each number\n    frequency = Counter(all_numbers)\n    \n    # Use a heap to find the k most common elements\n    # The nlargest function returns the k largest elements from the dataset defined by the iterable\n    # Here, we use a lambda function to sort by frequency\n    top_k = heapq.nlargest(k, frequency.items(), key=lambda x: x[1])\n    \n    # Extract the numbers from the top_k tuples\n    result = [num for num, freq in top_k]\n    \n    return result\n\n# Example usage:\nlists = [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]\nk = 2\nprint(func(lists, k))  # Output: [3, 4]\n\n\n",
        "base_tests": [
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"
        ],
        "tests": [
            "assert func([[], [], []], 0) == []"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function named 'func' to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.",
        "instruction": "Extend the function to handle cases where k is zero, returning an empty list.",
        "code_before": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    \"\"\"\n    Find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.\n    \n    :param lists: List of lists of sorted and distinct integers\n    :param k: Number of top frequent integers to find\n    :return: List of top k frequent integers\n    \"\"\"\n    # Flatten the list of lists into a single list\n    all_numbers = [num for sublist in lists for num in sublist]\n    \n    # Count the frequency of each number\n    frequency = Counter(all_numbers)\n    \n    # Use a heap to find the k most common elements\n    # The nlargest function returns the k largest elements from the dataset defined by the iterable\n    # Here, we use a lambda function to sort by frequency\n    top_k = heapq.nlargest(k, frequency.items(), key=lambda x: x[1])\n    \n    # Extract the numbers from the top_k tuples\n    result = [num for num, freq in top_k]\n    \n    return result\n\n# Example usage:\nlists = [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]\nk = 2\nprint(func(lists, k))  # Output: [3, 4]\n\n\n",
        "base_tests": [
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"
        ],
        "tests": [
            "assert func([[1, 2, 3], [4, 5, 6]], 0) == []"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function named 'func' to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'nums': List[List[int]], 'k': int, and the return type should be annotated as List[int].",
        "code_before": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    \"\"\"\n    Find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.\n    \n    :param lists: List of lists of sorted and distinct integers\n    :param k: Number of top frequent integers to find\n    :return: List of top k frequent integers\n    \"\"\"\n    # Flatten the list of lists into a single list\n    all_numbers = [num for sublist in lists for num in sublist]\n    \n    # Count the frequency of each number\n    frequency = Counter(all_numbers)\n    \n    # Use a heap to find the k most common elements\n    # The nlargest function returns the k largest elements from the dataset defined by the iterable\n    # Here, we use a lambda function to sort by frequency\n    top_k = heapq.nlargest(k, frequency.items(), key=lambda x: x[1])\n    \n    # Extract the numbers from the top_k tuples\n    result = [num for num, freq in top_k]\n    \n    return result\n\n# Example usage:\nlists = [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]\nk = 2\nprint(func(lists, k))  # Output: [3, 4]\n\n\n",
        "base_tests": [
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"
        ],
        "tests": [
            "assert 'def func(nums: List[List[int]], k: int) -> List[int]:' in inspect.getsource(func)"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function named 'func' to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper indentation and spacing.",
        "code_before": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    \"\"\"\n    Find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.\n    \n    :param lists: List of lists of sorted and distinct integers\n    :param k: Number of top frequent integers to find\n    :return: List of top k frequent integers\n    \"\"\"\n    # Flatten the list of lists into a single list\n    all_numbers = [num for sublist in lists for num in sublist]\n    \n    # Count the frequency of each number\n    frequency = Counter(all_numbers)\n    \n    # Use a heap to find the k most common elements\n    # The nlargest function returns the k largest elements from the dataset defined by the iterable\n    # Here, we use a lambda function to sort by frequency\n    top_k = heapq.nlargest(k, frequency.items(), key=lambda x: x[1])\n    \n    # Extract the numbers from the top_k tuples\n    result = [num for num, freq in top_k]\n    \n    return result\n\n# Example usage:\nlists = [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]\nk = 2\nprint(func(lists, k))  # Output: [3, 4]\n\n\n",
        "base_tests": [
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]",
            "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(func)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.",
        "instruction": "The function should accept a positive integer as input and return the largest prime factor as an integer.",
        "code_before": "def max_prime_factors(n):\n    \"\"\"\n    This function returns the largest prime factor of a given number n.\n    \"\"\"\n    # Initialize the largest prime factor\n    max_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n    \n    # n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, print i and divide n\n        while n % i == 0:\n            max_prime = i\n            n //= i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n    \n    return max_prime\n\n# Example usage:\nprint(max_prime_factors(13195))  # Output: 29\nprint(max_prime_factors(600851475143))  # Output: 6857\n\n\n",
        "base_tests": [
            "assert max_prime_factors(15) == 5",
            "assert max_prime_factors(6) == 3",
            "assert max_prime_factors(2) == 2"
        ],
        "tests": [
            "assert isinstance(max_prime_factors(15), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.",
        "instruction": "The function should raise a ValueError as 'Input must be a positive integer' with a descriptive error message if the input is not a positive integer.",
        "code_before": "def max_prime_factors(n):\n    \"\"\"\n    This function returns the largest prime factor of a given number n.\n    \"\"\"\n    # Initialize the largest prime factor\n    max_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n    \n    # n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, print i and divide n\n        while n % i == 0:\n            max_prime = i\n            n //= i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n    \n    return max_prime\n\n# Example usage:\nprint(max_prime_factors(13195))  # Output: 29\nprint(max_prime_factors(600851475143))  # Output: 6857\n\n\n",
        "base_tests": [
            "assert max_prime_factors(15) == 5",
            "assert max_prime_factors(6) == 3",
            "assert max_prime_factors(2) == 2"
        ],
        "tests": [
            "try:\n    max_prime_factors(-10)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a positive integer'\ntry:\n    max_prime_factors(0)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a positive integer' "
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.",
        "instruction": "The function should correctly handle the smallest prime number, which is 2, and return 2 as its largest prime factor.",
        "code_before": "def max_prime_factors(n):\n    \"\"\"\n    This function returns the largest prime factor of a given number n.\n    \"\"\"\n    # Initialize the largest prime factor\n    max_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n    \n    # n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, print i and divide n\n        while n % i == 0:\n            max_prime = i\n            n //= i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n    \n    return max_prime\n\n# Example usage:\nprint(max_prime_factors(13195))  # Output: 29\nprint(max_prime_factors(600851475143))  # Output: 6857\n\n\n",
        "base_tests": [
            "assert max_prime_factors(15) == 5",
            "assert max_prime_factors(6) == 3",
            "assert max_prime_factors(2) == 2"
        ],
        "tests": [
            "assert max_prime_factors(2) == 2"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.",
        "instruction": "Extend the function to return a list of prime factors of the given number. Add a parameter return_all (default value False). When return_all is True, return all the prime factors, otherwise return only the largest prime factor.",
        "code_before": "def max_prime_factors(n):\n    \"\"\"\n    This function returns the largest prime factor of a given number n.\n    \"\"\"\n    # Initialize the largest prime factor\n    max_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n    \n    # n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, print i and divide n\n        while n % i == 0:\n            max_prime = i\n            n //= i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n    \n    return max_prime\n\n# Example usage:\nprint(max_prime_factors(13195))  # Output: 29\nprint(max_prime_factors(600851475143))  # Output: 6857\n\n\n",
        "base_tests": [
            "assert max_prime_factors(15) == 5",
            "assert max_prime_factors(6) == 3",
            "assert max_prime_factors(2) == 2"
        ],
        "tests": [
            "assert max_prime_factors(15, return_all=True) == [3, 5]",
            "assert max_prime_factors(6, return_all=True) == [2, 3]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as int.",
        "code_before": "def max_prime_factors(n):\n    \"\"\"\n    This function returns the largest prime factor of a given number n.\n    \"\"\"\n    # Initialize the largest prime factor\n    max_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n    \n    # n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, print i and divide n\n        while n % i == 0:\n            max_prime = i\n            n //= i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n    \n    return max_prime\n\n# Example usage:\nprint(max_prime_factors(13195))  # Output: 29\nprint(max_prime_factors(600851475143))  # Output: 6857\n\n\n",
        "base_tests": [
            "assert max_prime_factors(15) == 5",
            "assert max_prime_factors(6) == 3",
            "assert max_prime_factors(2) == 2"
        ],
        "tests": [
            "assert max_prime_factors.__annotations__ == {'n': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.",
        "instruction": "The function should have a cyclomatic complexity of 5 or less.",
        "code_before": "def max_prime_factors(n):\n    \"\"\"\n    This function returns the largest prime factor of a given number n.\n    \"\"\"\n    # Initialize the largest prime factor\n    max_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n    \n    # n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, print i and divide n\n        while n % i == 0:\n            max_prime = i\n            n //= i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n    \n    return max_prime\n\n# Example usage:\nprint(max_prime_factors(13195))  # Output: 29\nprint(max_prime_factors(600851475143))  # Output: 6857\n\n\n",
        "base_tests": [
            "assert max_prime_factors(15) == 5",
            "assert max_prime_factors(6) == 3",
            "assert max_prime_factors(2) == 2"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(max_prime_factors))[0].complexity <= 5"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def max_prime_factors(n):\n    \"\"\"\n    This function returns the largest prime factor of a given number n.\n    \"\"\"\n    # Initialize the largest prime factor\n    max_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n    \n    # n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, print i and divide n\n        while n % i == 0:\n            max_prime = i\n            n //= i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        max_prime = n\n    \n    return max_prime\n\n# Example usage:\nprint(max_prime_factors(13195))  # Output: 29\nprint(max_prime_factors(600851475143))  # Output: 6857\n\n\n",
        "base_tests": [
            "assert max_prime_factors(15) == 5",
            "assert max_prime_factors(6) == 3",
            "assert max_prime_factors(2) == 2"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(max_prime_factors)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'decimal_to_binary' to convert a decimal number to binary number.",
        "instruction": "The function should raise a ValueError if the input is not a non-negative integer.",
        "code_before": "def decimal_to_binary(n):\n    \"\"\"\n    Convert a decimal number to binary number.\n\n    Parameters:\n    n (int): The decimal number to convert.\n\n    Returns:\n    str: The binary representation of the decimal number.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary\n\n# Example usage:\nprint(decimal_to_binary(10))  # Output: \"1010\"\nprint(decimal_to_binary(0))   # Output: \"0\"\nprint(decimal_to_binary(255)) # Output: \"11111111\"\n\n\n",
        "base_tests": [
            "assert decimal_to_binary(10) == 1010",
            "assert decimal_to_binary(1) == 1",
            "assert decimal_to_binary(20) == 10100"
        ],
        "tests": [
            "try: decimal_to_binary(-1)\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError'",
            "try: decimal_to_binary('10')\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'decimal_to_binary' to convert a decimal number to binary number.",
        "instruction": "The function should correctly handle the edge case where the input is zero.",
        "code_before": "def decimal_to_binary(n):\n    \"\"\"\n    Convert a decimal number to binary number.\n\n    Parameters:\n    n (int): The decimal number to convert.\n\n    Returns:\n    str: The binary representation of the decimal number.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary\n\n# Example usage:\nprint(decimal_to_binary(10))  # Output: \"1010\"\nprint(decimal_to_binary(0))   # Output: \"0\"\nprint(decimal_to_binary(255)) # Output: \"11111111\"\n\n\n",
        "base_tests": [
            "assert decimal_to_binary(10) == 1010",
            "assert decimal_to_binary(1) == 1",
            "assert decimal_to_binary(20) == 10100"
        ],
        "tests": [
            "assert decimal_to_binary(0) == '0'"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'decimal_to_binary' to convert a decimal number to binary number.",
        "instruction": "Extend the function to handle a list of decimal numbers, returning a list of binary strings.",
        "code_before": "def decimal_to_binary(n):\n    \"\"\"\n    Convert a decimal number to binary number.\n\n    Parameters:\n    n (int): The decimal number to convert.\n\n    Returns:\n    str: The binary representation of the decimal number.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary\n\n# Example usage:\nprint(decimal_to_binary(10))  # Output: \"1010\"\nprint(decimal_to_binary(0))   # Output: \"0\"\nprint(decimal_to_binary(255)) # Output: \"11111111\"\n\n\n",
        "base_tests": [
            "assert decimal_to_binary(10) == 1010",
            "assert decimal_to_binary(1) == 1",
            "assert decimal_to_binary(20) == 10100"
        ],
        "tests": [
            "assert decimal_to_binary([10, 1, 20]) == ['1010', '1', '10100']",
            "assert decimal_to_binary([0, 5]) == ['0', '101']"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'decimal_to_binary' to convert a decimal number to binary number.",
        "instruction": "The function should include type annotations for input parameters and return type. The parameter should be annotated as 'N': int, and the return type should be annotated as str.",
        "code_before": "def decimal_to_binary(n):\n    \"\"\"\n    Convert a decimal number to binary number.\n\n    Parameters:\n    n (int): The decimal number to convert.\n\n    Returns:\n    str: The binary representation of the decimal number.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary\n\n# Example usage:\nprint(decimal_to_binary(10))  # Output: \"1010\"\nprint(decimal_to_binary(0))   # Output: \"0\"\nprint(decimal_to_binary(255)) # Output: \"11111111\"\n\n\n",
        "base_tests": [
            "assert decimal_to_binary(10) == 1010",
            "assert decimal_to_binary(1) == 1",
            "assert decimal_to_binary(20) == 10100"
        ],
        "tests": [
            "assert 'def decimal_to_binary(N: int) -> str:' in inspect.getsource(decimal_to_binary)"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'decimal_to_binary' to convert a decimal number to binary number.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple linear function.",
        "code_before": "def decimal_to_binary(n):\n    \"\"\"\n    Convert a decimal number to binary number.\n\n    Parameters:\n    n (int): The decimal number to convert.\n\n    Returns:\n    str: The binary representation of the decimal number.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary\n\n# Example usage:\nprint(decimal_to_binary(10))  # Output: \"1010\"\nprint(decimal_to_binary(0))   # Output: \"0\"\nprint(decimal_to_binary(255)) # Output: \"11111111\"\n\n\n",
        "base_tests": [
            "assert decimal_to_binary(10) == 1010",
            "assert decimal_to_binary(1) == 1",
            "assert decimal_to_binary(20) == 10100"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(decimal_to_binary))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'decimal_to_binary' to convert a decimal number to binary number.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def decimal_to_binary(n):\n    \"\"\"\n    Convert a decimal number to binary number.\n\n    Parameters:\n    n (int): The decimal number to convert.\n\n    Returns:\n    str: The binary representation of the decimal number.\n    \"\"\"\n    if n == 0:\n        return \"0\"\n    binary = \"\"\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary\n\n# Example usage:\nprint(decimal_to_binary(10))  # Output: \"1010\"\nprint(decimal_to_binary(0))   # Output: \"0\"\nprint(decimal_to_binary(255)) # Output: \"11111111\"\n\n\n",
        "base_tests": [
            "assert decimal_to_binary(10) == 1010",
            "assert decimal_to_binary(1) == 1",
            "assert decimal_to_binary(20) == 10100"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(decimal_to_binary)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'find_missing' to find the missing number in a sorted array.",
        "instruction": "The function should raise a ValueError with a descriptive message as 'Input list must be sorted.' if the input list is not sorted.",
        "code_before": "def find_missing(arr):\n    \"\"\"\n    This function finds the missing number in a sorted array of consecutive integers.\n    The array is assumed to have exactly one number missing.\n    \n    :param arr: List[int] - A sorted list of consecutive integers with one missing number.\n    :return: int - The missing number in the array.\n    \"\"\"\n    # Initialize the expected sum of the array if no number was missing\n    n = len(arr) + 1  # Since one number is missing, the length should be one more\n    expected_sum = n * (n + 1) // 2  # Sum of first n natural numbers\n    \n    # Calculate the actual sum of the array\n    actual_sum = sum(arr)\n    \n    # The missing number is the difference between the expected sum and the actual sum\n    missing_number = expected_sum - actual_sum\n    \n    return missing_number\n\n# Example usage:\narr = [1, 2, 3, 4, 6]  # Here, 5 is missing\nprint(find_missing(arr))  # Output: 5\n\n\n",
        "base_tests": [
            "assert find_missing([1,2,3,5],4) == 4",
            "assert find_missing([1,3,4,5],4) == 2",
            "assert find_missing([1,2,3,5,6,7],5) == 4"
        ],
        "tests": [
            "try:\n    find_missing([3,1,2,4], 4)\nexcept ValueError as e:\n    assert str(e) == 'Input list must be sorted.'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'find_missing' to find the missing number in a sorted array.",
        "instruction": "The function should correctly handle the edge case where the missing number is the smallest number in the sequence.",
        "code_before": "def find_missing(arr):\n    \"\"\"\n    This function finds the missing number in a sorted array of consecutive integers.\n    The array is assumed to have exactly one number missing.\n    \n    :param arr: List[int] - A sorted list of consecutive integers with one missing number.\n    :return: int - The missing number in the array.\n    \"\"\"\n    # Initialize the expected sum of the array if no number was missing\n    n = len(arr) + 1  # Since one number is missing, the length should be one more\n    expected_sum = n * (n + 1) // 2  # Sum of first n natural numbers\n    \n    # Calculate the actual sum of the array\n    actual_sum = sum(arr)\n    \n    # The missing number is the difference between the expected sum and the actual sum\n    missing_number = expected_sum - actual_sum\n    \n    return missing_number\n\n# Example usage:\narr = [1, 2, 3, 4, 6]  # Here, 5 is missing\nprint(find_missing(arr))  # Output: 5\n\n\n",
        "base_tests": [
            "assert find_missing([1,2,3,5],4) == 4",
            "assert find_missing([1,3,4,5],4) == 2",
            "assert find_missing([1,2,3,5,6,7],5) == 4"
        ],
        "tests": [
            "assert find_missing([2,3,4,5], 4) == 1"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'find_missing' to find the missing number in a sorted array.",
        "instruction": "Extend the function to handle cases where multiple numbers are missing, returning a list of all missing numbers.",
        "code_before": "def find_missing(arr):\n    \"\"\"\n    This function finds the missing number in a sorted array of consecutive integers.\n    The array is assumed to have exactly one number missing.\n    \n    :param arr: List[int] - A sorted list of consecutive integers with one missing number.\n    :return: int - The missing number in the array.\n    \"\"\"\n    # Initialize the expected sum of the array if no number was missing\n    n = len(arr) + 1  # Since one number is missing, the length should be one more\n    expected_sum = n * (n + 1) // 2  # Sum of first n natural numbers\n    \n    # Calculate the actual sum of the array\n    actual_sum = sum(arr)\n    \n    # The missing number is the difference between the expected sum and the actual sum\n    missing_number = expected_sum - actual_sum\n    \n    return missing_number\n\n# Example usage:\narr = [1, 2, 3, 4, 6]  # Here, 5 is missing\nprint(find_missing(arr))  # Output: 5\n\n\n",
        "base_tests": [
            "assert find_missing([1,2,3,5],4) == 4",
            "assert find_missing([1,3,4,5],4) == 2",
            "assert find_missing([1,2,3,5,6,7],5) == 4"
        ],
        "tests": [
            "assert find_missing([1,3,6], 3) == [2, 4, 5]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'find_missing' to find the missing number in a sorted array.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'ar': list, 'N': int, and the return type should be annotated as int.",
        "code_before": "def find_missing(arr):\n    \"\"\"\n    This function finds the missing number in a sorted array of consecutive integers.\n    The array is assumed to have exactly one number missing.\n    \n    :param arr: List[int] - A sorted list of consecutive integers with one missing number.\n    :return: int - The missing number in the array.\n    \"\"\"\n    # Initialize the expected sum of the array if no number was missing\n    n = len(arr) + 1  # Since one number is missing, the length should be one more\n    expected_sum = n * (n + 1) // 2  # Sum of first n natural numbers\n    \n    # Calculate the actual sum of the array\n    actual_sum = sum(arr)\n    \n    # The missing number is the difference between the expected sum and the actual sum\n    missing_number = expected_sum - actual_sum\n    \n    return missing_number\n\n# Example usage:\narr = [1, 2, 3, 4, 6]  # Here, 5 is missing\nprint(find_missing(arr))  # Output: 5\n\n\n",
        "base_tests": [
            "assert find_missing([1,2,3,5],4) == 4",
            "assert find_missing([1,3,4,5],4) == 2",
            "assert find_missing([1,2,3,5,6,7],5) == 4"
        ],
        "tests": [
            "assert find_missing.__annotations__ == {'ar': list, 'N': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'find_missing' to find the missing number in a sorted array.",
        "instruction": "The function should follow PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def find_missing(arr):\n    \"\"\"\n    This function finds the missing number in a sorted array of consecutive integers.\n    The array is assumed to have exactly one number missing.\n    \n    :param arr: List[int] - A sorted list of consecutive integers with one missing number.\n    :return: int - The missing number in the array.\n    \"\"\"\n    # Initialize the expected sum of the array if no number was missing\n    n = len(arr) + 1  # Since one number is missing, the length should be one more\n    expected_sum = n * (n + 1) // 2  # Sum of first n natural numbers\n    \n    # Calculate the actual sum of the array\n    actual_sum = sum(arr)\n    \n    # The missing number is the difference between the expected sum and the actual sum\n    missing_number = expected_sum - actual_sum\n    \n    return missing_number\n\n# Example usage:\narr = [1, 2, 3, 4, 6]  # Here, 5 is missing\nprint(find_missing(arr))  # Output: 5\n\n\n",
        "base_tests": [
            "assert find_missing([1,2,3,5],4) == 4",
            "assert find_missing([1,3,4,5],4) == 2",
            "assert find_missing([1,2,3,5,6,7],5) == 4"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_missing)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.",
        "instruction": "The function should accept a single integer input and return an integer output representing the n-th rectangular number.",
        "code_before": "def find_rect_num(n):\n    \"\"\"\n    Find the n-th rectangular number.\n    \n    A rectangular number is a number that can be arranged into a rectangle. \n    The n-th rectangular number is the product of n and (n+1).\n    \n    Parameters:\n    n (int): The position of the rectangular number to find.\n    \n    Returns:\n    int: The n-th rectangular number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (n + 1)\n\n# Example usage:\nprint(find_rect_num(1))  # Output: 2\nprint(find_rect_num(2))  # Output: 6\nprint(find_rect_num(3))  # Output: 12\n\n\n",
        "base_tests": [
            "assert find_rect_num(4) == 20",
            "assert find_rect_num(5) == 30",
            "assert find_rect_num(6) == 42"
        ],
        "tests": [
            "assert isinstance(find_rect_num(7), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.",
        "instruction": "The function should raise a ValueError if the input is not a positive integer.",
        "code_before": "def find_rect_num(n):\n    \"\"\"\n    Find the n-th rectangular number.\n    \n    A rectangular number is a number that can be arranged into a rectangle. \n    The n-th rectangular number is the product of n and (n+1).\n    \n    Parameters:\n    n (int): The position of the rectangular number to find.\n    \n    Returns:\n    int: The n-th rectangular number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (n + 1)\n\n# Example usage:\nprint(find_rect_num(1))  # Output: 2\nprint(find_rect_num(2))  # Output: 6\nprint(find_rect_num(3))  # Output: 12\n\n\n",
        "base_tests": [
            "assert find_rect_num(4) == 20",
            "assert find_rect_num(5) == 30",
            "assert find_rect_num(6) == 42"
        ],
        "tests": [
            "try: find_rect_num(-1)\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError for negative input'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.",
        "instruction": "The function should correctly handle the edge case where n is 1, returning 2 as the first rectangular number.",
        "code_before": "def find_rect_num(n):\n    \"\"\"\n    Find the n-th rectangular number.\n    \n    A rectangular number is a number that can be arranged into a rectangle. \n    The n-th rectangular number is the product of n and (n+1).\n    \n    Parameters:\n    n (int): The position of the rectangular number to find.\n    \n    Returns:\n    int: The n-th rectangular number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (n + 1)\n\n# Example usage:\nprint(find_rect_num(1))  # Output: 2\nprint(find_rect_num(2))  # Output: 6\nprint(find_rect_num(3))  # Output: 12\n\n\n",
        "base_tests": [
            "assert find_rect_num(4) == 20",
            "assert find_rect_num(5) == 30",
            "assert find_rect_num(6) == 42"
        ],
        "tests": [
            "assert find_rect_num(1) == 2"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.",
        "instruction": "Extend the function to handle a list of integers, returning a list of corresponding rectangular numbers.",
        "code_before": "def find_rect_num(n):\n    \"\"\"\n    Find the n-th rectangular number.\n    \n    A rectangular number is a number that can be arranged into a rectangle. \n    The n-th rectangular number is the product of n and (n+1).\n    \n    Parameters:\n    n (int): The position of the rectangular number to find.\n    \n    Returns:\n    int: The n-th rectangular number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (n + 1)\n\n# Example usage:\nprint(find_rect_num(1))  # Output: 2\nprint(find_rect_num(2))  # Output: 6\nprint(find_rect_num(3))  # Output: 12\n\n\n",
        "base_tests": [
            "assert find_rect_num(4) == 20",
            "assert find_rect_num(5) == 30",
            "assert find_rect_num(6) == 42"
        ],
        "tests": [
            "assert find_rect_num([1, 2, 3]) == [2, 6, 12]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as int.",
        "code_before": "def find_rect_num(n):\n    \"\"\"\n    Find the n-th rectangular number.\n    \n    A rectangular number is a number that can be arranged into a rectangle. \n    The n-th rectangular number is the product of n and (n+1).\n    \n    Parameters:\n    n (int): The position of the rectangular number to find.\n    \n    Returns:\n    int: The n-th rectangular number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (n + 1)\n\n# Example usage:\nprint(find_rect_num(1))  # Output: 2\nprint(find_rect_num(2))  # Output: 6\nprint(find_rect_num(3))  # Output: 12\n\n\n",
        "base_tests": [
            "assert find_rect_num(4) == 20",
            "assert find_rect_num(5) == 30",
            "assert find_rect_num(6) == 42"
        ],
        "tests": [
            "assert find_rect_num.__annotations__ == {'n': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a straightforward implementation without unnecessary branching.",
        "code_before": "def find_rect_num(n):\n    \"\"\"\n    Find the n-th rectangular number.\n    \n    A rectangular number is a number that can be arranged into a rectangle. \n    The n-th rectangular number is the product of n and (n+1).\n    \n    Parameters:\n    n (int): The position of the rectangular number to find.\n    \n    Returns:\n    int: The n-th rectangular number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (n + 1)\n\n# Example usage:\nprint(find_rect_num(1))  # Output: 2\nprint(find_rect_num(2))  # Output: 6\nprint(find_rect_num(3))  # Output: 12\n\n\n",
        "base_tests": [
            "assert find_rect_num(4) == 20",
            "assert find_rect_num(5) == 30",
            "assert find_rect_num(6) == 42"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(find_rect_num))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def find_rect_num(n):\n    \"\"\"\n    Find the n-th rectangular number.\n    \n    A rectangular number is a number that can be arranged into a rectangle. \n    The n-th rectangular number is the product of n and (n+1).\n    \n    Parameters:\n    n (int): The position of the rectangular number to find.\n    \n    Returns:\n    int: The n-th rectangular number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (n + 1)\n\n# Example usage:\nprint(find_rect_num(1))  # Output: 2\nprint(find_rect_num(2))  # Output: 6\nprint(find_rect_num(3))  # Output: 12\n\n\n",
        "base_tests": [
            "assert find_rect_num(4) == 20",
            "assert find_rect_num(5) == 30",
            "assert find_rect_num(6) == 42"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_rect_num)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.",
        "instruction": "The function should accept two integers as input and return an integer representing the nth digit of the decimal representation of the fraction.",
        "code_before": "def find_nth_digit(numerator, denominator, n):\n    \"\"\"\n    This function finds the nth digit in the decimal representation of the fraction numerator/denominator.\n    \n    :param numerator: The numerator of the fraction.\n    :param denominator: The denominator of the fraction.\n    :param n: The position of the digit to be found in the decimal representation.\n    :return: The nth digit in the decimal representation of the fraction.\n    \"\"\"\n    # Ensure the fraction is a proper fraction\n    if numerator >= denominator:\n        raise ValueError(\"The fraction must be a proper fraction (numerator < denominator).\")\n    \n    # Initialize the remainder\n    remainder = numerator\n    \n    # Loop until we find the nth digit\n    for _ in range(n):\n        # Multiply the remainder by 10 to shift the decimal point\n        remainder *= 10\n        \n        # Find the next digit in the decimal representation\n        digit = remainder // denominator\n        \n        # Update the remainder\n        remainder %= denominator\n    \n    return digit\n\n# Example usage:\nnumerator = 1\ndenominator = 3\nn = 5\nprint(find_nth_digit(numerator, denominator, n))  # Output: 3, because 1/3 = 0.33333...\n\n\n",
        "base_tests": [
            "assert find_nth_digit(1,2,1) == 5",
            "assert find_nth_digit(3,5,1) == 6",
            "assert find_nth_digit(5,6,5) == 3"
        ],
        "tests": [
            "assert isinstance(find_nth_digit(1, 2, 1), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.",
        "instruction": "The function should raise a ValueError as 'Denominator cannot be zero' if the denominator is zero, as division by zero is undefined.",
        "code_before": "def find_nth_digit(numerator, denominator, n):\n    \"\"\"\n    This function finds the nth digit in the decimal representation of the fraction numerator/denominator.\n    \n    :param numerator: The numerator of the fraction.\n    :param denominator: The denominator of the fraction.\n    :param n: The position of the digit to be found in the decimal representation.\n    :return: The nth digit in the decimal representation of the fraction.\n    \"\"\"\n    # Ensure the fraction is a proper fraction\n    if numerator >= denominator:\n        raise ValueError(\"The fraction must be a proper fraction (numerator < denominator).\")\n    \n    # Initialize the remainder\n    remainder = numerator\n    \n    # Loop until we find the nth digit\n    for _ in range(n):\n        # Multiply the remainder by 10 to shift the decimal point\n        remainder *= 10\n        \n        # Find the next digit in the decimal representation\n        digit = remainder // denominator\n        \n        # Update the remainder\n        remainder %= denominator\n    \n    return digit\n\n# Example usage:\nnumerator = 1\ndenominator = 3\nn = 5\nprint(find_nth_digit(numerator, denominator, n))  # Output: 3, because 1/3 = 0.33333...\n\n\n",
        "base_tests": [
            "assert find_nth_digit(1,2,1) == 5",
            "assert find_nth_digit(3,5,1) == 6",
            "assert find_nth_digit(5,6,5) == 3"
        ],
        "tests": [
            "try:\n    find_nth_digit(1, 0, 1)\nexcept ValueError as e:\n    assert str(e) == 'Denominator cannot be zero'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.",
        "instruction": "The function should correctly handle the case where the numerator is zero, returning 0 for any nth digit.",
        "code_before": "def find_nth_digit(numerator, denominator, n):\n    \"\"\"\n    This function finds the nth digit in the decimal representation of the fraction numerator/denominator.\n    \n    :param numerator: The numerator of the fraction.\n    :param denominator: The denominator of the fraction.\n    :param n: The position of the digit to be found in the decimal representation.\n    :return: The nth digit in the decimal representation of the fraction.\n    \"\"\"\n    # Ensure the fraction is a proper fraction\n    if numerator >= denominator:\n        raise ValueError(\"The fraction must be a proper fraction (numerator < denominator).\")\n    \n    # Initialize the remainder\n    remainder = numerator\n    \n    # Loop until we find the nth digit\n    for _ in range(n):\n        # Multiply the remainder by 10 to shift the decimal point\n        remainder *= 10\n        \n        # Find the next digit in the decimal representation\n        digit = remainder // denominator\n        \n        # Update the remainder\n        remainder %= denominator\n    \n    return digit\n\n# Example usage:\nnumerator = 1\ndenominator = 3\nn = 5\nprint(find_nth_digit(numerator, denominator, n))  # Output: 3, because 1/3 = 0.33333...\n\n\n",
        "base_tests": [
            "assert find_nth_digit(1,2,1) == 5",
            "assert find_nth_digit(3,5,1) == 6",
            "assert find_nth_digit(5,6,5) == 3"
        ],
        "tests": [
            "assert find_nth_digit(0, 5, 1) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.",
        "instruction": "Extend the function to handle negative numerators and denominators, returning the nth digit of the absolute value of the fraction.",
        "code_before": "def find_nth_digit(numerator, denominator, n):\n    \"\"\"\n    This function finds the nth digit in the decimal representation of the fraction numerator/denominator.\n    \n    :param numerator: The numerator of the fraction.\n    :param denominator: The denominator of the fraction.\n    :param n: The position of the digit to be found in the decimal representation.\n    :return: The nth digit in the decimal representation of the fraction.\n    \"\"\"\n    # Ensure the fraction is a proper fraction\n    if numerator >= denominator:\n        raise ValueError(\"The fraction must be a proper fraction (numerator < denominator).\")\n    \n    # Initialize the remainder\n    remainder = numerator\n    \n    # Loop until we find the nth digit\n    for _ in range(n):\n        # Multiply the remainder by 10 to shift the decimal point\n        remainder *= 10\n        \n        # Find the next digit in the decimal representation\n        digit = remainder // denominator\n        \n        # Update the remainder\n        remainder %= denominator\n    \n    return digit\n\n# Example usage:\nnumerator = 1\ndenominator = 3\nn = 5\nprint(find_nth_digit(numerator, denominator, n))  # Output: 3, because 1/3 = 0.33333...\n\n\n",
        "base_tests": [
            "assert find_nth_digit(1,2,1) == 5",
            "assert find_nth_digit(3,5,1) == 6",
            "assert find_nth_digit(5,6,5) == 3"
        ],
        "tests": [
            "assert find_nth_digit(-1, 2, 1) == 5"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.",
        "instruction": "The function should include type annotations for all parameters and the return type. The parameter should be annotated as 'p': int, 'q': int, 'N': int, and the return type should be annotated as int.",
        "code_before": "def find_nth_digit(numerator, denominator, n):\n    \"\"\"\n    This function finds the nth digit in the decimal representation of the fraction numerator/denominator.\n    \n    :param numerator: The numerator of the fraction.\n    :param denominator: The denominator of the fraction.\n    :param n: The position of the digit to be found in the decimal representation.\n    :return: The nth digit in the decimal representation of the fraction.\n    \"\"\"\n    # Ensure the fraction is a proper fraction\n    if numerator >= denominator:\n        raise ValueError(\"The fraction must be a proper fraction (numerator < denominator).\")\n    \n    # Initialize the remainder\n    remainder = numerator\n    \n    # Loop until we find the nth digit\n    for _ in range(n):\n        # Multiply the remainder by 10 to shift the decimal point\n        remainder *= 10\n        \n        # Find the next digit in the decimal representation\n        digit = remainder // denominator\n        \n        # Update the remainder\n        remainder %= denominator\n    \n    return digit\n\n# Example usage:\nnumerator = 1\ndenominator = 3\nn = 5\nprint(find_nth_digit(numerator, denominator, n))  # Output: 3, because 1/3 = 0.33333...\n\n\n",
        "base_tests": [
            "assert find_nth_digit(1,2,1) == 5",
            "assert find_nth_digit(3,5,1) == 6",
            "assert find_nth_digit(5,6,5) == 3"
        ],
        "tests": [
            "assert find_nth_digit.__annotations__ == {'p': int, 'q': int, 'N': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.",
        "instruction": "The function should have a cyclomatic complexity of 5 or less to ensure maintainability.",
        "code_before": "def find_nth_digit(numerator, denominator, n):\n    \"\"\"\n    This function finds the nth digit in the decimal representation of the fraction numerator/denominator.\n    \n    :param numerator: The numerator of the fraction.\n    :param denominator: The denominator of the fraction.\n    :param n: The position of the digit to be found in the decimal representation.\n    :return: The nth digit in the decimal representation of the fraction.\n    \"\"\"\n    # Ensure the fraction is a proper fraction\n    if numerator >= denominator:\n        raise ValueError(\"The fraction must be a proper fraction (numerator < denominator).\")\n    \n    # Initialize the remainder\n    remainder = numerator\n    \n    # Loop until we find the nth digit\n    for _ in range(n):\n        # Multiply the remainder by 10 to shift the decimal point\n        remainder *= 10\n        \n        # Find the next digit in the decimal representation\n        digit = remainder // denominator\n        \n        # Update the remainder\n        remainder %= denominator\n    \n    return digit\n\n# Example usage:\nnumerator = 1\ndenominator = 3\nn = 5\nprint(find_nth_digit(numerator, denominator, n))  # Output: 3, because 1/3 = 0.33333...\n\n\n",
        "base_tests": [
            "assert find_nth_digit(1,2,1) == 5",
            "assert find_nth_digit(3,5,1) == 6",
            "assert find_nth_digit(5,6,5) == 3"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(find_nth_digit))[0].complexity <= 5"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation, naming conventions, and spacing.",
        "code_before": "def find_nth_digit(numerator, denominator, n):\n    \"\"\"\n    This function finds the nth digit in the decimal representation of the fraction numerator/denominator.\n    \n    :param numerator: The numerator of the fraction.\n    :param denominator: The denominator of the fraction.\n    :param n: The position of the digit to be found in the decimal representation.\n    :return: The nth digit in the decimal representation of the fraction.\n    \"\"\"\n    # Ensure the fraction is a proper fraction\n    if numerator >= denominator:\n        raise ValueError(\"The fraction must be a proper fraction (numerator < denominator).\")\n    \n    # Initialize the remainder\n    remainder = numerator\n    \n    # Loop until we find the nth digit\n    for _ in range(n):\n        # Multiply the remainder by 10 to shift the decimal point\n        remainder *= 10\n        \n        # Find the next digit in the decimal representation\n        digit = remainder // denominator\n        \n        # Update the remainder\n        remainder %= denominator\n    \n    return digit\n\n# Example usage:\nnumerator = 1\ndenominator = 3\nn = 5\nprint(find_nth_digit(numerator, denominator, n))  # Output: 3, because 1/3 = 0.33333...\n\n\n",
        "base_tests": [
            "assert find_nth_digit(1,2,1) == 5",
            "assert find_nth_digit(3,5,1) == 6",
            "assert find_nth_digit(5,6,5) == 3"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_nth_digit)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'sort_mixed_list' to sort a given mixed list of integers and strings.",
        "instruction": "The function should raise a TypeError if the input is not a list or if the list contains elements that are neither integers nor strings.",
        "code_before": "def sort_mixed_list(mixed_list):\n    \"\"\"\n    Sorts a mixed list of integers and strings. Integers are sorted before strings, and within each type, the values are sorted in ascending order.\n    \n    Parameters:\n    mixed_list (list): A list containing both integers and strings.\n    \n    Returns:\n    list: A sorted list with integers first, followed by strings.\n    \"\"\"\n    # Separate integers and strings into two different lists\n    int_list = [item for item in mixed_list if isinstance(item, int)]\n    str_list = [item for item in mixed_list if isinstance(item, str)]\n    \n    # Sort each list individually\n    int_list.sort()\n    str_list.sort()\n    \n    # Concatenate the sorted integer list with the sorted string list\n    return int_list + str_list\n\n# Example usage:\nmixed_list = [3, 'banana', 1, 'apple', 2, 'cherry']\nsorted_list = sort_mixed_list(mixed_list)\nprint(sorted_list)  # Output: [1, 2, 3, 'apple', 'banana', 'cherry']\n\n\n",
        "base_tests": [
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"
        ],
        "tests": [
            "try:\n    sort_mixed_list('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'Expected TypeError'\n\ntry:\n    sort_mixed_list([1, 'apple', 3.5])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'Expected TypeError'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'sort_mixed_list' to sort a given mixed list of integers and strings.",
        "instruction": "The function should correctly handle an empty list by returning an empty list.",
        "code_before": "def sort_mixed_list(mixed_list):\n    \"\"\"\n    Sorts a mixed list of integers and strings. Integers are sorted before strings, and within each type, the values are sorted in ascending order.\n    \n    Parameters:\n    mixed_list (list): A list containing both integers and strings.\n    \n    Returns:\n    list: A sorted list with integers first, followed by strings.\n    \"\"\"\n    # Separate integers and strings into two different lists\n    int_list = [item for item in mixed_list if isinstance(item, int)]\n    str_list = [item for item in mixed_list if isinstance(item, str)]\n    \n    # Sort each list individually\n    int_list.sort()\n    str_list.sort()\n    \n    # Concatenate the sorted integer list with the sorted string list\n    return int_list + str_list\n\n# Example usage:\nmixed_list = [3, 'banana', 1, 'apple', 2, 'cherry']\nsorted_list = sort_mixed_list(mixed_list)\nprint(sorted_list)  # Output: [1, 2, 3, 'apple', 'banana', 'cherry']\n\n\n",
        "base_tests": [
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"
        ],
        "tests": [
            "assert sort_mixed_list([]) == []"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'sort_mixed_list' to sort a given mixed list of integers and strings.",
        "instruction": "Extend the function to optionally sort strings in reverse lexicographical order if a parameter 'reverse_strings' is set to True.",
        "code_before": "def sort_mixed_list(mixed_list):\n    \"\"\"\n    Sorts a mixed list of integers and strings. Integers are sorted before strings, and within each type, the values are sorted in ascending order.\n    \n    Parameters:\n    mixed_list (list): A list containing both integers and strings.\n    \n    Returns:\n    list: A sorted list with integers first, followed by strings.\n    \"\"\"\n    # Separate integers and strings into two different lists\n    int_list = [item for item in mixed_list if isinstance(item, int)]\n    str_list = [item for item in mixed_list if isinstance(item, str)]\n    \n    # Sort each list individually\n    int_list.sort()\n    str_list.sort()\n    \n    # Concatenate the sorted integer list with the sorted string list\n    return int_list + str_list\n\n# Example usage:\nmixed_list = [3, 'banana', 1, 'apple', 2, 'cherry']\nsorted_list = sort_mixed_list(mixed_list)\nprint(sorted_list)  # Output: [1, 2, 3, 'apple', 'banana', 'cherry']\n\n\n",
        "base_tests": [
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"
        ],
        "tests": [
            "assert sort_mixed_list([3, 'banana', 2, 'apple', 1, 'cherry'], reverse_strings=True) == [1, 2, 3, 'cherry', 'banana', 'apple']"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'sort_mixed_list' to sort a given mixed list of integers and strings.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'mixed_list': list[Union[int, str]], and the return type should be annotated as list[Union[int, str]].",
        "code_before": "def sort_mixed_list(mixed_list):\n    \"\"\"\n    Sorts a mixed list of integers and strings. Integers are sorted before strings, and within each type, the values are sorted in ascending order.\n    \n    Parameters:\n    mixed_list (list): A list containing both integers and strings.\n    \n    Returns:\n    list: A sorted list with integers first, followed by strings.\n    \"\"\"\n    # Separate integers and strings into two different lists\n    int_list = [item for item in mixed_list if isinstance(item, int)]\n    str_list = [item for item in mixed_list if isinstance(item, str)]\n    \n    # Sort each list individually\n    int_list.sort()\n    str_list.sort()\n    \n    # Concatenate the sorted integer list with the sorted string list\n    return int_list + str_list\n\n# Example usage:\nmixed_list = [3, 'banana', 1, 'apple', 2, 'cherry']\nsorted_list = sort_mixed_list(mixed_list)\nprint(sorted_list)  # Output: [1, 2, 3, 'apple', 'banana', 'cherry']\n\n\n",
        "base_tests": [
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"
        ],
        "tests": [
            "from typing import Union\nassert sort_mixed_list.__annotations__ == {'mixed_list': list[Union[int, str]], 'return' : list}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'sort_mixed_list' to sort a given mixed list of integers and strings.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def sort_mixed_list(mixed_list):\n    \"\"\"\n    Sorts a mixed list of integers and strings. Integers are sorted before strings, and within each type, the values are sorted in ascending order.\n    \n    Parameters:\n    mixed_list (list): A list containing both integers and strings.\n    \n    Returns:\n    list: A sorted list with integers first, followed by strings.\n    \"\"\"\n    # Separate integers and strings into two different lists\n    int_list = [item for item in mixed_list if isinstance(item, int)]\n    str_list = [item for item in mixed_list if isinstance(item, str)]\n    \n    # Sort each list individually\n    int_list.sort()\n    str_list.sort()\n    \n    # Concatenate the sorted integer list with the sorted string list\n    return int_list + str_list\n\n# Example usage:\nmixed_list = [3, 'banana', 1, 'apple', 2, 'cherry']\nsorted_list = sort_mixed_list(mixed_list)\nprint(sorted_list)  # Output: [1, 2, 3, 'apple', 'banana', 'cherry']\n\n\n",
        "base_tests": [
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']",
            "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(sort_mixed_list)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.",
        "instruction": "The function should accept a list of integers and return a float or integer representing the division of the first even number by the first odd number.",
        "code_before": "def div_even_odd(lst):\n    \"\"\"\n    This function takes a list of integers as input and returns the division of the first even number by the first odd number in the list.\n    If there is no even or odd number in the list, it returns None.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n            \n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        return None\n    else:\n        return first_even / first_odd\n\n# Test the function\nprint(div_even_odd([1, 3, 5, 2, 4, 6]))  # Output: 0.6666666666666666\nprint(div_even_odd([2, 4, 6, 8]))        # Output: None\nprint(div_even_odd([1, 3, 5, 7]))        # Output: None\nprint(div_even_odd([1, 2, 3, 4, 5]))     # Output: 0.6666666666666666\n\n\n",
        "base_tests": [
            "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
            "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
            "assert div_even_odd([1,5,7,9,10])==10"
        ],
        "tests": [
            "assert isinstance(div_even_odd([2, 3, 4, 5]), (int, float))"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.",
        "instruction": "The function should raise a ValueError with a descriptive message as 'List must contain at least one even and one odd number.' if the list does not contain at least one even and one odd number.",
        "code_before": "def div_even_odd(lst):\n    \"\"\"\n    This function takes a list of integers as input and returns the division of the first even number by the first odd number in the list.\n    If there is no even or odd number in the list, it returns None.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n            \n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        return None\n    else:\n        return first_even / first_odd\n\n# Test the function\nprint(div_even_odd([1, 3, 5, 2, 4, 6]))  # Output: 0.6666666666666666\nprint(div_even_odd([2, 4, 6, 8]))        # Output: None\nprint(div_even_odd([1, 3, 5, 7]))        # Output: None\nprint(div_even_odd([1, 2, 3, 4, 5]))     # Output: 0.6666666666666666\n\n\n",
        "base_tests": [
            "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
            "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
            "assert div_even_odd([1,5,7,9,10])==10"
        ],
        "tests": [
            "try:\n    div_even_odd([2, 4, 6])\n    assert False\nexcept ValueError as e: assert str(e) == 'List must contain at least one even and one odd number.'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.",
        "instruction": "The function should correctly handle lists where the first even or odd number is zero, returning zero if the first even number is zero.",
        "code_before": "def div_even_odd(lst):\n    \"\"\"\n    This function takes a list of integers as input and returns the division of the first even number by the first odd number in the list.\n    If there is no even or odd number in the list, it returns None.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n            \n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        return None\n    else:\n        return first_even / first_odd\n\n# Test the function\nprint(div_even_odd([1, 3, 5, 2, 4, 6]))  # Output: 0.6666666666666666\nprint(div_even_odd([2, 4, 6, 8]))        # Output: None\nprint(div_even_odd([1, 3, 5, 7]))        # Output: None\nprint(div_even_odd([1, 2, 3, 4, 5]))     # Output: 0.6666666666666666\n\n\n",
        "base_tests": [
            "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
            "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
            "assert div_even_odd([1,5,7,9,10])==10"
        ],
        "tests": [
            "assert div_even_odd([0, 1, 2, 3]) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.",
        "instruction": "Extend the function to handle lists with negative numbers, correctly performing division with negative values.",
        "code_before": "def div_even_odd(lst):\n    \"\"\"\n    This function takes a list of integers as input and returns the division of the first even number by the first odd number in the list.\n    If there is no even or odd number in the list, it returns None.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n            \n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        return None\n    else:\n        return first_even / first_odd\n\n# Test the function\nprint(div_even_odd([1, 3, 5, 2, 4, 6]))  # Output: 0.6666666666666666\nprint(div_even_odd([2, 4, 6, 8]))        # Output: None\nprint(div_even_odd([1, 3, 5, 7]))        # Output: None\nprint(div_even_odd([1, 2, 3, 4, 5]))     # Output: 0.6666666666666666\n\n\n",
        "base_tests": [
            "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
            "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
            "assert div_even_odd([1,5,7,9,10])==10"
        ],
        "tests": [
            "assert div_even_odd([-2, 3, 4, 5]) == -2 / 3"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'list1': list, and a return type: (int, float).",
        "code_before": "def div_even_odd(lst):\n    \"\"\"\n    This function takes a list of integers as input and returns the division of the first even number by the first odd number in the list.\n    If there is no even or odd number in the list, it returns None.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n            \n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        return None\n    else:\n        return first_even / first_odd\n\n# Test the function\nprint(div_even_odd([1, 3, 5, 2, 4, 6]))  # Output: 0.6666666666666666\nprint(div_even_odd([2, 4, 6, 8]))        # Output: None\nprint(div_even_odd([1, 3, 5, 7]))        # Output: None\nprint(div_even_odd([1, 2, 3, 4, 5]))     # Output: 0.6666666666666666\n\n\n",
        "base_tests": [
            "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
            "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
            "assert div_even_odd([1,5,7,9,10])==10"
        ],
        "tests": [
            "assert div_even_odd.__annotations__ == {'list1': list, 'return': (int, float)}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.",
        "instruction": "The function should have a cyclomatic complexity of 3 or less.",
        "code_before": "def div_even_odd(lst):\n    \"\"\"\n    This function takes a list of integers as input and returns the division of the first even number by the first odd number in the list.\n    If there is no even or odd number in the list, it returns None.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n            \n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        return None\n    else:\n        return first_even / first_odd\n\n# Test the function\nprint(div_even_odd([1, 3, 5, 2, 4, 6]))  # Output: 0.6666666666666666\nprint(div_even_odd([2, 4, 6, 8]))        # Output: None\nprint(div_even_odd([1, 3, 5, 7]))        # Output: None\nprint(div_even_odd([1, 2, 3, 4, 5]))     # Output: 0.6666666666666666\n\n\n",
        "base_tests": [
            "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
            "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
            "assert div_even_odd([1,5,7,9,10])==10"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(div_even_odd))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation and spacing.",
        "code_before": "def div_even_odd(lst):\n    \"\"\"\n    This function takes a list of integers as input and returns the division of the first even number by the first odd number in the list.\n    If there is no even or odd number in the list, it returns None.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n            \n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        return None\n    else:\n        return first_even / first_odd\n\n# Test the function\nprint(div_even_odd([1, 3, 5, 2, 4, 6]))  # Output: 0.6666666666666666\nprint(div_even_odd([2, 4, 6, 8]))        # Output: None\nprint(div_even_odd([1, 3, 5, 7]))        # Output: None\nprint(div_even_odd([1, 2, 3, 4, 5]))     # Output: 0.6666666666666666\n\n\n",
        "base_tests": [
            "assert div_even_odd([1,3,5,7,4,1,6,8])==4",
            "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2",
            "assert div_even_odd([1,5,7,9,10])==10"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(div_even_odd)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function  called 'rearange_string' to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
        "instruction": "The function should accept a string as input and return a string where no two adjacent characters are the same. The input should be a non-empty string consisting only of lowercase letters.",
        "code_before": "from collections import Counter\n\ndef rearrange_string(s):\n    # Count the frequency of each character\n    char_count = Counter(s)\n    \n    # Find the character with the maximum frequency\n    max_freq = max(char_count.values())\n    \n    # If the maximum frequency is more than half the length of the string plus one, \n    # it's not possible to rearrange the string to meet the condition\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    \n    # Create a list from the character count\n    char_list = []\n    for char, count in char_count.items():\n        char_list.extend([char] * count)\n    \n    # Sort the list in descending order of frequency\n    char_list.sort(key=lambda x: -char_count[x])\n    \n    # Initialize the result list\n    result = [None] * len(s)\n    \n    # Place the most frequent character first\n    index = 0\n    for char in char_list:\n        if index >= len(s):\n            index = 1  # If we reach the end, start placing at the second position\n        result[index] = char\n        index += 2\n    \n    return ''.join(result)\n\n# Test the function\nprint(rearrange_string(\"aabb\"))  # Output: \"abab\" or \"baba\"\nprint(rearrange_string(\"aaab\"))  # Output: \"\"\n\n\n",
        "base_tests": [
            "assert rearange_string(\"aab\")==('aba')",
            "assert rearange_string(\"aabb\")==('abab')",
            "assert rearange_string(\"abccdd\")==('cdabcd')"
        ],
        "tests": [
            "assert isinstance(rearange_string('abc'), str)\nassert rearange_string('') == ''"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function  called 'rearange_string' to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
        "instruction": "The function should raise a ValueError if the input is not a string or if it contains characters other than lowercase letters.",
        "code_before": "from collections import Counter\n\ndef rearrange_string(s):\n    # Count the frequency of each character\n    char_count = Counter(s)\n    \n    # Find the character with the maximum frequency\n    max_freq = max(char_count.values())\n    \n    # If the maximum frequency is more than half the length of the string plus one, \n    # it's not possible to rearrange the string to meet the condition\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    \n    # Create a list from the character count\n    char_list = []\n    for char, count in char_count.items():\n        char_list.extend([char] * count)\n    \n    # Sort the list in descending order of frequency\n    char_list.sort(key=lambda x: -char_count[x])\n    \n    # Initialize the result list\n    result = [None] * len(s)\n    \n    # Place the most frequent character first\n    index = 0\n    for char in char_list:\n        if index >= len(s):\n            index = 1  # If we reach the end, start placing at the second position\n        result[index] = char\n        index += 2\n    \n    return ''.join(result)\n\n# Test the function\nprint(rearrange_string(\"aabb\"))  # Output: \"abab\" or \"baba\"\nprint(rearrange_string(\"aaab\"))  # Output: \"\"\n\n\n",
        "base_tests": [
            "assert rearange_string(\"aab\")==('aba')",
            "assert rearange_string(\"aabb\")==('abab')",
            "assert rearange_string(\"abccdd\")==('cdabcd')"
        ],
        "tests": [
            "try:\n    rearange_string(123)\nexcept ValueError:\n    pass\nelse:\n    assert False\ntry:\n    rearange_string('abc123')\nexcept ValueError:\n    pass\nelse:\n    assert False"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function  called 'rearange_string' to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
        "instruction": "The function should handle edge cases such as strings with all identical characters by returning an empty string, as rearrangement is not possible.",
        "code_before": "from collections import Counter\n\ndef rearrange_string(s):\n    # Count the frequency of each character\n    char_count = Counter(s)\n    \n    # Find the character with the maximum frequency\n    max_freq = max(char_count.values())\n    \n    # If the maximum frequency is more than half the length of the string plus one, \n    # it's not possible to rearrange the string to meet the condition\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    \n    # Create a list from the character count\n    char_list = []\n    for char, count in char_count.items():\n        char_list.extend([char] * count)\n    \n    # Sort the list in descending order of frequency\n    char_list.sort(key=lambda x: -char_count[x])\n    \n    # Initialize the result list\n    result = [None] * len(s)\n    \n    # Place the most frequent character first\n    index = 0\n    for char in char_list:\n        if index >= len(s):\n            index = 1  # If we reach the end, start placing at the second position\n        result[index] = char\n        index += 2\n    \n    return ''.join(result)\n\n# Test the function\nprint(rearrange_string(\"aabb\"))  # Output: \"abab\" or \"baba\"\nprint(rearrange_string(\"aaab\"))  # Output: \"\"\n\n\n",
        "base_tests": [
            "assert rearange_string(\"aab\")==('aba')",
            "assert rearange_string(\"aabb\")==('abab')",
            "assert rearange_string(\"abccdd\")==('cdabcd')"
        ],
        "tests": [
            "assert rearange_string('aaaa') == ''\nassert rearange_string('') == ''"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function  called 'rearange_string' to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
        "instruction": "Extend the function to return all possible valid rearrangements if more than one exists.",
        "code_before": "from collections import Counter\n\ndef rearrange_string(s):\n    # Count the frequency of each character\n    char_count = Counter(s)\n    \n    # Find the character with the maximum frequency\n    max_freq = max(char_count.values())\n    \n    # If the maximum frequency is more than half the length of the string plus one, \n    # it's not possible to rearrange the string to meet the condition\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    \n    # Create a list from the character count\n    char_list = []\n    for char, count in char_count.items():\n        char_list.extend([char] * count)\n    \n    # Sort the list in descending order of frequency\n    char_list.sort(key=lambda x: -char_count[x])\n    \n    # Initialize the result list\n    result = [None] * len(s)\n    \n    # Place the most frequent character first\n    index = 0\n    for char in char_list:\n        if index >= len(s):\n            index = 1  # If we reach the end, start placing at the second position\n        result[index] = char\n        index += 2\n    \n    return ''.join(result)\n\n# Test the function\nprint(rearrange_string(\"aabb\"))  # Output: \"abab\" or \"baba\"\nprint(rearrange_string(\"aaab\"))  # Output: \"\"\n\n\n",
        "base_tests": [
            "assert rearange_string(\"aab\")==('aba')",
            "assert rearange_string(\"aabb\")==('abab')",
            "assert rearange_string(\"abccdd\")==('cdabcd')"
        ],
        "tests": [
            "assert set(rearange_string('aabb')) == {'abab', 'baba'}"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function  called 'rearange_string' to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'S': str, and a return type: str, and should have a docstring explaining its purpose and usage: 'Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.'",
        "code_before": "from collections import Counter\n\ndef rearrange_string(s):\n    # Count the frequency of each character\n    char_count = Counter(s)\n    \n    # Find the character with the maximum frequency\n    max_freq = max(char_count.values())\n    \n    # If the maximum frequency is more than half the length of the string plus one, \n    # it's not possible to rearrange the string to meet the condition\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    \n    # Create a list from the character count\n    char_list = []\n    for char, count in char_count.items():\n        char_list.extend([char] * count)\n    \n    # Sort the list in descending order of frequency\n    char_list.sort(key=lambda x: -char_count[x])\n    \n    # Initialize the result list\n    result = [None] * len(s)\n    \n    # Place the most frequent character first\n    index = 0\n    for char in char_list:\n        if index >= len(s):\n            index = 1  # If we reach the end, start placing at the second position\n        result[index] = char\n        index += 2\n    \n    return ''.join(result)\n\n# Test the function\nprint(rearrange_string(\"aabb\"))  # Output: \"abab\" or \"baba\"\nprint(rearrange_string(\"aaab\"))  # Output: \"\"\n\n\n",
        "base_tests": [
            "assert rearange_string(\"aab\")==('aba')",
            "assert rearange_string(\"aabb\")==('abab')",
            "assert rearange_string(\"abccdd\")==('cdabcd')"
        ],
        "tests": [
            "assert rearange_string.__annotations__ == {'S': str, 'return': str}\nassert rearange_string.__doc__ == 'Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.'"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function  called 'rearange_string' to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.",
        "instruction": "The code should adhere to PEP 8 standards, including proper indentation, spacing, and naming conventions.",
        "code_before": "from collections import Counter\n\ndef rearrange_string(s):\n    # Count the frequency of each character\n    char_count = Counter(s)\n    \n    # Find the character with the maximum frequency\n    max_freq = max(char_count.values())\n    \n    # If the maximum frequency is more than half the length of the string plus one, \n    # it's not possible to rearrange the string to meet the condition\n    if max_freq > (len(s) + 1) // 2:\n        return \"\"\n    \n    # Create a list from the character count\n    char_list = []\n    for char, count in char_count.items():\n        char_list.extend([char] * count)\n    \n    # Sort the list in descending order of frequency\n    char_list.sort(key=lambda x: -char_count[x])\n    \n    # Initialize the result list\n    result = [None] * len(s)\n    \n    # Place the most frequent character first\n    index = 0\n    for char in char_list:\n        if index >= len(s):\n            index = 1  # If we reach the end, start placing at the second position\n        result[index] = char\n        index += 2\n    \n    return ''.join(result)\n\n# Test the function\nprint(rearrange_string(\"aabb\"))  # Output: \"abab\" or \"baba\"\nprint(rearrange_string(\"aaab\"))  # Output: \"\"\n\n\n",
        "base_tests": [
            "assert rearange_string(\"aab\")==('aba')",
            "assert rearange_string(\"aabb\")==('abab')",
            "assert rearange_string(\"abccdd\")==('cdabcd')"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(rearange_string)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'freq_element' to find frequency of the elements in a given list of lists using collections module.",
        "instruction": "The function should raise a TypeError if the input is not a list of lists.",
        "code_before": "from collections import Counter\n\ndef freq_element(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [element for sublist in list_of_lists for element in sublist]\n    \n    # Use Counter to count the frequency of each element in the flattened list\n    frequency = Counter(flattened_list)\n    \n    return frequency\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [2, 3, 4], [4, 5, 6], [1, 2, 3]]\nprint(freq_element(list_of_lists))\n\n\n",
        "base_tests": [
            "assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})",
            "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})",
            "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"
        ],
        "tests": [
            "try\n    freq_element('not a list')\n    assert False\nexcept TypeError: assert True"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'freq_element' to find frequency of the elements in a given list of lists using collections module.",
        "instruction": "The function should return an empty dictionary if the input is an empty list.",
        "code_before": "from collections import Counter\n\ndef freq_element(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [element for sublist in list_of_lists for element in sublist]\n    \n    # Use Counter to count the frequency of each element in the flattened list\n    frequency = Counter(flattened_list)\n    \n    return frequency\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [2, 3, 4], [4, 5, 6], [1, 2, 3]]\nprint(freq_element(list_of_lists))\n\n\n",
        "base_tests": [
            "assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})",
            "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})",
            "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"
        ],
        "tests": [
            "assert freq_element([]) == {}"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'freq_element' to find frequency of the elements in a given list of lists using collections module.",
        "instruction": "Extend the function to handle nested lists of arbitrary depth and return the frequency of all integers.",
        "code_before": "from collections import Counter\n\ndef freq_element(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [element for sublist in list_of_lists for element in sublist]\n    \n    # Use Counter to count the frequency of each element in the flattened list\n    frequency = Counter(flattened_list)\n    \n    return frequency\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [2, 3, 4], [4, 5, 6], [1, 2, 3]]\nprint(freq_element(list_of_lists))\n\n\n",
        "base_tests": [
            "assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})",
            "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})",
            "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"
        ],
        "tests": [
            "assert freq_element([[1, [2, [3, 2]], 2], [4, 5, [6, 2]], [7, 1, [9, 5]]]) == {1: 2, 2: 4, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 9: 1}"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'freq_element' to find frequency of the elements in a given list of lists using collections module.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'nums': list[list[int]], and the return type should be annotated as dict[int, int].",
        "code_before": "from collections import Counter\n\ndef freq_element(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [element for sublist in list_of_lists for element in sublist]\n    \n    # Use Counter to count the frequency of each element in the flattened list\n    frequency = Counter(flattened_list)\n    \n    return frequency\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [2, 3, 4], [4, 5, 6], [1, 2, 3]]\nprint(freq_element(list_of_lists))\n\n\n",
        "base_tests": [
            "assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})",
            "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})",
            "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"
        ],
        "tests": [
            "assert freq_element.__annotations__ == {'nums': 'list[list[int]]', 'return': 'dict[int, int]'}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'freq_element' to find frequency of the elements in a given list of lists using collections module.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a single path through the code.",
        "code_before": "from collections import Counter\n\ndef freq_element(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [element for sublist in list_of_lists for element in sublist]\n    \n    # Use Counter to count the frequency of each element in the flattened list\n    frequency = Counter(flattened_list)\n    \n    return frequency\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [2, 3, 4], [4, 5, 6], [1, 2, 3]]\nprint(freq_element(list_of_lists))\n\n\n",
        "base_tests": [
            "assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})",
            "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})",
            "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(freq_element))[0].complexity == 1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'freq_element' to find frequency of the elements in a given list of lists using collections module.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation and spacing.",
        "code_before": "from collections import Counter\n\ndef freq_element(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [element for sublist in list_of_lists for element in sublist]\n    \n    # Use Counter to count the frequency of each element in the flattened list\n    frequency = Counter(flattened_list)\n    \n    return frequency\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [2, 3, 4], [4, 5, 6], [1, 2, 3]]\nprint(freq_element(list_of_lists))\n\n\n",
        "base_tests": [
            "assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})",
            "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})",
            "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(freq_element)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'filter_evennumbers' to filter even numbers using lambda function.",
        "instruction": "The function should raise a TypeError if the input is not a list of integers.",
        "code_before": "def filter_evennumbers(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a new list containing only the even numbers.\n    \n    :param numbers: List of integers\n    :return: List of even integers\n    \"\"\"\n    even_numbers = list(filter(lambda x: x % 2 == 0, numbers))\n    return even_numbers\n\n# Example usage:\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(filter_evennumbers(numbers))  # Output: [2, 4, 6, 8, 10]\n\n\n",
        "base_tests": [
            "assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]",
            "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]",
            "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]"
        ],
        "tests": [
            "try: filter_evennumbers('not a list')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'filter_evennumbers' to filter even numbers using lambda function.",
        "instruction": "The function should return an empty list if the input list is empty.",
        "code_before": "def filter_evennumbers(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a new list containing only the even numbers.\n    \n    :param numbers: List of integers\n    :return: List of even integers\n    \"\"\"\n    even_numbers = list(filter(lambda x: x % 2 == 0, numbers))\n    return even_numbers\n\n# Example usage:\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(filter_evennumbers(numbers))  # Output: [2, 4, 6, 8, 10]\n\n\n",
        "base_tests": [
            "assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]",
            "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]",
            "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]"
        ],
        "tests": [
            "assert filter_evennumbers([]) == []"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'filter_evennumbers' to filter even numbers using lambda function.",
        "instruction": "Extend the function to handle lists containing non-integer types by filtering them out before processing.",
        "code_before": "def filter_evennumbers(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a new list containing only the even numbers.\n    \n    :param numbers: List of integers\n    :return: List of even integers\n    \"\"\"\n    even_numbers = list(filter(lambda x: x % 2 == 0, numbers))\n    return even_numbers\n\n# Example usage:\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(filter_evennumbers(numbers))  # Output: [2, 4, 6, 8, 10]\n\n\n",
        "base_tests": [
            "assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]",
            "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]",
            "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]"
        ],
        "tests": [
            "assert filter_evennumbers([2, 'a', 4.5, 6, 'b']) == [2, 6]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'filter_evennumbers' to filter even numbers using lambda function.",
        "instruction": "The function should include type annotations for its parameters and return type, including parameters: 'nums': list, and a return type: list.",
        "code_before": "def filter_evennumbers(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a new list containing only the even numbers.\n    \n    :param numbers: List of integers\n    :return: List of even integers\n    \"\"\"\n    even_numbers = list(filter(lambda x: x % 2 == 0, numbers))\n    return even_numbers\n\n# Example usage:\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(filter_evennumbers(numbers))  # Output: [2, 4, 6, 8, 10]\n\n\n",
        "base_tests": [
            "assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]",
            "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]",
            "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]"
        ],
        "tests": [
            "assert filter_evennumbers.__annotations__ == {'nums': list, 'return': list}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'filter_evennumbers' to filter even numbers using lambda function.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def filter_evennumbers(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a new list containing only the even numbers.\n    \n    :param numbers: List of integers\n    :return: List of even integers\n    \"\"\"\n    even_numbers = list(filter(lambda x: x % 2 == 0, numbers))\n    return even_numbers\n\n# Example usage:\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(filter_evennumbers(numbers))  # Output: [2, 4, 6, 8, 10]\n\n\n",
        "base_tests": [
            "assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]",
            "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]",
            "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(filter_evennumbers)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.",
        "instruction": "The function should return 0 if there are no repeated elements in the array.",
        "code_before": "def find_sum(arr):\n    \"\"\"\n    This function takes a list of integers as input and returns the sum of elements that appear more than once in the list.\n    \n    :param arr: List of integers\n    :return: Sum of repeated elements\n    \"\"\"\n    from collections import Counter\n    \n    # Count the occurrences of each element in the array\n    element_counts = Counter(arr)\n    \n    # Calculate the sum of elements that appear more than once\n    repeated_sum = sum(element * count for element, count in element_counts.items() if count > 1)\n    \n    return repeated_sum\n\n# Example usage:\narr = [1, 2, 3, 2, 4, 5, 6, 3, 3]\nprint(find_sum(arr))  # Output: 13 (2 appears twice, 3 appears three times, so 2*2 + 3*3 = 4 + 9 = 13)\n\n\n",
        "base_tests": [
            "assert find_sum([1,2,3,1,1,4,5,6],8) == 3",
            "assert find_sum([1,2,3,1,1],5) == 3",
            "assert find_sum([1,1,2],3) == 2"
        ],
        "tests": [
            "assert find_sum([1, 2, 3, 4, 5], 5) == 0"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.",
        "instruction": "The function should raise a TypeError if the input is not a list.",
        "code_before": "def find_sum(arr):\n    \"\"\"\n    This function takes a list of integers as input and returns the sum of elements that appear more than once in the list.\n    \n    :param arr: List of integers\n    :return: Sum of repeated elements\n    \"\"\"\n    from collections import Counter\n    \n    # Count the occurrences of each element in the array\n    element_counts = Counter(arr)\n    \n    # Calculate the sum of elements that appear more than once\n    repeated_sum = sum(element * count for element, count in element_counts.items() if count > 1)\n    \n    return repeated_sum\n\n# Example usage:\narr = [1, 2, 3, 2, 4, 5, 6, 3, 3]\nprint(find_sum(arr))  # Output: 13 (2 appears twice, 3 appears three times, so 2*2 + 3*3 = 4 + 9 = 13)\n\n\n",
        "base_tests": [
            "assert find_sum([1,2,3,1,1,4,5,6],8) == 3",
            "assert find_sum([1,2,3,1,1],5) == 3",
            "assert find_sum([1,1,2],3) == 2"
        ],
        "tests": [
            "try:\n    find_sum('not a list', 5)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.",
        "instruction": "The function should handle an empty array and return 0.",
        "code_before": "def find_sum(arr):\n    \"\"\"\n    This function takes a list of integers as input and returns the sum of elements that appear more than once in the list.\n    \n    :param arr: List of integers\n    :return: Sum of repeated elements\n    \"\"\"\n    from collections import Counter\n    \n    # Count the occurrences of each element in the array\n    element_counts = Counter(arr)\n    \n    # Calculate the sum of elements that appear more than once\n    repeated_sum = sum(element * count for element, count in element_counts.items() if count > 1)\n    \n    return repeated_sum\n\n# Example usage:\narr = [1, 2, 3, 2, 4, 5, 6, 3, 3]\nprint(find_sum(arr))  # Output: 13 (2 appears twice, 3 appears three times, so 2*2 + 3*3 = 4 + 9 = 13)\n\n\n",
        "base_tests": [
            "assert find_sum([1,2,3,1,1,4,5,6],8) == 3",
            "assert find_sum([1,2,3,1,1],5) == 3",
            "assert find_sum([1,1,2],3) == 2"
        ],
        "tests": [
            "assert find_sum([], 0) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.",
        "instruction": "The function should be able to handle arrays with negative numbers and return the correct sum of repeated elements.",
        "code_before": "def find_sum(arr):\n    \"\"\"\n    This function takes a list of integers as input and returns the sum of elements that appear more than once in the list.\n    \n    :param arr: List of integers\n    :return: Sum of repeated elements\n    \"\"\"\n    from collections import Counter\n    \n    # Count the occurrences of each element in the array\n    element_counts = Counter(arr)\n    \n    # Calculate the sum of elements that appear more than once\n    repeated_sum = sum(element * count for element, count in element_counts.items() if count > 1)\n    \n    return repeated_sum\n\n# Example usage:\narr = [1, 2, 3, 2, 4, 5, 6, 3, 3]\nprint(find_sum(arr))  # Output: 13 (2 appears twice, 3 appears three times, so 2*2 + 3*3 = 4 + 9 = 13)\n\n\n",
        "base_tests": [
            "assert find_sum([1,2,3,1,1,4,5,6],8) == 3",
            "assert find_sum([1,2,3,1,1],5) == 3",
            "assert find_sum([1,1,2],3) == 2"
        ],
        "tests": [
            "assert find_sum([-1, -2, -3, -1, -1], 5) == -2"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'arr': list, 'n': int, and the return type should be annotated as int.",
        "code_before": "def find_sum(arr):\n    \"\"\"\n    This function takes a list of integers as input and returns the sum of elements that appear more than once in the list.\n    \n    :param arr: List of integers\n    :return: Sum of repeated elements\n    \"\"\"\n    from collections import Counter\n    \n    # Count the occurrences of each element in the array\n    element_counts = Counter(arr)\n    \n    # Calculate the sum of elements that appear more than once\n    repeated_sum = sum(element * count for element, count in element_counts.items() if count > 1)\n    \n    return repeated_sum\n\n# Example usage:\narr = [1, 2, 3, 2, 4, 5, 6, 3, 3]\nprint(find_sum(arr))  # Output: 13 (2 appears twice, 3 appears three times, so 2*2 + 3*3 = 4 + 9 = 13)\n\n\n",
        "base_tests": [
            "assert find_sum([1,2,3,1,1,4,5,6],8) == 3",
            "assert find_sum([1,2,3,1,1],5) == 3",
            "assert find_sum([1,1,2],3) == 2"
        ],
        "tests": [
            "assert 'def find_sum(arr: list, n: int) -> int:' in inspect.getsource(find_sum)"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.",
        "instruction": "The function should have a cyclomatic complexity of 5 or less.",
        "code_before": "def find_sum(arr):\n    \"\"\"\n    This function takes a list of integers as input and returns the sum of elements that appear more than once in the list.\n    \n    :param arr: List of integers\n    :return: Sum of repeated elements\n    \"\"\"\n    from collections import Counter\n    \n    # Count the occurrences of each element in the array\n    element_counts = Counter(arr)\n    \n    # Calculate the sum of elements that appear more than once\n    repeated_sum = sum(element * count for element, count in element_counts.items() if count > 1)\n    \n    return repeated_sum\n\n# Example usage:\narr = [1, 2, 3, 2, 4, 5, 6, 3, 3]\nprint(find_sum(arr))  # Output: 13 (2 appears twice, 3 appears three times, so 2*2 + 3*3 = 4 + 9 = 13)\n\n\n",
        "base_tests": [
            "assert find_sum([1,2,3,1,1,4,5,6],8) == 3",
            "assert find_sum([1,2,3,1,1],5) == 3",
            "assert find_sum([1,1,2],3) == 2"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(find_sum))[0].complexity <=5"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.",
        "instruction": "The function should adhere to PEP 8 style guidelines.",
        "code_before": "def find_sum(arr):\n    \"\"\"\n    This function takes a list of integers as input and returns the sum of elements that appear more than once in the list.\n    \n    :param arr: List of integers\n    :return: Sum of repeated elements\n    \"\"\"\n    from collections import Counter\n    \n    # Count the occurrences of each element in the array\n    element_counts = Counter(arr)\n    \n    # Calculate the sum of elements that appear more than once\n    repeated_sum = sum(element * count for element, count in element_counts.items() if count > 1)\n    \n    return repeated_sum\n\n# Example usage:\narr = [1, 2, 3, 2, 4, 5, 6, 3, 3]\nprint(find_sum(arr))  # Output: 13 (2 appears twice, 3 appears three times, so 2*2 + 3*3 = 4 + 9 = 13)\n\n\n",
        "base_tests": [
            "assert find_sum([1,2,3,1,1,4,5,6],8) == 3",
            "assert find_sum([1,2,3,1,1],5) == 3",
            "assert find_sum([1,1,2],3) == 2"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_sum)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.",
        "instruction": "The function should return 'Not matched!' for any input that does not contain sequences of lowercase letters joined by an underscore.",
        "code_before": "import re\n\ndef text_match(text):\n    # Define the regex pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+_[a-z]+$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n# Test the function\nprint(text_match(\"hello_world\"))  # Expected output: True\nprint(text_match(\"Hello_world\"))  # Expected output: False\nprint(text_match(\"hello_World\"))  # Expected output: False\nprint(text_match(\"hello_world_\")) # Expected output: False\nprint(text_match(\"hello\"))        # Expected output: False\n\n\n",
        "base_tests": [
            "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
            "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
            "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
        ],
        "tests": [
            "assert text_match('123_456') == 'Not matched!'"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.",
        "instruction": "The function should raise a TypeError if the input is not a string.",
        "code_before": "import re\n\ndef text_match(text):\n    # Define the regex pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+_[a-z]+$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n# Test the function\nprint(text_match(\"hello_world\"))  # Expected output: True\nprint(text_match(\"Hello_world\"))  # Expected output: False\nprint(text_match(\"hello_World\"))  # Expected output: False\nprint(text_match(\"hello_world_\")) # Expected output: False\nprint(text_match(\"hello\"))        # Expected output: False\n\n\n",
        "base_tests": [
            "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
            "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
            "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
        ],
        "tests": [
            "try:\n    text_match(12345)\nexcept TypeError:\n    assert True\nelse:\n    assert False"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.",
        "instruction": "The function should return 'Not matched!' for an empty string input.",
        "code_before": "import re\n\ndef text_match(text):\n    # Define the regex pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+_[a-z]+$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n# Test the function\nprint(text_match(\"hello_world\"))  # Expected output: True\nprint(text_match(\"Hello_world\"))  # Expected output: False\nprint(text_match(\"hello_World\"))  # Expected output: False\nprint(text_match(\"hello_world_\")) # Expected output: False\nprint(text_match(\"hello\"))        # Expected output: False\n\n\n",
        "base_tests": [
            "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
            "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
            "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
        ],
        "tests": [
            "assert text_match('') == 'Not matched!'"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.",
        "instruction": "Extend the function to handle sequences of lowercase letters joined by multiple underscores.",
        "code_before": "import re\n\ndef text_match(text):\n    # Define the regex pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+_[a-z]+$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n# Test the function\nprint(text_match(\"hello_world\"))  # Expected output: True\nprint(text_match(\"Hello_world\"))  # Expected output: False\nprint(text_match(\"hello_World\"))  # Expected output: False\nprint(text_match(\"hello_world_\")) # Expected output: False\nprint(text_match(\"hello\"))        # Expected output: False\n\n\n",
        "base_tests": [
            "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
            "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
            "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
        ],
        "tests": [
            "assert text_match('abc_def_ghi') == 'Found a match!'"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'text': str, and the return type should be annotated as str.",
        "code_before": "import re\n\ndef text_match(text):\n    # Define the regex pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+_[a-z]+$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n# Test the function\nprint(text_match(\"hello_world\"))  # Expected output: True\nprint(text_match(\"Hello_world\"))  # Expected output: False\nprint(text_match(\"hello_World\"))  # Expected output: False\nprint(text_match(\"hello_world_\")) # Expected output: False\nprint(text_match(\"hello\"))        # Expected output: False\n\n\n",
        "base_tests": [
            "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
            "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
            "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
        ],
        "tests": [
            "assert text_match.__annotations__ == {'text': str, 'return': str}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple linear flow.",
        "code_before": "import re\n\ndef text_match(text):\n    # Define the regex pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+_[a-z]+$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n# Test the function\nprint(text_match(\"hello_world\"))  # Expected output: True\nprint(text_match(\"Hello_world\"))  # Expected output: False\nprint(text_match(\"hello_World\"))  # Expected output: False\nprint(text_match(\"hello_world_\")) # Expected output: False\nprint(text_match(\"hello\"))        # Expected output: False\n\n\n",
        "base_tests": [
            "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
            "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
            "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(text_match))[0].complexity ==1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper indentation and spacing.",
        "code_before": "import re\n\ndef text_match(text):\n    # Define the regex pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+_[a-z]+$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n# Test the function\nprint(text_match(\"hello_world\"))  # Expected output: True\nprint(text_match(\"Hello_world\"))  # Expected output: False\nprint(text_match(\"hello_World\"))  # Expected output: False\nprint(text_match(\"hello_world_\")) # Expected output: False\nprint(text_match(\"hello\"))        # Expected output: False\n\n\n",
        "base_tests": [
            "assert text_match(\"aab_cbbbc\") == 'Found a match!'",
            "assert text_match(\"aab_Abbbc\") == 'Not matched!'",
            "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(cc_visit)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'text_match_string' that matches a word at the beginning of a string.",
        "instruction": "The function should raise a TypeError if the input is not a string.",
        "code_before": "import re\n\ndef text_match_string(text):\n    \"\"\"\n    This function checks if the given text starts with a word.\n    \n    Args:\n    text (str): The string to be checked.\n    \n    Returns:\n    bool: True if the text starts with a word, False otherwise.\n    \"\"\"\n    # Define the pattern to match word at the beginning of the string\n    pattern = '^\\w+'\n    \n    # Search for the pattern in the text\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n# Test the function\nprint(text_match_string(\"Hello world\"))  # Expected output: True\nprint(text_match_string(\" hello world\"))  # Expected output: False\nprint(text_match_string(\"123abc\"))  # Expected output: True\nprint(text_match_string(\"!@#abc\"))  # Expected output: False\n\n\n",
        "base_tests": [
            "assert text_match_string(\" python\")==('Not matched!')",
            "assert text_match_string(\"python\")==('Found a match!')",
            "assert text_match_string(\"  lang\")==('Not matched!')"
        ],
        "tests": [
            "try: text_match_string(123); assert False, 'TypeError not raised' except TypeError: pass",
            "try: text_match_string(None); assert False, 'TypeError not raised' except TypeError: pass"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'text_match_string' that matches a word at the beginning of a string.",
        "instruction": "The function should correctly handle edge cases such as an empty string or a string with only spaces.",
        "code_before": "import re\n\ndef text_match_string(text):\n    \"\"\"\n    This function checks if the given text starts with a word.\n    \n    Args:\n    text (str): The string to be checked.\n    \n    Returns:\n    bool: True if the text starts with a word, False otherwise.\n    \"\"\"\n    # Define the pattern to match word at the beginning of the string\n    pattern = '^\\w+'\n    \n    # Search for the pattern in the text\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n# Test the function\nprint(text_match_string(\"Hello world\"))  # Expected output: True\nprint(text_match_string(\" hello world\"))  # Expected output: False\nprint(text_match_string(\"123abc\"))  # Expected output: True\nprint(text_match_string(\"!@#abc\"))  # Expected output: False\n\n\n",
        "base_tests": [
            "assert text_match_string(\" python\")==('Not matched!')",
            "assert text_match_string(\"python\")==('Found a match!')",
            "assert text_match_string(\"  lang\")==('Not matched!')"
        ],
        "tests": [
            "assert text_match_string('') == 'Not matched!'",
            "assert text_match_string('   ') == 'Not matched!'"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'text_match_string' that matches a word at the beginning of a string.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'text': str, and the return type should be annotated as str.",
        "code_before": "import re\n\ndef text_match_string(text):\n    \"\"\"\n    This function checks if the given text starts with a word.\n    \n    Args:\n    text (str): The string to be checked.\n    \n    Returns:\n    bool: True if the text starts with a word, False otherwise.\n    \"\"\"\n    # Define the pattern to match word at the beginning of the string\n    pattern = '^\\w+'\n    \n    # Search for the pattern in the text\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n# Test the function\nprint(text_match_string(\"Hello world\"))  # Expected output: True\nprint(text_match_string(\" hello world\"))  # Expected output: False\nprint(text_match_string(\"123abc\"))  # Expected output: True\nprint(text_match_string(\"!@#abc\"))  # Expected output: False\n\n\n",
        "base_tests": [
            "assert text_match_string(\" python\")==('Not matched!')",
            "assert text_match_string(\"python\")==('Found a match!')",
            "assert text_match_string(\"  lang\")==('Not matched!')"
        ],
        "tests": [
            "assert text_match_string.__annotations__ == {'text': str, 'return': str}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'text_match_string' that matches a word at the beginning of a string.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "import re\n\ndef text_match_string(text):\n    \"\"\"\n    This function checks if the given text starts with a word.\n    \n    Args:\n    text (str): The string to be checked.\n    \n    Returns:\n    bool: True if the text starts with a word, False otherwise.\n    \"\"\"\n    # Define the pattern to match word at the beginning of the string\n    pattern = '^\\w+'\n    \n    # Search for the pattern in the text\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n# Test the function\nprint(text_match_string(\"Hello world\"))  # Expected output: True\nprint(text_match_string(\" hello world\"))  # Expected output: False\nprint(text_match_string(\"123abc\"))  # Expected output: True\nprint(text_match_string(\"!@#abc\"))  # Expected output: False\n\n\n",
        "base_tests": [
            "assert text_match_string(\" python\")==('Not matched!')",
            "assert text_match_string(\"python\")==('Found a match!')",
            "assert text_match_string(\"  lang\")==('Not matched!')"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(text_match_string)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'get_gcd' to find the gcd of the given array elements.",
        "instruction": "The function should raise a ValueError with error message 'Input list cannot be empty.' if the input list is empty.",
        "code_before": "from math import gcd\nfrom functools import reduce\n\ndef get_gcd(arr):\n    \"\"\"\n    This function takes an array of integers and returns the greatest common divisor (GCD) of the array elements.\n    \n    :param arr: List[int] - A list of integers\n    :return: int - The GCD of the array elements\n    \"\"\"\n    return reduce(gcd, arr)\n\n# Example usage:\narr = [48, 64, 80, 96]\nprint(get_gcd(arr))  # Output: 16\n\n\n",
        "base_tests": [
            "assert get_gcd([2, 4, 6, 8, 16]) == 2",
            "assert get_gcd([1, 2, 3]) == 1",
            "assert get_gcd([2, 4, 6, 8]) == 2 "
        ],
        "tests": [
            "try: get_gcd([])\nexcept ValueError as e: assert str(e) == 'Input list cannot be empty.'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'get_gcd' to find the gcd of the given array elements.",
        "instruction": "Extend the function to handle lists containing zero, returning the GCD of the non-zero elements.",
        "code_before": "from math import gcd\nfrom functools import reduce\n\ndef get_gcd(arr):\n    \"\"\"\n    This function takes an array of integers and returns the greatest common divisor (GCD) of the array elements.\n    \n    :param arr: List[int] - A list of integers\n    :return: int - The GCD of the array elements\n    \"\"\"\n    return reduce(gcd, arr)\n\n# Example usage:\narr = [48, 64, 80, 96]\nprint(get_gcd(arr))  # Output: 16\n\n\n",
        "base_tests": [
            "assert get_gcd([2, 4, 6, 8, 16]) == 2",
            "assert get_gcd([1, 2, 3]) == 1",
            "assert get_gcd([2, 4, 6, 8]) == 2 "
        ],
        "tests": [
            "assert get_gcd([0, 0, 6, 9]) == 3"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'get_gcd' to find the gcd of the given array elements.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'numbers': list, and the return type should be annotated as int.",
        "code_before": "from math import gcd\nfrom functools import reduce\n\ndef get_gcd(arr):\n    \"\"\"\n    This function takes an array of integers and returns the greatest common divisor (GCD) of the array elements.\n    \n    :param arr: List[int] - A list of integers\n    :return: int - The GCD of the array elements\n    \"\"\"\n    return reduce(gcd, arr)\n\n# Example usage:\narr = [48, 64, 80, 96]\nprint(get_gcd(arr))  # Output: 16\n\n\n",
        "base_tests": [
            "assert get_gcd([2, 4, 6, 8, 16]) == 2",
            "assert get_gcd([1, 2, 3]) == 1",
            "assert get_gcd([2, 4, 6, 8]) == 2 "
        ],
        "tests": [
            "assert get_gcd.__annotations__ == {'numbers': list, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'get_gcd' to find the gcd of the given array elements.",
        "instruction": "The function should have a cyclomatic complexity of no more than 5.",
        "code_before": "from math import gcd\nfrom functools import reduce\n\ndef get_gcd(arr):\n    \"\"\"\n    This function takes an array of integers and returns the greatest common divisor (GCD) of the array elements.\n    \n    :param arr: List[int] - A list of integers\n    :return: int - The GCD of the array elements\n    \"\"\"\n    return reduce(gcd, arr)\n\n# Example usage:\narr = [48, 64, 80, 96]\nprint(get_gcd(arr))  # Output: 16\n\n\n",
        "base_tests": [
            "assert get_gcd([2, 4, 6, 8, 16]) == 2",
            "assert get_gcd([1, 2, 3]) == 1",
            "assert get_gcd([2, 4, 6, 8]) == 2 "
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(get_gcd))[0].complexity <=1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'get_gcd' to find the gcd of the given array elements.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "from math import gcd\nfrom functools import reduce\n\ndef get_gcd(arr):\n    \"\"\"\n    This function takes an array of integers and returns the greatest common divisor (GCD) of the array elements.\n    \n    :param arr: List[int] - A list of integers\n    :return: int - The GCD of the array elements\n    \"\"\"\n    return reduce(gcd, arr)\n\n# Example usage:\narr = [48, 64, 80, 96]\nprint(get_gcd(arr))  # Output: 16\n\n\n",
        "base_tests": [
            "assert get_gcd([2, 4, 6, 8, 16]) == 2",
            "assert get_gcd([1, 2, 3]) == 1",
            "assert get_gcd([2, 4, 6, 8]) == 2 "
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(get_gcd)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'test_distinct' to determine whether all the numbers are different from each other are not.",
        "instruction": "The function should accept a list of integers as input and return a boolean indicating whether all numbers are distinct.",
        "code_before": "def test_distinct(numbers):\n    \"\"\"\n    This function checks if all the numbers in the given list are distinct.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    bool: True if all numbers are distinct, False otherwise.\n    \"\"\"\n    # Convert the list to a set. Sets automatically remove duplicates.\n    unique_numbers = set(numbers)\n    \n    # If the length of the set is the same as the length of the list,\n    # it means all numbers were distinct.\n    return len(unique_numbers) == len(numbers)\n\n# Example usage:\nprint(test_distinct([1, 2, 3, 4]))  # Output: True\nprint(test_distinct([1, 2, 2, 4]))  # Output: False\n\n\n",
        "base_tests": [
            "assert test_distinct([1,5,7,9]) == True",
            "assert test_distinct([2,4,5,5,7,9]) == False",
            "assert test_distinct([1,2,3]) == True"
        ],
        "tests": [
            "assert test_distinct([1, 2, 3, 4]) == True\nassert test_distinct([1, 1, 2, 3]) == False"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'test_distinct' to determine whether all the numbers are different from each other are not.",
        "instruction": "The function should raise a TypeError if the input is not a list or if the list contains non-integer elements.",
        "code_before": "def test_distinct(numbers):\n    \"\"\"\n    This function checks if all the numbers in the given list are distinct.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    bool: True if all numbers are distinct, False otherwise.\n    \"\"\"\n    # Convert the list to a set. Sets automatically remove duplicates.\n    unique_numbers = set(numbers)\n    \n    # If the length of the set is the same as the length of the list,\n    # it means all numbers were distinct.\n    return len(unique_numbers) == len(numbers)\n\n# Example usage:\nprint(test_distinct([1, 2, 3, 4]))  # Output: True\nprint(test_distinct([1, 2, 2, 4]))  # Output: False\n\n\n",
        "base_tests": [
            "assert test_distinct([1,5,7,9]) == True",
            "assert test_distinct([2,4,5,5,7,9]) == False",
            "assert test_distinct([1,2,3]) == True"
        ],
        "tests": [
            "try:\n    test_distinct('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    test_distinct([1, 'a', 3])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'test_distinct' to determine whether all the numbers are different from each other are not.",
        "instruction": "The function should correctly handle edge cases such as an empty list or a list with a single element.",
        "code_before": "def test_distinct(numbers):\n    \"\"\"\n    This function checks if all the numbers in the given list are distinct.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    bool: True if all numbers are distinct, False otherwise.\n    \"\"\"\n    # Convert the list to a set. Sets automatically remove duplicates.\n    unique_numbers = set(numbers)\n    \n    # If the length of the set is the same as the length of the list,\n    # it means all numbers were distinct.\n    return len(unique_numbers) == len(numbers)\n\n# Example usage:\nprint(test_distinct([1, 2, 3, 4]))  # Output: True\nprint(test_distinct([1, 2, 2, 4]))  # Output: False\n\n\n",
        "base_tests": [
            "assert test_distinct([1,5,7,9]) == True",
            "assert test_distinct([2,4,5,5,7,9]) == False",
            "assert test_distinct([1,2,3]) == True"
        ],
        "tests": [
            "assert test_distinct([]) == True\nassert test_distinct([42]) == True"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'test_distinct' to determine whether all the numbers are different from each other are not.",
        "instruction": "Extend the function to handle lists of floating-point numbers and return whether all numbers are distinct.",
        "code_before": "def test_distinct(numbers):\n    \"\"\"\n    This function checks if all the numbers in the given list are distinct.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    bool: True if all numbers are distinct, False otherwise.\n    \"\"\"\n    # Convert the list to a set. Sets automatically remove duplicates.\n    unique_numbers = set(numbers)\n    \n    # If the length of the set is the same as the length of the list,\n    # it means all numbers were distinct.\n    return len(unique_numbers) == len(numbers)\n\n# Example usage:\nprint(test_distinct([1, 2, 3, 4]))  # Output: True\nprint(test_distinct([1, 2, 2, 4]))  # Output: False\n\n\n",
        "base_tests": [
            "assert test_distinct([1,5,7,9]) == True",
            "assert test_distinct([2,4,5,5,7,9]) == False",
            "assert test_distinct([1,2,3]) == True"
        ],
        "tests": [
            "assert test_distinct([1.1, 2.2, 3.3]) == True\nassert test_distinct([1.1, 2.2, 2.2]) == False"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'test_distinct' to determine whether all the numbers are different from each other are not.",
        "instruction": "The function should include type annotations for its parameters called 'numbers' and return type. The parameter should be annotated as 'numbers': list, and the return type should be annotated as bool.",
        "code_before": "def test_distinct(numbers):\n    \"\"\"\n    This function checks if all the numbers in the given list are distinct.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    bool: True if all numbers are distinct, False otherwise.\n    \"\"\"\n    # Convert the list to a set. Sets automatically remove duplicates.\n    unique_numbers = set(numbers)\n    \n    # If the length of the set is the same as the length of the list,\n    # it means all numbers were distinct.\n    return len(unique_numbers) == len(numbers)\n\n# Example usage:\nprint(test_distinct([1, 2, 3, 4]))  # Output: True\nprint(test_distinct([1, 2, 2, 4]))  # Output: False\n\n\n",
        "base_tests": [
            "assert test_distinct([1,5,7,9]) == True",
            "assert test_distinct([2,4,5,5,7,9]) == False",
            "assert test_distinct([1,2,3]) == True"
        ],
        "tests": [
            "assert test_distinct.__annotations__ == {'numbers': list, 'return': bool}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'test_distinct' to determine whether all the numbers are different from each other are not.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def test_distinct(numbers):\n    \"\"\"\n    This function checks if all the numbers in the given list are distinct.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    bool: True if all numbers are distinct, False otherwise.\n    \"\"\"\n    # Convert the list to a set. Sets automatically remove duplicates.\n    unique_numbers = set(numbers)\n    \n    # If the length of the set is the same as the length of the list,\n    # it means all numbers were distinct.\n    return len(unique_numbers) == len(numbers)\n\n# Example usage:\nprint(test_distinct([1, 2, 3, 4]))  # Output: True\nprint(test_distinct([1, 2, 2, 4]))  # Output: False\n\n\n",
        "base_tests": [
            "assert test_distinct([1,5,7,9]) == True",
            "assert test_distinct([2,4,5,5,7,9]) == False",
            "assert test_distinct([1,2,3]) == True"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(test_distinct)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'compute_last_digit' to find the last digit when factorial of a divides factorial of b.",
        "instruction": "The function should raise a ValueError with a descriptive message 'a should not be greater than b' if a is greater than b.",
        "code_before": "def compute_last_digit(a, b):\n    \"\"\"\n    This function computes the last digit of the division of factorial of b by factorial of a.\n    It assumes that b >= a.\n    \"\"\"\n    if a == b:\n        return 1  # Since b! / a! = 1 when a == b, and the last digit of 1 is 1.\n    \n    last_digit = 1\n    for i in range(a + 1, b + 1):\n        last_digit = (last_digit * (i % 10)) % 10\n        # If at any point the last digit becomes 0, we can break early\n        if last_digit == 0:\n            break\n    \n    return last_digit\n\n# Example usage:\nprint(compute_last_digit(5, 10))  # Output: 2\n\n\n",
        "base_tests": [
            "assert compute_last_digit(2,4) == 2",
            "assert compute_last_digit(6,8) == 6",
            "assert compute_last_digit(1,2) == 2"
        ],
        "tests": [
            "try:\n    compute_last_digit(5, 3)\nexcept ValueError as e:\n    assert str(e) == 'a should not be greater than b'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'compute_last_digit' to find the last digit when factorial of a divides factorial of b.",
        "instruction": "The function should correctly handle the edge case where a equals b, returning 1 since factorial(a) divided by factorial(b) is 1.",
        "code_before": "def compute_last_digit(a, b):\n    \"\"\"\n    This function computes the last digit of the division of factorial of b by factorial of a.\n    It assumes that b >= a.\n    \"\"\"\n    if a == b:\n        return 1  # Since b! / a! = 1 when a == b, and the last digit of 1 is 1.\n    \n    last_digit = 1\n    for i in range(a + 1, b + 1):\n        last_digit = (last_digit * (i % 10)) % 10\n        # If at any point the last digit becomes 0, we can break early\n        if last_digit == 0:\n            break\n    \n    return last_digit\n\n# Example usage:\nprint(compute_last_digit(5, 10))  # Output: 2\n\n\n",
        "base_tests": [
            "assert compute_last_digit(2,4) == 2",
            "assert compute_last_digit(6,8) == 6",
            "assert compute_last_digit(1,2) == 2"
        ],
        "tests": [
            "assert compute_last_digit(5, 5) == 1"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'compute_last_digit' to find the last digit when factorial of a divides factorial of b.",
        "instruction": "Extend the function to handle cases where a or b is zero, returning 1 since factorial(0) is 1.",
        "code_before": "def compute_last_digit(a, b):\n    \"\"\"\n    This function computes the last digit of the division of factorial of b by factorial of a.\n    It assumes that b >= a.\n    \"\"\"\n    if a == b:\n        return 1  # Since b! / a! = 1 when a == b, and the last digit of 1 is 1.\n    \n    last_digit = 1\n    for i in range(a + 1, b + 1):\n        last_digit = (last_digit * (i % 10)) % 10\n        # If at any point the last digit becomes 0, we can break early\n        if last_digit == 0:\n            break\n    \n    return last_digit\n\n# Example usage:\nprint(compute_last_digit(5, 10))  # Output: 2\n\n\n",
        "base_tests": [
            "assert compute_last_digit(2,4) == 2",
            "assert compute_last_digit(6,8) == 6",
            "assert compute_last_digit(1,2) == 2"
        ],
        "tests": [
            "assert compute_last_digit(0, 5) == 1"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'compute_last_digit' to find the last digit when factorial of a divides factorial of b.",
        "instruction": "The function should include type annotations for its parameters 'a','b' and return type, indicating that both parameters are integers and the return type is an integer.",
        "code_before": "def compute_last_digit(a, b):\n    \"\"\"\n    This function computes the last digit of the division of factorial of b by factorial of a.\n    It assumes that b >= a.\n    \"\"\"\n    if a == b:\n        return 1  # Since b! / a! = 1 when a == b, and the last digit of 1 is 1.\n    \n    last_digit = 1\n    for i in range(a + 1, b + 1):\n        last_digit = (last_digit * (i % 10)) % 10\n        # If at any point the last digit becomes 0, we can break early\n        if last_digit == 0:\n            break\n    \n    return last_digit\n\n# Example usage:\nprint(compute_last_digit(5, 10))  # Output: 2\n\n\n",
        "base_tests": [
            "assert compute_last_digit(2,4) == 2",
            "assert compute_last_digit(6,8) == 6",
            "assert compute_last_digit(1,2) == 2"
        ],
        "tests": [
            "assert compute_last_digit.__annotations__ == {'a': int, 'b': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'compute_last_digit' to find the last digit when factorial of a divides factorial of b.",
        "instruction": "The function should have a cyclomatic complexity of 3 or less, ensuring that the logic is straightforward and easy to follow.",
        "code_before": "def compute_last_digit(a, b):\n    \"\"\"\n    This function computes the last digit of the division of factorial of b by factorial of a.\n    It assumes that b >= a.\n    \"\"\"\n    if a == b:\n        return 1  # Since b! / a! = 1 when a == b, and the last digit of 1 is 1.\n    \n    last_digit = 1\n    for i in range(a + 1, b + 1):\n        last_digit = (last_digit * (i % 10)) % 10\n        # If at any point the last digit becomes 0, we can break early\n        if last_digit == 0:\n            break\n    \n    return last_digit\n\n# Example usage:\nprint(compute_last_digit(5, 10))  # Output: 2\n\n\n",
        "base_tests": [
            "assert compute_last_digit(2,4) == 2",
            "assert compute_last_digit(6,8) == 6",
            "assert compute_last_digit(1,2) == 2"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(compute_last_digit))[0].complexity <=3"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'odd_bit_set_number' to set all odd bits of a given number.",
        "instruction": "The function should accept an integer as input and return an integer with all odd bits set.",
        "code_before": "def odd_bit_set_number(n):\n    \"\"\"\n    This function sets all odd bits of a given number n.\n    \n    Parameters:\n    n (int): The number whose odd bits are to be set.\n    \n    Returns:\n    int: The number with all odd bits set.\n    \"\"\"\n    # Initialize result\n    result = 0\n    \n    # Initialize position\n    pos = 0\n    \n    # Iterate through all bits of n\n    while (1 << pos) <= n or pos < 32:  # Assuming 32-bit integer\n        # Set bit if it's in an odd position\n        if pos % 2 == 1:\n            result |= (1 << pos)\n        pos += 1\n    \n    # Combine original number with the result to set odd bits\n    return n | result\n\n# Test the function\nprint(odd_bit_set_number(10))  # Output: 15 (binary 1010 -> 1111)\nprint(odd_bit_set_number(21))  # Output: 31 (binary 10101 -> 11111)\n\n\n",
        "base_tests": [
            "assert odd_bit_set_number(10) == 15",
            "assert odd_bit_set_number(20) == 21",
            "assert odd_bit_set_number(30) == 31"
        ],
        "tests": [
            "assert isinstance(odd_bit_set_number(10), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'odd_bit_set_number' to set all odd bits of a given number.",
        "instruction": "The function should raise a TypeError if the input is not an integer.",
        "code_before": "def odd_bit_set_number(n):\n    \"\"\"\n    This function sets all odd bits of a given number n.\n    \n    Parameters:\n    n (int): The number whose odd bits are to be set.\n    \n    Returns:\n    int: The number with all odd bits set.\n    \"\"\"\n    # Initialize result\n    result = 0\n    \n    # Initialize position\n    pos = 0\n    \n    # Iterate through all bits of n\n    while (1 << pos) <= n or pos < 32:  # Assuming 32-bit integer\n        # Set bit if it's in an odd position\n        if pos % 2 == 1:\n            result |= (1 << pos)\n        pos += 1\n    \n    # Combine original number with the result to set odd bits\n    return n | result\n\n# Test the function\nprint(odd_bit_set_number(10))  # Output: 15 (binary 1010 -> 1111)\nprint(odd_bit_set_number(21))  # Output: 31 (binary 10101 -> 11111)\n\n\n",
        "base_tests": [
            "assert odd_bit_set_number(10) == 15",
            "assert odd_bit_set_number(20) == 21",
            "assert odd_bit_set_number(30) == 31"
        ],
        "tests": [
            "try: odd_bit_set_number('10')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'odd_bit_set_number' to set all odd bits of a given number.",
        "instruction": "The function should correctly handle the edge case where the input is 0, returning 1.",
        "code_before": "def odd_bit_set_number(n):\n    \"\"\"\n    This function sets all odd bits of a given number n.\n    \n    Parameters:\n    n (int): The number whose odd bits are to be set.\n    \n    Returns:\n    int: The number with all odd bits set.\n    \"\"\"\n    # Initialize result\n    result = 0\n    \n    # Initialize position\n    pos = 0\n    \n    # Iterate through all bits of n\n    while (1 << pos) <= n or pos < 32:  # Assuming 32-bit integer\n        # Set bit if it's in an odd position\n        if pos % 2 == 1:\n            result |= (1 << pos)\n        pos += 1\n    \n    # Combine original number with the result to set odd bits\n    return n | result\n\n# Test the function\nprint(odd_bit_set_number(10))  # Output: 15 (binary 1010 -> 1111)\nprint(odd_bit_set_number(21))  # Output: 31 (binary 10101 -> 11111)\n\n\n",
        "base_tests": [
            "assert odd_bit_set_number(10) == 15",
            "assert odd_bit_set_number(20) == 21",
            "assert odd_bit_set_number(30) == 31"
        ],
        "tests": [
            "assert odd_bit_set_number(0) == 1"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'odd_bit_set_number' to set all odd bits of a given number.",
        "instruction": "Extend the function to handle negative integers by setting all odd bits in their absolute value.",
        "code_before": "def odd_bit_set_number(n):\n    \"\"\"\n    This function sets all odd bits of a given number n.\n    \n    Parameters:\n    n (int): The number whose odd bits are to be set.\n    \n    Returns:\n    int: The number with all odd bits set.\n    \"\"\"\n    # Initialize result\n    result = 0\n    \n    # Initialize position\n    pos = 0\n    \n    # Iterate through all bits of n\n    while (1 << pos) <= n or pos < 32:  # Assuming 32-bit integer\n        # Set bit if it's in an odd position\n        if pos % 2 == 1:\n            result |= (1 << pos)\n        pos += 1\n    \n    # Combine original number with the result to set odd bits\n    return n | result\n\n# Test the function\nprint(odd_bit_set_number(10))  # Output: 15 (binary 1010 -> 1111)\nprint(odd_bit_set_number(21))  # Output: 31 (binary 10101 -> 11111)\n\n\n",
        "base_tests": [
            "assert odd_bit_set_number(10) == 15",
            "assert odd_bit_set_number(20) == 21",
            "assert odd_bit_set_number(30) == 31"
        ],
        "tests": [
            "assert odd_bit_set_number(-10) == 15"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'odd_bit_set_number' to set all odd bits of a given number.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as int.",
        "code_before": "def odd_bit_set_number(n):\n    \"\"\"\n    This function sets all odd bits of a given number n.\n    \n    Parameters:\n    n (int): The number whose odd bits are to be set.\n    \n    Returns:\n    int: The number with all odd bits set.\n    \"\"\"\n    # Initialize result\n    result = 0\n    \n    # Initialize position\n    pos = 0\n    \n    # Iterate through all bits of n\n    while (1 << pos) <= n or pos < 32:  # Assuming 32-bit integer\n        # Set bit if it's in an odd position\n        if pos % 2 == 1:\n            result |= (1 << pos)\n        pos += 1\n    \n    # Combine original number with the result to set odd bits\n    return n | result\n\n# Test the function\nprint(odd_bit_set_number(10))  # Output: 15 (binary 1010 -> 1111)\nprint(odd_bit_set_number(21))  # Output: 31 (binary 10101 -> 11111)\n\n\n",
        "base_tests": [
            "assert odd_bit_set_number(10) == 15",
            "assert odd_bit_set_number(20) == 21",
            "assert odd_bit_set_number(30) == 31"
        ],
        "tests": [
            "assert odd_bit_set_number.__annotations__ == {'n': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'odd_bit_set_number' to set all odd bits of a given number.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def odd_bit_set_number(n):\n    \"\"\"\n    This function sets all odd bits of a given number n.\n    \n    Parameters:\n    n (int): The number whose odd bits are to be set.\n    \n    Returns:\n    int: The number with all odd bits set.\n    \"\"\"\n    # Initialize result\n    result = 0\n    \n    # Initialize position\n    pos = 0\n    \n    # Iterate through all bits of n\n    while (1 << pos) <= n or pos < 32:  # Assuming 32-bit integer\n        # Set bit if it's in an odd position\n        if pos % 2 == 1:\n            result |= (1 << pos)\n        pos += 1\n    \n    # Combine original number with the result to set odd bits\n    return n | result\n\n# Test the function\nprint(odd_bit_set_number(10))  # Output: 15 (binary 1010 -> 1111)\nprint(odd_bit_set_number(21))  # Output: 31 (binary 10101 -> 11111)\n\n\n",
        "base_tests": [
            "assert odd_bit_set_number(10) == 15",
            "assert odd_bit_set_number(20) == 21",
            "assert odd_bit_set_number(30) == 31"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(odd_bit_set_number)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'specified_element' to extract every first or specified element from a given two-dimensional list.",
        "instruction": "The function should accept a two-dimensional list and an integer index, returning a list of elements from each sublist at the specified index. The function should return an empty list if the input list is empty.",
        "code_before": "def specified_element(two_d_list, index=0):\n    \"\"\"\n    Extracts every element at the specified index from a given two-dimensional list.\n    \n    Parameters:\n    two_d_list (list of lists): The two-dimensional list from which to extract elements.\n    index (int): The index of the element to extract from each sublist. Defaults to 0.\n    \n    Returns:\n    list: A list containing the elements at the specified index from each sublist.\n    \"\"\"\n    # Check if the provided index is valid\n    if not two_d_list or index < 0 or index >= len(two_d_list[0]):\n        raise ValueError(\"Invalid index provided.\")\n    \n    # Extract the specified element from each sublist\n    return [sublist[index] for sublist in two_d_list]\n\n# Example usage:\ntwo_d_list = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# Extract the first element from each sublist\nprint(specified_element(two_d_list))  # Output: [1, 4, 7]\n\n# Extract the second element from each sublist\nprint(specified_element(two_d_list, 1))  # Output: [2, 5, 8]\n\n\n",
        "base_tests": [
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]"
        ],
        "tests": [
            "assert specified_element([], 0) == []"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'specified_element' to extract every first or specified element from a given two-dimensional list.",
        "instruction": "The function should raise an IndexError with a descriptive message 'Index out of range for sublist' if the specified index is out of range for any sublist.",
        "code_before": "def specified_element(two_d_list, index=0):\n    \"\"\"\n    Extracts every element at the specified index from a given two-dimensional list.\n    \n    Parameters:\n    two_d_list (list of lists): The two-dimensional list from which to extract elements.\n    index (int): The index of the element to extract from each sublist. Defaults to 0.\n    \n    Returns:\n    list: A list containing the elements at the specified index from each sublist.\n    \"\"\"\n    # Check if the provided index is valid\n    if not two_d_list or index < 0 or index >= len(two_d_list[0]):\n        raise ValueError(\"Invalid index provided.\")\n    \n    # Extract the specified element from each sublist\n    return [sublist[index] for sublist in two_d_list]\n\n# Example usage:\ntwo_d_list = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# Extract the first element from each sublist\nprint(specified_element(two_d_list))  # Output: [1, 4, 7]\n\n# Extract the second element from each sublist\nprint(specified_element(two_d_list, 1))  # Output: [2, 5, 8]\n\n\n",
        "base_tests": [
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]"
        ],
        "tests": [
            "try: specified_element([[1, 2], [3, 4]], 3)\nexcept IndexError as e: assert str(e) == 'Index out of range for sublist'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'specified_element' to extract every first or specified element from a given two-dimensional list.",
        "instruction": "The function should handle cases where sublists are of varying lengths, extracting elements only from sublists where the index is valid.",
        "code_before": "def specified_element(two_d_list, index=0):\n    \"\"\"\n    Extracts every element at the specified index from a given two-dimensional list.\n    \n    Parameters:\n    two_d_list (list of lists): The two-dimensional list from which to extract elements.\n    index (int): The index of the element to extract from each sublist. Defaults to 0.\n    \n    Returns:\n    list: A list containing the elements at the specified index from each sublist.\n    \"\"\"\n    # Check if the provided index is valid\n    if not two_d_list or index < 0 or index >= len(two_d_list[0]):\n        raise ValueError(\"Invalid index provided.\")\n    \n    # Extract the specified element from each sublist\n    return [sublist[index] for sublist in two_d_list]\n\n# Example usage:\ntwo_d_list = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# Extract the first element from each sublist\nprint(specified_element(two_d_list))  # Output: [1, 4, 7]\n\n# Extract the second element from each sublist\nprint(specified_element(two_d_list, 1))  # Output: [2, 5, 8]\n\n\n",
        "base_tests": [
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]"
        ],
        "tests": [
            "assert specified_element([[1, 2], [3], [4, 5, 6]], 1) == [2, 5]"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'specified_element' to extract every first or specified element from a given two-dimensional list.",
        "instruction": "Extend the function to allow negative indices, which should extract elements from the end of each sublist.",
        "code_before": "def specified_element(two_d_list, index=0):\n    \"\"\"\n    Extracts every element at the specified index from a given two-dimensional list.\n    \n    Parameters:\n    two_d_list (list of lists): The two-dimensional list from which to extract elements.\n    index (int): The index of the element to extract from each sublist. Defaults to 0.\n    \n    Returns:\n    list: A list containing the elements at the specified index from each sublist.\n    \"\"\"\n    # Check if the provided index is valid\n    if not two_d_list or index < 0 or index >= len(two_d_list[0]):\n        raise ValueError(\"Invalid index provided.\")\n    \n    # Extract the specified element from each sublist\n    return [sublist[index] for sublist in two_d_list]\n\n# Example usage:\ntwo_d_list = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# Extract the first element from each sublist\nprint(specified_element(two_d_list))  # Output: [1, 4, 7]\n\n# Extract the second element from each sublist\nprint(specified_element(two_d_list, 1))  # Output: [2, 5, 8]\n\n\n",
        "base_tests": [
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]"
        ],
        "tests": [
            "assert specified_element([[1, 2, 3], [4, 5, 6], [7, 8, 9]], -1) == [3, 6, 9]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'specified_element' to extract every first or specified element from a given two-dimensional list.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation, spacing, and naming conventions.",
        "code_before": "def specified_element(two_d_list, index=0):\n    \"\"\"\n    Extracts every element at the specified index from a given two-dimensional list.\n    \n    Parameters:\n    two_d_list (list of lists): The two-dimensional list from which to extract elements.\n    index (int): The index of the element to extract from each sublist. Defaults to 0.\n    \n    Returns:\n    list: A list containing the elements at the specified index from each sublist.\n    \"\"\"\n    # Check if the provided index is valid\n    if not two_d_list or index < 0 or index >= len(two_d_list[0]):\n        raise ValueError(\"Invalid index provided.\")\n    \n    # Extract the specified element from each sublist\n    return [sublist[index] for sublist in two_d_list]\n\n# Example usage:\ntwo_d_list = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n# Extract the first element from each sublist\nprint(specified_element(two_d_list))  # Output: [1, 4, 7]\n\n# Extract the second element from each sublist\nprint(specified_element(two_d_list, 1))  # Output: [2, 5, 8]\n\n\n",
        "base_tests": [
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]",
            "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(specified_element)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'min_length_list' to find the list with minimum length using lambda function.",
        "instruction": "The function should accept a list of lists and return a tuple containing the length of the shortest list and the list itself.",
        "code_before": "def min_length_list(lists):\n    \"\"\"\n    This function takes a list of lists and returns the list with the minimum length.\n    It uses a lambda function to determine the length of each list.\n    \n    :param lists: List of lists\n    :return: List with minimum length\n    \"\"\"\n    if not lists:\n        return None  # Return None if the input list is empty\n    \n    return min(lists, key=lambda x: len(x))\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [4, 5], [6, 7, 8, 9], [10]]\nprint(min_length_list(list_of_lists))  # Output: [4, 5]\n\n\n",
        "base_tests": [
            "assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])",
            "assert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1,[1])",
            "assert min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])==(2,[1,2])"
        ],
        "tests": [
            "assert min_length_list([[1, 2], [3, 4, 5], [6]]) == (1, [6])"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'min_length_list' to find the list with minimum length using lambda function.",
        "instruction": "The function should raise a ValueError with a descriptive message 'Input must be a list of lists.' if the input is not a list of lists.",
        "code_before": "def min_length_list(lists):\n    \"\"\"\n    This function takes a list of lists and returns the list with the minimum length.\n    It uses a lambda function to determine the length of each list.\n    \n    :param lists: List of lists\n    :return: List with minimum length\n    \"\"\"\n    if not lists:\n        return None  # Return None if the input list is empty\n    \n    return min(lists, key=lambda x: len(x))\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [4, 5], [6, 7, 8, 9], [10]]\nprint(min_length_list(list_of_lists))  # Output: [4, 5]\n\n\n",
        "base_tests": [
            "assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])",
            "assert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1,[1])",
            "assert min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])==(2,[1,2])"
        ],
        "tests": [
            "try: min_length_list('not a list of lists')\nexcept ValueError as e: assert str(e) == 'Input must be a list of lists.'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'min_length_list' to find the list with minimum length using lambda function.",
        "instruction": "The function should correctly handle an edge case where all lists are of the same length, returning the first such list.",
        "code_before": "def min_length_list(lists):\n    \"\"\"\n    This function takes a list of lists and returns the list with the minimum length.\n    It uses a lambda function to determine the length of each list.\n    \n    :param lists: List of lists\n    :return: List with minimum length\n    \"\"\"\n    if not lists:\n        return None  # Return None if the input list is empty\n    \n    return min(lists, key=lambda x: len(x))\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [4, 5], [6, 7, 8, 9], [10]]\nprint(min_length_list(list_of_lists))  # Output: [4, 5]\n\n\n",
        "base_tests": [
            "assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])",
            "assert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1,[1])",
            "assert min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])==(2,[1,2])"
        ],
        "tests": [
            "assert min_length_list([[1, 2], [3, 4], [5, 6]]) == (2, [1, 2])"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'min_length_list' to find the list with minimum length using lambda function.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'lists': list[list], and the return type should be annotated as tuple[int, list].",
        "code_before": "def min_length_list(lists):\n    \"\"\"\n    This function takes a list of lists and returns the list with the minimum length.\n    It uses a lambda function to determine the length of each list.\n    \n    :param lists: List of lists\n    :return: List with minimum length\n    \"\"\"\n    if not lists:\n        return None  # Return None if the input list is empty\n    \n    return min(lists, key=lambda x: len(x))\n\n# Example usage:\nlist_of_lists = [[1, 2, 3], [4, 5], [6, 7, 8, 9], [10]]\nprint(min_length_list(list_of_lists))  # Output: [4, 5]\n\n\n",
        "base_tests": [
            "assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])",
            "assert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1,[1])",
            "assert min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])==(2,[1,2])"
        ],
        "tests": [
            "assert min_length_list.__annotations__ == {'lists': 'list[list]', 'return': 'tuple[int, list]'}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'check_equilateral' to print check if the triangle is equilateral or not.",
        "instruction": "The function should raise a ValueError if any of the inputs are non-positive integers.",
        "code_before": "def check_equilateral(a, b, c):\n    \"\"\"\n    This function checks if a triangle with sides of length a, b, and c is equilateral.\n    \n    An equilateral triangle has all three sides of the same length.\n    \n    Parameters:\n    a (float): The length of the first side of the triangle.\n    b (float): The length of the second side of the triangle.\n    c (float): The length of the third side of the triangle.\n    \n    Returns:\n    None: This function prints whether the triangle is equilateral or not.\n    \"\"\"\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n\n# Example usage:\ncheck_equilateral(5, 5, 5)  # Output: The triangle is equilateral.\ncheck_equilateral(5, 5, 4)  # Output: The triangle is not equilateral.\n\n\n",
        "base_tests": [
            "assert check_equilateral(6,8,12)==False ",
            "assert check_equilateral(6,6,12)==False",
            "assert check_equilateral(6,6,6)==True"
        ],
        "tests": [
            "try:\n    check_equilateral(-1, 3, 3)\nexcept ValueError:\n    pass\nelse:\n    assert False, 'Expected ValueError'\n\ntry:\n    check_equilateral(0, 3, 3)\nexcept ValueError:\n    pass\nelse:\n    assert False, 'Expected ValueError'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'check_equilateral' to print check if the triangle is equilateral or not.",
        "instruction": "The function should correctly handle the case where all sides are zero, returning False.",
        "code_before": "def check_equilateral(a, b, c):\n    \"\"\"\n    This function checks if a triangle with sides of length a, b, and c is equilateral.\n    \n    An equilateral triangle has all three sides of the same length.\n    \n    Parameters:\n    a (float): The length of the first side of the triangle.\n    b (float): The length of the second side of the triangle.\n    c (float): The length of the third side of the triangle.\n    \n    Returns:\n    None: This function prints whether the triangle is equilateral or not.\n    \"\"\"\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n\n# Example usage:\ncheck_equilateral(5, 5, 5)  # Output: The triangle is equilateral.\ncheck_equilateral(5, 5, 4)  # Output: The triangle is not equilateral.\n\n\n",
        "base_tests": [
            "assert check_equilateral(6,8,12)==False ",
            "assert check_equilateral(6,6,12)==False",
            "assert check_equilateral(6,6,6)==True"
        ],
        "tests": [
            "assert check_equilateral(0, 0, 0) == False"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'check_equilateral' to print check if the triangle is equilateral or not.",
        "instruction": "Extend the function to also check if the triangle is isosceles, returning 'isosceles' if true.",
        "code_before": "def check_equilateral(a, b, c):\n    \"\"\"\n    This function checks if a triangle with sides of length a, b, and c is equilateral.\n    \n    An equilateral triangle has all three sides of the same length.\n    \n    Parameters:\n    a (float): The length of the first side of the triangle.\n    b (float): The length of the second side of the triangle.\n    c (float): The length of the third side of the triangle.\n    \n    Returns:\n    None: This function prints whether the triangle is equilateral or not.\n    \"\"\"\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n\n# Example usage:\ncheck_equilateral(5, 5, 5)  # Output: The triangle is equilateral.\ncheck_equilateral(5, 5, 4)  # Output: The triangle is not equilateral.\n\n\n",
        "base_tests": [
            "assert check_equilateral(6,8,12)==False ",
            "assert check_equilateral(6,6,12)==False",
            "assert check_equilateral(6,6,6)==True"
        ],
        "tests": [
            "assert check_equilateral(5, 5, 3) == 'isosceles'"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'check_equilateral' to print check if the triangle is equilateral or not.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'a': int, 'b': int, 'c': int, and the return type should be annotated as bool.",
        "code_before": "def check_equilateral(a, b, c):\n    \"\"\"\n    This function checks if a triangle with sides of length a, b, and c is equilateral.\n    \n    An equilateral triangle has all three sides of the same length.\n    \n    Parameters:\n    a (float): The length of the first side of the triangle.\n    b (float): The length of the second side of the triangle.\n    c (float): The length of the third side of the triangle.\n    \n    Returns:\n    None: This function prints whether the triangle is equilateral or not.\n    \"\"\"\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n\n# Example usage:\ncheck_equilateral(5, 5, 5)  # Output: The triangle is equilateral.\ncheck_equilateral(5, 5, 4)  # Output: The triangle is not equilateral.\n\n\n",
        "base_tests": [
            "assert check_equilateral(6,8,12)==False ",
            "assert check_equilateral(6,6,12)==False",
            "assert check_equilateral(6,6,6)==True"
        ],
        "tests": [
            "assert check_equilateral.__annotations__ == {'a': int, 'b': int, 'c': int, 'return': bool}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'check_equilateral' to print check if the triangle is equilateral or not.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple conditional check.",
        "code_before": "def check_equilateral(a, b, c):\n    \"\"\"\n    This function checks if a triangle with sides of length a, b, and c is equilateral.\n    \n    An equilateral triangle has all three sides of the same length.\n    \n    Parameters:\n    a (float): The length of the first side of the triangle.\n    b (float): The length of the second side of the triangle.\n    c (float): The length of the third side of the triangle.\n    \n    Returns:\n    None: This function prints whether the triangle is equilateral or not.\n    \"\"\"\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n\n# Example usage:\ncheck_equilateral(5, 5, 5)  # Output: The triangle is equilateral.\ncheck_equilateral(5, 5, 4)  # Output: The triangle is not equilateral.\n\n\n",
        "base_tests": [
            "assert check_equilateral(6,8,12)==False ",
            "assert check_equilateral(6,6,12)==False",
            "assert check_equilateral(6,6,6)==True"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(check_equilateral))[0].complexity ==1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'check_equilateral' to print check if the triangle is equilateral or not.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation and spacing.",
        "code_before": "def check_equilateral(a, b, c):\n    \"\"\"\n    This function checks if a triangle with sides of length a, b, and c is equilateral.\n    \n    An equilateral triangle has all three sides of the same length.\n    \n    Parameters:\n    a (float): The length of the first side of the triangle.\n    b (float): The length of the second side of the triangle.\n    c (float): The length of the third side of the triangle.\n    \n    Returns:\n    None: This function prints whether the triangle is equilateral or not.\n    \"\"\"\n    if a == b == c:\n        print(\"The triangle is equilateral.\")\n    else:\n        print(\"The triangle is not equilateral.\")\n\n# Example usage:\ncheck_equilateral(5, 5, 5)  # Output: The triangle is equilateral.\ncheck_equilateral(5, 5, 4)  # Output: The triangle is not equilateral.\n\n\n",
        "base_tests": [
            "assert check_equilateral(6,8,12)==False ",
            "assert check_equilateral(6,6,12)==False",
            "assert check_equilateral(6,6,6)==True"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(check_equilateral)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.",
        "instruction": "The function should accept two positive numerical inputs representing the base and height of the parallelogram and return a positive numerical output representing the area.",
        "code_before": "def parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    base (float): The length of the base of the parallelogram.\n    height (float): The height of the parallelogram (measured perpendicular to the base).\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    if base <= 0 or height <= 0:\n        raise ValueError(\"Base and height must be positive numbers.\")\n    \n    area = base * height\n    return area\n\n# Example usage:\n# area = parallelogram_area(5, 3)\n# print(area)  # Output: 15\n\n\n",
        "base_tests": [
            "assert parallelogram_area(10,20)==200",
            "assert parallelogram_area(15,20)==300",
            "assert parallelogram_area(8,9)==72"
        ],
        "tests": [
            "assert parallelogram_area(5, 10) == 50",
            "assert parallelogram_area(0, 10) == 0",
            "assert parallelogram_area(10, 0) == 0",
            "assert parallelogram_area(0, 0) == 0"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.",
        "instruction": "The function should raise a TypeError if the inputs are not numerical.",
        "code_before": "def parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    base (float): The length of the base of the parallelogram.\n    height (float): The height of the parallelogram (measured perpendicular to the base).\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    if base <= 0 or height <= 0:\n        raise ValueError(\"Base and height must be positive numbers.\")\n    \n    area = base * height\n    return area\n\n# Example usage:\n# area = parallelogram_area(5, 3)\n# print(area)  # Output: 15\n\n\n",
        "base_tests": [
            "assert parallelogram_area(10,20)==200",
            "assert parallelogram_area(15,20)==300",
            "assert parallelogram_area(8,9)==72"
        ],
        "tests": [
            "try:\n    parallelogram_area('10', 20)\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass",
            "try:\n    parallelogram_area(10, '20')\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass",
            "try:\n    parallelogram_area('10', '20')\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.",
        "instruction": "The function should correctly handle edge cases where the base or height is zero, returning an area of zero.",
        "code_before": "def parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    base (float): The length of the base of the parallelogram.\n    height (float): The height of the parallelogram (measured perpendicular to the base).\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    if base <= 0 or height <= 0:\n        raise ValueError(\"Base and height must be positive numbers.\")\n    \n    area = base * height\n    return area\n\n# Example usage:\n# area = parallelogram_area(5, 3)\n# print(area)  # Output: 15\n\n\n",
        "base_tests": [
            "assert parallelogram_area(10,20)==200",
            "assert parallelogram_area(15,20)==300",
            "assert parallelogram_area(8,9)==72"
        ],
        "tests": [
            "assert parallelogram_area(0, 10) == 0",
            "assert parallelogram_area(10, 0) == 0",
            "assert parallelogram_area(0, 0) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.",
        "instruction": "Extend the function to accept a list of tuples where each tuple contains the base and height of a parallelogram, and return a list of areas.",
        "code_before": "def parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    base (float): The length of the base of the parallelogram.\n    height (float): The height of the parallelogram (measured perpendicular to the base).\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    if base <= 0 or height <= 0:\n        raise ValueError(\"Base and height must be positive numbers.\")\n    \n    area = base * height\n    return area\n\n# Example usage:\n# area = parallelogram_area(5, 3)\n# print(area)  # Output: 15\n\n\n",
        "base_tests": [
            "assert parallelogram_area(10,20)==200",
            "assert parallelogram_area(15,20)==300",
            "assert parallelogram_area(8,9)==72"
        ],
        "tests": [
            "assert parallelogram_area_list([(10, 20), (15, 20), (8, 9)]) == [200, 300, 72]",
            "assert parallelogram_area_list([(0, 10), (10, 0), (0, 0)]) == [0, 0, 0]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'base': float, 'height': float, and the return type should be annotated as float.",
        "code_before": "def parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    base (float): The length of the base of the parallelogram.\n    height (float): The height of the parallelogram (measured perpendicular to the base).\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    if base <= 0 or height <= 0:\n        raise ValueError(\"Base and height must be positive numbers.\")\n    \n    area = base * height\n    return area\n\n# Example usage:\n# area = parallelogram_area(5, 3)\n# print(area)  # Output: 15\n\n\n",
        "base_tests": [
            "assert parallelogram_area(10,20)==200",
            "assert parallelogram_area(15,20)==300",
            "assert parallelogram_area(8,9)==72"
        ],
        "tests": [
            "assert parallelogram_area.__annotations__ == {'base': float, 'height': float, 'return': float}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple, linear function.",
        "code_before": "def parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    base (float): The length of the base of the parallelogram.\n    height (float): The height of the parallelogram (measured perpendicular to the base).\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    if base <= 0 or height <= 0:\n        raise ValueError(\"Base and height must be positive numbers.\")\n    \n    area = base * height\n    return area\n\n# Example usage:\n# area = parallelogram_area(5, 3)\n# print(area)  # Output: 15\n\n\n",
        "base_tests": [
            "assert parallelogram_area(10,20)==200",
            "assert parallelogram_area(15,20)==300",
            "assert parallelogram_area(8,9)==72"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(parallelogram_area))[0].complexity ==1"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def parallelogram_area(base, height):\n    \"\"\"\n    Calculate the area of a parallelogram.\n\n    Parameters:\n    base (float): The length of the base of the parallelogram.\n    height (float): The height of the parallelogram (measured perpendicular to the base).\n\n    Returns:\n    float: The area of the parallelogram.\n    \"\"\"\n    if base <= 0 or height <= 0:\n        raise ValueError(\"Base and height must be positive numbers.\")\n    \n    area = base * height\n    return area\n\n# Example usage:\n# area = parallelogram_area(5, 3)\n# print(area)  # Output: 15\n\n\n",
        "base_tests": [
            "assert parallelogram_area(10,20)==200",
            "assert parallelogram_area(15,20)==300",
            "assert parallelogram_area(8,9)==72"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(parallelogram_area)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.",
        "instruction": "The function should accept only strings as input and return 'Equal' if the first and last characters are the same, otherwise 'Not Equal'.",
        "code_before": "def check_equality(input_string):\n    \"\"\"\n    This function checks whether the first and last characters of a given string are equal or not.\n    \n    Args:\n    input_string (str): The string to be checked.\n    \n    Returns:\n    bool: True if the first and last characters are equal, False otherwise.\n    \"\"\"\n    # Check if the string is empty\n    if not input_string:\n        return False\n    \n    # Compare the first and last characters\n    return input_string[0] == input_string[-1]\n\n# Example usage:\nprint(check_equality(\"radar\"))  # Output: True\nprint(check_equality(\"hello\"))  # Output: False\nprint(check_equality(\"a\"))      # Output: True\nprint(check_equality(\"\"))       # Output: False\n\n\n",
        "base_tests": [
            "assert check_equality(\"abcda\") == \"Equal\"",
            "assert check_equality(\"ab\") == \"Not Equal\"",
            "assert check_equality(\"mad\") == \"Not Equal\""
        ],
        "tests": [
            "assert check_equality('racecar') == 'Equal'\nassert check_equality('hello') == 'Not Equal'\nassert check_equality('a') == 'Equal'"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.",
        "instruction": "The function should raise a TypeError with a descriptive message as 'Input must be a string' if the input is not a string.",
        "code_before": "def check_equality(input_string):\n    \"\"\"\n    This function checks whether the first and last characters of a given string are equal or not.\n    \n    Args:\n    input_string (str): The string to be checked.\n    \n    Returns:\n    bool: True if the first and last characters are equal, False otherwise.\n    \"\"\"\n    # Check if the string is empty\n    if not input_string:\n        return False\n    \n    # Compare the first and last characters\n    return input_string[0] == input_string[-1]\n\n# Example usage:\nprint(check_equality(\"radar\"))  # Output: True\nprint(check_equality(\"hello\"))  # Output: False\nprint(check_equality(\"a\"))      # Output: True\nprint(check_equality(\"\"))       # Output: False\n\n\n",
        "base_tests": [
            "assert check_equality(\"abcda\") == \"Equal\"",
            "assert check_equality(\"ab\") == \"Not Equal\"",
            "assert check_equality(\"mad\") == \"Not Equal\""
        ],
        "tests": [
            "try:\n    check_equality(123)\nexcept TypeError as e:\n    assert str(e) == 'Input must be a string'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.",
        "instruction": "The function should correctly handle empty strings by returning 'Equal'.",
        "code_before": "def check_equality(input_string):\n    \"\"\"\n    This function checks whether the first and last characters of a given string are equal or not.\n    \n    Args:\n    input_string (str): The string to be checked.\n    \n    Returns:\n    bool: True if the first and last characters are equal, False otherwise.\n    \"\"\"\n    # Check if the string is empty\n    if not input_string:\n        return False\n    \n    # Compare the first and last characters\n    return input_string[0] == input_string[-1]\n\n# Example usage:\nprint(check_equality(\"radar\"))  # Output: True\nprint(check_equality(\"hello\"))  # Output: False\nprint(check_equality(\"a\"))      # Output: True\nprint(check_equality(\"\"))       # Output: False\n\n\n",
        "base_tests": [
            "assert check_equality(\"abcda\") == \"Equal\"",
            "assert check_equality(\"ab\") == \"Not Equal\"",
            "assert check_equality(\"mad\") == \"Not Equal\""
        ],
        "tests": [
            "assert check_equality('') == 'Equal'"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.",
        "instruction": "Extend the function to ignore case sensitivity when comparing the first and last characters.",
        "code_before": "def check_equality(input_string):\n    \"\"\"\n    This function checks whether the first and last characters of a given string are equal or not.\n    \n    Args:\n    input_string (str): The string to be checked.\n    \n    Returns:\n    bool: True if the first and last characters are equal, False otherwise.\n    \"\"\"\n    # Check if the string is empty\n    if not input_string:\n        return False\n    \n    # Compare the first and last characters\n    return input_string[0] == input_string[-1]\n\n# Example usage:\nprint(check_equality(\"radar\"))  # Output: True\nprint(check_equality(\"hello\"))  # Output: False\nprint(check_equality(\"a\"))      # Output: True\nprint(check_equality(\"\"))       # Output: False\n\n\n",
        "base_tests": [
            "assert check_equality(\"abcda\") == \"Equal\"",
            "assert check_equality(\"ab\") == \"Not Equal\"",
            "assert check_equality(\"mad\") == \"Not Equal\""
        ],
        "tests": [
            "assert check_equality('Abca') == 'Equal'\nassert check_equality('AbC') == 'Not Equal'"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 's': str, and the return type should be annotated as str.",
        "code_before": "def check_equality(input_string):\n    \"\"\"\n    This function checks whether the first and last characters of a given string are equal or not.\n    \n    Args:\n    input_string (str): The string to be checked.\n    \n    Returns:\n    bool: True if the first and last characters are equal, False otherwise.\n    \"\"\"\n    # Check if the string is empty\n    if not input_string:\n        return False\n    \n    # Compare the first and last characters\n    return input_string[0] == input_string[-1]\n\n# Example usage:\nprint(check_equality(\"radar\"))  # Output: True\nprint(check_equality(\"hello\"))  # Output: False\nprint(check_equality(\"a\"))      # Output: True\nprint(check_equality(\"\"))       # Output: False\n\n\n",
        "base_tests": [
            "assert check_equality(\"abcda\") == \"Equal\"",
            "assert check_equality(\"ab\") == \"Not Equal\"",
            "assert check_equality(\"mad\") == \"Not Equal\""
        ],
        "tests": [
            "assert check_equality.__annotations__ == {'s': str, 'return': str}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple linear control flow.",
        "code_before": "def check_equality(input_string):\n    \"\"\"\n    This function checks whether the first and last characters of a given string are equal or not.\n    \n    Args:\n    input_string (str): The string to be checked.\n    \n    Returns:\n    bool: True if the first and last characters are equal, False otherwise.\n    \"\"\"\n    # Check if the string is empty\n    if not input_string:\n        return False\n    \n    # Compare the first and last characters\n    return input_string[0] == input_string[-1]\n\n# Example usage:\nprint(check_equality(\"radar\"))  # Output: True\nprint(check_equality(\"hello\"))  # Output: False\nprint(check_equality(\"a\"))      # Output: True\nprint(check_equality(\"\"))       # Output: False\n\n\n",
        "base_tests": [
            "assert check_equality(\"abcda\") == \"Equal\"",
            "assert check_equality(\"ab\") == \"Not Equal\"",
            "assert check_equality(\"mad\") == \"Not Equal\""
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(check_equality))[0].complexity <=3"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation and spacing.",
        "code_before": "def check_equality(input_string):\n    \"\"\"\n    This function checks whether the first and last characters of a given string are equal or not.\n    \n    Args:\n    input_string (str): The string to be checked.\n    \n    Returns:\n    bool: True if the first and last characters are equal, False otherwise.\n    \"\"\"\n    # Check if the string is empty\n    if not input_string:\n        return False\n    \n    # Compare the first and last characters\n    return input_string[0] == input_string[-1]\n\n# Example usage:\nprint(check_equality(\"radar\"))  # Output: True\nprint(check_equality(\"hello\"))  # Output: False\nprint(check_equality(\"a\"))      # Output: True\nprint(check_equality(\"\"))       # Output: False\n\n\n",
        "base_tests": [
            "assert check_equality(\"abcda\") == \"Equal\"",
            "assert check_equality(\"ab\") == \"Not Equal\"",
            "assert check_equality(\"mad\") == \"Not Equal\""
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(check_equality)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'counting_sort' to sort the given array by using counting sort.",
        "instruction": "The function should accept only a list of non-negative integers as input and return a sorted list of integers.",
        "code_before": "def counting_sort(arr):\n    if not arr:\n        return arr\n\n    # Find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n\n    # Create a count array to store the count of each unique object\n    range_of_elements = max_val - min_val + 1\n    count = [0 for _ in range(range_of_elements)]\n\n    # Store the count of each unique object\n    for num in arr:\n        count[num - min_val] += 1\n\n    # Modify the count array by adding the previous counts (cumulative count)\n    for i in range(1, range_of_elements):\n        count[i] += count[i - 1]\n\n    # Output array to store the sorted order\n    output = [0 for _ in range(len(arr))]\n\n    # Build the output array using the count array\n    for num in reversed(arr):\n        output[count[num - min_val] - 1] = num\n        count[num - min_val] -= 1\n\n    return output\n\n\n",
        "base_tests": [
            "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
            "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
            "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"
        ],
        "tests": [
            "assert counting_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]\nassert counting_sort([10, 0, 5, 5]) == [0, 5, 5, 10]"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'counting_sort' to sort the given array by using counting sort.",
        "instruction": "The function should raise a TypeError if the input is not a list or contains non-integer elements.",
        "code_before": "def counting_sort(arr):\n    if not arr:\n        return arr\n\n    # Find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n\n    # Create a count array to store the count of each unique object\n    range_of_elements = max_val - min_val + 1\n    count = [0 for _ in range(range_of_elements)]\n\n    # Store the count of each unique object\n    for num in arr:\n        count[num - min_val] += 1\n\n    # Modify the count array by adding the previous counts (cumulative count)\n    for i in range(1, range_of_elements):\n        count[i] += count[i - 1]\n\n    # Output array to store the sorted order\n    output = [0 for _ in range(len(arr))]\n\n    # Build the output array using the count array\n    for num in reversed(arr):\n        output[count[num - min_val] - 1] = num\n        count[num - min_val] -= 1\n\n    return output\n\n\n",
        "base_tests": [
            "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
            "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
            "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"
        ],
        "tests": [
            "try:\n    counting_sort('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    counting_sort([1, 'a', 3])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'counting_sort' to sort the given array by using counting sort.",
        "instruction": "The function should correctly handle edge cases such as an empty list or a list with a single element.",
        "code_before": "def counting_sort(arr):\n    if not arr:\n        return arr\n\n    # Find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n\n    # Create a count array to store the count of each unique object\n    range_of_elements = max_val - min_val + 1\n    count = [0 for _ in range(range_of_elements)]\n\n    # Store the count of each unique object\n    for num in arr:\n        count[num - min_val] += 1\n\n    # Modify the count array by adding the previous counts (cumulative count)\n    for i in range(1, range_of_elements):\n        count[i] += count[i - 1]\n\n    # Output array to store the sorted order\n    output = [0 for _ in range(len(arr))]\n\n    # Build the output array using the count array\n    for num in reversed(arr):\n        output[count[num - min_val] - 1] = num\n        count[num - min_val] -= 1\n\n    return output\n\n\n",
        "base_tests": [
            "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
            "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
            "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"
        ],
        "tests": [
            "assert counting_sort([]) == []\nassert counting_sort([42]) == [42]"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'counting_sort' to sort the given array by using counting sort.",
        "instruction": "Extend the function to handle lists containing negative integers by sorting them correctly.",
        "code_before": "def counting_sort(arr):\n    if not arr:\n        return arr\n\n    # Find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n\n    # Create a count array to store the count of each unique object\n    range_of_elements = max_val - min_val + 1\n    count = [0 for _ in range(range_of_elements)]\n\n    # Store the count of each unique object\n    for num in arr:\n        count[num - min_val] += 1\n\n    # Modify the count array by adding the previous counts (cumulative count)\n    for i in range(1, range_of_elements):\n        count[i] += count[i - 1]\n\n    # Output array to store the sorted order\n    output = [0 for _ in range(len(arr))]\n\n    # Build the output array using the count array\n    for num in reversed(arr):\n        output[count[num - min_val] - 1] = num\n        count[num - min_val] -= 1\n\n    return output\n\n\n",
        "base_tests": [
            "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
            "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
            "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"
        ],
        "tests": [
            "assert counting_sort([-5, -1, -3, 0, 2, 1]) == [-5, -3, -1, 0, 1, 2]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'counting_sort' to sort the given array by using counting sort.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'arr': list, and the return type should be annotated as list.",
        "code_before": "def counting_sort(arr):\n    if not arr:\n        return arr\n\n    # Find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n\n    # Create a count array to store the count of each unique object\n    range_of_elements = max_val - min_val + 1\n    count = [0 for _ in range(range_of_elements)]\n\n    # Store the count of each unique object\n    for num in arr:\n        count[num - min_val] += 1\n\n    # Modify the count array by adding the previous counts (cumulative count)\n    for i in range(1, range_of_elements):\n        count[i] += count[i - 1]\n\n    # Output array to store the sorted order\n    output = [0 for _ in range(len(arr))]\n\n    # Build the output array using the count array\n    for num in reversed(arr):\n        output[count[num - min_val] - 1] = num\n        count[num - min_val] -= 1\n\n    return output\n\n\n",
        "base_tests": [
            "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
            "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
            "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"
        ],
        "tests": [
            "def test_annotations():\n    from typing import get_type_hints\n    hints = get_type_hints(counting_sort)\n    assert hints == {'arr': list, 'return': list}\ntest_annotations()"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'counting_sort' to sort the given array by using counting sort.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def counting_sort(arr):\n    if not arr:\n        return arr\n\n    # Find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n\n    # Create a count array to store the count of each unique object\n    range_of_elements = max_val - min_val + 1\n    count = [0 for _ in range(range_of_elements)]\n\n    # Store the count of each unique object\n    for num in arr:\n        count[num - min_val] += 1\n\n    # Modify the count array by adding the previous counts (cumulative count)\n    for i in range(1, range_of_elements):\n        count[i] += count[i - 1]\n\n    # Output array to store the sorted order\n    output = [0 for _ in range(len(arr))]\n\n    # Build the output array using the count array\n    for num in reversed(arr):\n        output[count[num - min_val] - 1] = num\n        count[num - min_val] -= 1\n\n    return output\n\n\n",
        "base_tests": [
            "assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]",
            "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]",
            "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(counting_sort)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'tn_gp' to find t-nth term of geometric series.",
        "instruction": "The function should raise a ValueError with the message 'Term number must be greater than 0' if the term number (n) is less than 1, as it is not possible to have a non-positive term number in a geometric series.",
        "code_before": "def tn_gp(a, r, n):\n    \"\"\"\n    Function to find the t-nth term of a geometric series.\n    \n    Parameters:\n    a (float): The first term of the geometric series.\n    r (float): The common ratio of the geometric series.\n    n (int): The term number to find in the series.\n    \n    Returns:\n    float: The t-nth term of the geometric series.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"The term number n must be a positive integer.\")\n    return a * (r ** (n - 1))\n\n# Example usage:\n# a = 2, r = 3, n = 4\n# The series is 2, 6, 18, 54, ...\n# The 4th term is 54.\nprint(tn_gp(2, 3, 4))  # Output: 54\n\n\n",
        "base_tests": [
            "assert tn_gp(1,5,2)==16",
            "assert tn_gp(1,5,4)==256",
            "assert tn_gp(2,6,3)==486"
        ],
        "tests": [
            "try:\n    tn_gp(1, 5, 0)\nexcept ValueError as e:\n    assert str(e) == 'Term number must be greater than 0'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'tn_gp' to find t-nth term of geometric series.",
        "instruction": "The function should correctly handle the edge case where the common ratio (r) is zero, returning zero for all terms beyond the first.",
        "code_before": "def tn_gp(a, r, n):\n    \"\"\"\n    Function to find the t-nth term of a geometric series.\n    \n    Parameters:\n    a (float): The first term of the geometric series.\n    r (float): The common ratio of the geometric series.\n    n (int): The term number to find in the series.\n    \n    Returns:\n    float: The t-nth term of the geometric series.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"The term number n must be a positive integer.\")\n    return a * (r ** (n - 1))\n\n# Example usage:\n# a = 2, r = 3, n = 4\n# The series is 2, 6, 18, 54, ...\n# The 4th term is 54.\nprint(tn_gp(2, 3, 4))  # Output: 54\n\n\n",
        "base_tests": [
            "assert tn_gp(1,5,2)==16",
            "assert tn_gp(1,5,4)==256",
            "assert tn_gp(2,6,3)==486"
        ],
        "tests": [
            "assert tn_gp(3, 0, 5) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'tn_gp' to find t-nth term of geometric series.",
        "instruction": "Extend the function to handle floating-point numbers for the first term and common ratio, returning a floating-point number for the n-th term.",
        "code_before": "def tn_gp(a, r, n):\n    \"\"\"\n    Function to find the t-nth term of a geometric series.\n    \n    Parameters:\n    a (float): The first term of the geometric series.\n    r (float): The common ratio of the geometric series.\n    n (int): The term number to find in the series.\n    \n    Returns:\n    float: The t-nth term of the geometric series.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"The term number n must be a positive integer.\")\n    return a * (r ** (n - 1))\n\n# Example usage:\n# a = 2, r = 3, n = 4\n# The series is 2, 6, 18, 54, ...\n# The 4th term is 54.\nprint(tn_gp(2, 3, 4))  # Output: 54\n\n\n",
        "base_tests": [
            "assert tn_gp(1,5,2)==16",
            "assert tn_gp(1,5,4)==256",
            "assert tn_gp(2,6,3)==486"
        ],
        "tests": [
            "assert tn_gp(1.5, 2.5, 3) == 9.375"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'tn_gp' to find t-nth term of geometric series.",
        "instruction": "The function should include type annotations for all parameters and the return type to improve code readability and maintainability. The parameter should be annotated as 'a': int, 'r': int, 'n': int, and the return type should be annotated as int.",
        "code_before": "def tn_gp(a, r, n):\n    \"\"\"\n    Function to find the t-nth term of a geometric series.\n    \n    Parameters:\n    a (float): The first term of the geometric series.\n    r (float): The common ratio of the geometric series.\n    n (int): The term number to find in the series.\n    \n    Returns:\n    float: The t-nth term of the geometric series.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"The term number n must be a positive integer.\")\n    return a * (r ** (n - 1))\n\n# Example usage:\n# a = 2, r = 3, n = 4\n# The series is 2, 6, 18, 54, ...\n# The 4th term is 54.\nprint(tn_gp(2, 3, 4))  # Output: 54\n\n\n",
        "base_tests": [
            "assert tn_gp(1,5,2)==16",
            "assert tn_gp(1,5,4)==256",
            "assert tn_gp(2,6,3)==486"
        ],
        "tests": [
            "assert tn_gp.__annotations__ == {'a': int, 'r': int, 'n': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'tn_gp' to find t-nth term of geometric series.",
        "instruction": "The function should adhere to PEP 8 standards, including proper indentation, spacing, and naming conventions.",
        "code_before": "def tn_gp(a, r, n):\n    \"\"\"\n    Function to find the t-nth term of a geometric series.\n    \n    Parameters:\n    a (float): The first term of the geometric series.\n    r (float): The common ratio of the geometric series.\n    n (int): The term number to find in the series.\n    \n    Returns:\n    float: The t-nth term of the geometric series.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"The term number n must be a positive integer.\")\n    return a * (r ** (n - 1))\n\n# Example usage:\n# a = 2, r = 3, n = 4\n# The series is 2, 6, 18, 54, ...\n# The 4th term is 54.\nprint(tn_gp(2, 3, 4))  # Output: 54\n\n\n",
        "base_tests": [
            "assert tn_gp(1,5,2)==16",
            "assert tn_gp(1,5,4)==256",
            "assert tn_gp(2,6,3)==486"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(tn_gp)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'check' to check if a given number is one less than twice its reverse.",
        "instruction": "The function should raise a TypeError if the input is not an integer.",
        "code_before": "def check(number):\n    \"\"\"\n    Check if the given number is one less than twice its reverse.\n\n    Args:\n    number (int): The number to check.\n\n    Returns:\n    bool: True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    # Convert the number to a string to reverse it\n    reversed_number_str = str(number)[::-1]\n    \n    # Convert the reversed string back to an integer\n    reversed_number = int(reversed_number_str)\n    \n    # Check if the number is one less than twice its reverse\n    return number == 2 * reversed_number - 1\n\n# Example usage:\nprint(check(21))  # True, because 21 is one less than twice its reverse (12)\nprint(check(12))  # False, because 12 is not one less than twice its reverse (21)\n\n\n",
        "base_tests": [
            "assert check(70) == False",
            "assert check(23) == False",
            "assert check(73) == True"
        ],
        "tests": [
            "try:\n    check('73')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for non-integer input'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'check' to check if a given number is one less than twice its reverse.",
        "instruction": "The function should correctly handle edge cases such as single-digit numbers and zero.",
        "code_before": "def check(number):\n    \"\"\"\n    Check if the given number is one less than twice its reverse.\n\n    Args:\n    number (int): The number to check.\n\n    Returns:\n    bool: True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    # Convert the number to a string to reverse it\n    reversed_number_str = str(number)[::-1]\n    \n    # Convert the reversed string back to an integer\n    reversed_number = int(reversed_number_str)\n    \n    # Check if the number is one less than twice its reverse\n    return number == 2 * reversed_number - 1\n\n# Example usage:\nprint(check(21))  # True, because 21 is one less than twice its reverse (12)\nprint(check(12))  # False, because 12 is not one less than twice its reverse (21)\n\n\n",
        "base_tests": [
            "assert check(70) == False",
            "assert check(23) == False",
            "assert check(73) == True"
        ],
        "tests": [
            "assert check(0) == False\nassert check(1) == False\nassert check(9) == False"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'check' to check if a given number is one less than twice its reverse.",
        "instruction": "Extend the function to handle negative numbers correctly, considering the reverse of a negative number as negative.",
        "code_before": "def check(number):\n    \"\"\"\n    Check if the given number is one less than twice its reverse.\n\n    Args:\n    number (int): The number to check.\n\n    Returns:\n    bool: True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    # Convert the number to a string to reverse it\n    reversed_number_str = str(number)[::-1]\n    \n    # Convert the reversed string back to an integer\n    reversed_number = int(reversed_number_str)\n    \n    # Check if the number is one less than twice its reverse\n    return number == 2 * reversed_number - 1\n\n# Example usage:\nprint(check(21))  # True, because 21 is one less than twice its reverse (12)\nprint(check(12))  # False, because 12 is not one less than twice its reverse (21)\n\n\n",
        "base_tests": [
            "assert check(70) == False",
            "assert check(23) == False",
            "assert check(73) == True"
        ],
        "tests": [
            "assert check(-73) == False\nassert check(-37) == True"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'check' to check if a given number is one less than twice its reverse.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as bool.",
        "code_before": "def check(number):\n    \"\"\"\n    Check if the given number is one less than twice its reverse.\n\n    Args:\n    number (int): The number to check.\n\n    Returns:\n    bool: True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    # Convert the number to a string to reverse it\n    reversed_number_str = str(number)[::-1]\n    \n    # Convert the reversed string back to an integer\n    reversed_number = int(reversed_number_str)\n    \n    # Check if the number is one less than twice its reverse\n    return number == 2 * reversed_number - 1\n\n# Example usage:\nprint(check(21))  # True, because 21 is one less than twice its reverse (12)\nprint(check(12))  # False, because 12 is not one less than twice its reverse (21)\n\n\n",
        "base_tests": [
            "assert check(70) == False",
            "assert check(23) == False",
            "assert check(73) == True"
        ],
        "tests": [
            "assert check.__annotations__ == {'n': int, 'return': bool}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'check' to check if a given number is one less than twice its reverse.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple, linear control flow.",
        "code_before": "def check(number):\n    \"\"\"\n    Check if the given number is one less than twice its reverse.\n\n    Args:\n    number (int): The number to check.\n\n    Returns:\n    bool: True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    # Convert the number to a string to reverse it\n    reversed_number_str = str(number)[::-1]\n    \n    # Convert the reversed string back to an integer\n    reversed_number = int(reversed_number_str)\n    \n    # Check if the number is one less than twice its reverse\n    return number == 2 * reversed_number - 1\n\n# Example usage:\nprint(check(21))  # True, because 21 is one less than twice its reverse (12)\nprint(check(12))  # False, because 12 is not one less than twice its reverse (21)\n\n\n",
        "base_tests": [
            "assert check(70) == False",
            "assert check(23) == False",
            "assert check(73) == True"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(check))[0].complexity <=3"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'check' to check if a given number is one less than twice its reverse.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def check(number):\n    \"\"\"\n    Check if the given number is one less than twice its reverse.\n\n    Args:\n    number (int): The number to check.\n\n    Returns:\n    bool: True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    # Convert the number to a string to reverse it\n    reversed_number_str = str(number)[::-1]\n    \n    # Convert the reversed string back to an integer\n    reversed_number = int(reversed_number_str)\n    \n    # Check if the number is one less than twice its reverse\n    return number == 2 * reversed_number - 1\n\n# Example usage:\nprint(check(21))  # True, because 21 is one less than twice its reverse (12)\nprint(check(12))  # False, because 12 is not one less than twice its reverse (21)\n\n\n",
        "base_tests": [
            "assert check(70) == False",
            "assert check(23) == False",
            "assert check(73) == True"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(check)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'find_max_num' to find the largest number that can be formed with the given digits.",
        "instruction": "The function should accept a list of integers and an integer representing the number of digits, and return an integer representing the largest number that can be formed.",
        "code_before": "def find_max_num(digits):\n    \"\"\"\n    This function takes a list of digits and returns the largest number that can be formed with those digits.\n    \n    :param digits: List of integers representing the digits\n    :return: Integer representing the largest number that can be formed\n    \"\"\"\n    # Convert each digit to a string and sort the list in descending order\n    digits_str = [str(digit) for digit in digits]\n    digits_str.sort(reverse=True)\n    \n    # Join the sorted list into a single string and convert it back to an integer\n    max_num = int(''.join(digits_str))\n    \n    return max_num\n\n# Example usage:\ndigits = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nprint(find_max_num(digits))  # Output: 96555433211\n\n\n",
        "base_tests": [
            "assert find_max_num([1,2,3],3) == 321",
            "assert find_max_num([4,5,6,1],4) == 6541",
            "assert find_max_num([1,2,3,9],4) == 9321"
        ],
        "tests": [
            "assert find_max_num([7, 8, 9], 3) == 987"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'find_max_num' to find the largest number that can be formed with the given digits.",
        "instruction": "The function should raise a ValueError with the message 'Number of digits exceeds the length of the list.' if the number of digits specified is greater than the length of the list of digits.",
        "code_before": "def find_max_num(digits):\n    \"\"\"\n    This function takes a list of digits and returns the largest number that can be formed with those digits.\n    \n    :param digits: List of integers representing the digits\n    :return: Integer representing the largest number that can be formed\n    \"\"\"\n    # Convert each digit to a string and sort the list in descending order\n    digits_str = [str(digit) for digit in digits]\n    digits_str.sort(reverse=True)\n    \n    # Join the sorted list into a single string and convert it back to an integer\n    max_num = int(''.join(digits_str))\n    \n    return max_num\n\n# Example usage:\ndigits = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nprint(find_max_num(digits))  # Output: 96555433211\n\n\n",
        "base_tests": [
            "assert find_max_num([1,2,3],3) == 321",
            "assert find_max_num([4,5,6,1],4) == 6541",
            "assert find_max_num([1,2,3,9],4) == 9321"
        ],
        "tests": [
            "try:\n    find_max_num([1, 2], 3)\nexcept ValueError as e:\n    assert str(e) == 'Number of digits exceeds the length of the list.'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'find_max_num' to find the largest number that can be formed with the given digits.",
        "instruction": "The function should correctly handle the edge case where the list of digits is empty, returning 0.",
        "code_before": "def find_max_num(digits):\n    \"\"\"\n    This function takes a list of digits and returns the largest number that can be formed with those digits.\n    \n    :param digits: List of integers representing the digits\n    :return: Integer representing the largest number that can be formed\n    \"\"\"\n    # Convert each digit to a string and sort the list in descending order\n    digits_str = [str(digit) for digit in digits]\n    digits_str.sort(reverse=True)\n    \n    # Join the sorted list into a single string and convert it back to an integer\n    max_num = int(''.join(digits_str))\n    \n    return max_num\n\n# Example usage:\ndigits = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nprint(find_max_num(digits))  # Output: 96555433211\n\n\n",
        "base_tests": [
            "assert find_max_num([1,2,3],3) == 321",
            "assert find_max_num([4,5,6,1],4) == 6541",
            "assert find_max_num([1,2,3,9],4) == 9321"
        ],
        "tests": [
            "assert find_max_num([], 0) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'find_max_num' to find the largest number that can be formed with the given digits.",
        "instruction": "Extend the function to handle a list of digits containing duplicate numbers, ensuring the largest number is still formed.",
        "code_before": "def find_max_num(digits):\n    \"\"\"\n    This function takes a list of digits and returns the largest number that can be formed with those digits.\n    \n    :param digits: List of integers representing the digits\n    :return: Integer representing the largest number that can be formed\n    \"\"\"\n    # Convert each digit to a string and sort the list in descending order\n    digits_str = [str(digit) for digit in digits]\n    digits_str.sort(reverse=True)\n    \n    # Join the sorted list into a single string and convert it back to an integer\n    max_num = int(''.join(digits_str))\n    \n    return max_num\n\n# Example usage:\ndigits = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nprint(find_max_num(digits))  # Output: 96555433211\n\n\n",
        "base_tests": [
            "assert find_max_num([1,2,3],3) == 321",
            "assert find_max_num([4,5,6,1],4) == 6541",
            "assert find_max_num([1,2,3,9],4) == 9321"
        ],
        "tests": [
            "assert find_max_num([1, 1, 2, 2], 4) == 2211"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'find_max_num' to find the largest number that can be formed with the given digits.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'digits': list, 'n': int, and the return type should be annotated as int.",
        "code_before": "def find_max_num(digits):\n    \"\"\"\n    This function takes a list of digits and returns the largest number that can be formed with those digits.\n    \n    :param digits: List of integers representing the digits\n    :return: Integer representing the largest number that can be formed\n    \"\"\"\n    # Convert each digit to a string and sort the list in descending order\n    digits_str = [str(digit) for digit in digits]\n    digits_str.sort(reverse=True)\n    \n    # Join the sorted list into a single string and convert it back to an integer\n    max_num = int(''.join(digits_str))\n    \n    return max_num\n\n# Example usage:\ndigits = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nprint(find_max_num(digits))  # Output: 96555433211\n\n\n",
        "base_tests": [
            "assert find_max_num([1,2,3],3) == 321",
            "assert find_max_num([4,5,6,1],4) == 6541",
            "assert find_max_num([1,2,3,9],4) == 9321"
        ],
        "tests": [
            "assert find_max_num.__annotations__ == {'digits': list, 'n': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'find_max_num' to find the largest number that can be formed with the given digits.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def find_max_num(digits):\n    \"\"\"\n    This function takes a list of digits and returns the largest number that can be formed with those digits.\n    \n    :param digits: List of integers representing the digits\n    :return: Integer representing the largest number that can be formed\n    \"\"\"\n    # Convert each digit to a string and sort the list in descending order\n    digits_str = [str(digit) for digit in digits]\n    digits_str.sort(reverse=True)\n    \n    # Join the sorted list into a single string and convert it back to an integer\n    max_num = int(''.join(digits_str))\n    \n    return max_num\n\n# Example usage:\ndigits = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nprint(find_max_num(digits))  # Output: 96555433211\n\n\n",
        "base_tests": [
            "assert find_max_num([1,2,3],3) == 321",
            "assert find_max_num([4,5,6,1],4) == 6541",
            "assert find_max_num([1,2,3,9],4) == 9321"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_max_num)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.",
        "instruction": "The function should accept only integer inputs and return a boolean value indicating whether the integers have opposite signs.",
        "code_before": "def opposite_signs(x, y):\n    \"\"\"\n    Check if two integers have opposite signs.\n\n    Args:\n    x (int): First integer.\n    y (int): Second integer.\n\n    Returns:\n    bool: True if x and y have opposite signs, False otherwise.\n    \"\"\"\n    return (x ^ y) < 0\n\n\n",
        "base_tests": [
            "assert opposite_signs(1,-2) == True",
            "assert opposite_signs(3,2) == False",
            "assert opposite_signs(-10,-10) == False"
        ],
        "tests": [
            "assert opposite_signs(5, -5) == True",
            "assert opposite_signs(0, 0) == False",
            "assert opposite_signs(-7, 7) == True"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.",
        "instruction": "The function should raise a TypeError if the inputs are not integers.",
        "code_before": "def opposite_signs(x, y):\n    \"\"\"\n    Check if two integers have opposite signs.\n\n    Args:\n    x (int): First integer.\n    y (int): Second integer.\n\n    Returns:\n    bool: True if x and y have opposite signs, False otherwise.\n    \"\"\"\n    return (x ^ y) < 0\n\n\n",
        "base_tests": [
            "assert opposite_signs(1,-2) == True",
            "assert opposite_signs(3,2) == False",
            "assert opposite_signs(-10,-10) == False"
        ],
        "tests": [
            "try:\n    opposite_signs(1.5, -2)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for float input'",
            "try:\n    opposite_signs('a', 2)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for string input'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.",
        "instruction": "The function should correctly handle edge cases such as zero and large integers.",
        "code_before": "def opposite_signs(x, y):\n    \"\"\"\n    Check if two integers have opposite signs.\n\n    Args:\n    x (int): First integer.\n    y (int): Second integer.\n\n    Returns:\n    bool: True if x and y have opposite signs, False otherwise.\n    \"\"\"\n    return (x ^ y) < 0\n\n\n",
        "base_tests": [
            "assert opposite_signs(1,-2) == True",
            "assert opposite_signs(3,2) == False",
            "assert opposite_signs(-10,-10) == False"
        ],
        "tests": [
            "assert opposite_signs(0, -1) == True",
            "assert opposite_signs(0, 1) == True",
            "assert opposite_signs(0, 0) == False",
            "assert opposite_signs(2147483647, -2147483648) == True"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.",
        "instruction": "Extend the function to handle a list of integer pairs and return a list of boolean values indicating opposite signs for each pair.",
        "code_before": "def opposite_signs(x, y):\n    \"\"\"\n    Check if two integers have opposite signs.\n\n    Args:\n    x (int): First integer.\n    y (int): Second integer.\n\n    Returns:\n    bool: True if x and y have opposite signs, False otherwise.\n    \"\"\"\n    return (x ^ y) < 0\n\n\n",
        "base_tests": [
            "assert opposite_signs(1,-2) == True",
            "assert opposite_signs(3,2) == False",
            "assert opposite_signs(-10,-10) == False"
        ],
        "tests": [
            "assert opposite_signs_list([(1, -2), (3, 2), (-10, -10)]) == [True, False, False]",
            "assert opposite_signs_list([(0, 0), (0, -1), (1, 1)]) == [False, True, False]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'a': int, 'b': int, and the return type should be annotated as bool.",
        "code_before": "def opposite_signs(x, y):\n    \"\"\"\n    Check if two integers have opposite signs.\n\n    Args:\n    x (int): First integer.\n    y (int): Second integer.\n\n    Returns:\n    bool: True if x and y have opposite signs, False otherwise.\n    \"\"\"\n    return (x ^ y) < 0\n\n\n",
        "base_tests": [
            "assert opposite_signs(1,-2) == True",
            "assert opposite_signs(3,2) == False",
            "assert opposite_signs(-10,-10) == False"
        ],
        "tests": [
            "assert opposite_signs.__annotations__ == {'a': int, 'b': int, 'return': bool}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.",
        "instruction": "The function should have a cyclomatic complexity of 1, indicating a simple, linear control flow.",
        "code_before": "def opposite_signs(x, y):\n    \"\"\"\n    Check if two integers have opposite signs.\n\n    Args:\n    x (int): First integer.\n    y (int): Second integer.\n\n    Returns:\n    bool: True if x and y have opposite signs, False otherwise.\n    \"\"\"\n    return (x ^ y) < 0\n\n\n",
        "base_tests": [
            "assert opposite_signs(1,-2) == True",
            "assert opposite_signs(3,2) == False",
            "assert opposite_signs(-10,-10) == False"
        ],
        "tests": [
            "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(opposite_signs))[0].complexity <=3"
        ],
        "ins_type": "Code Complexity"
    },
    {
        "prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.",
        "instruction": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.",
        "code_before": "def opposite_signs(x, y):\n    \"\"\"\n    Check if two integers have opposite signs.\n\n    Args:\n    x (int): First integer.\n    y (int): Second integer.\n\n    Returns:\n    bool: True if x and y have opposite signs, False otherwise.\n    \"\"\"\n    return (x ^ y) < 0\n\n\n",
        "base_tests": [
            "assert opposite_signs(1,-2) == True",
            "assert opposite_signs(3,2) == False",
            "assert opposite_signs(-10,-10) == False"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(opposite_signs)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'is_octagonal' to find the nth octagonal number.",
        "instruction": "The function should raise a ValueError as 'Input must be a positive integer' if the input is not a positive integer.",
        "code_before": "def is_octagonal(n):\n    \"\"\"\n    This function checks if a given number 'n' is an octagonal number.\n    An octagonal number is a figurate number that represents an octagon.\n    The nth octagonal number is given by the formula: O_n = n * (3 * n - 2).\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if 'n' is an octagonal number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    \n    # Calculate the potential position in the octagonal sequence\n    potential_position = (2 + (n ** 0.5)) / 3\n    \n    # Check if the potential position is an integer\n    return potential_position.is_integer()\n\ndef nth_octagonal_number(n):\n    \"\"\"\n    This function calculates the nth octagonal number.\n    The nth octagonal number is given by the formula: O_n = n * (3 * n - 2).\n    \n    Parameters:\n    n (int): The position in the octagonal sequence.\n    \n    Returns:\n    int: The nth octagonal number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return n * (3 * n - 2)\n\n# Example usage:\nn = 5\nprint(f\"The {n}th octagonal number is: {nth_octagonal_number(n)}\")\nprint(f\"Is {n} an octagonal number? {is_octagonal(n)}\")\n\n\n",
        "base_tests": [
            "assert is_octagonal(5) == 65",
            "assert is_octagonal(10) == 280",
            "assert is_octagonal(15) == 645"
        ],
        "tests": [
            "try:\n    is_octagonal(-1)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a positive integer'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'is_octagonal' to find the nth octagonal number.",
        "instruction": "The function should correctly handle the edge case where n is 1, returning the first octagonal number.",
        "code_before": "def is_octagonal(n):\n    \"\"\"\n    This function checks if a given number 'n' is an octagonal number.\n    An octagonal number is a figurate number that represents an octagon.\n    The nth octagonal number is given by the formula: O_n = n * (3 * n - 2).\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if 'n' is an octagonal number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    \n    # Calculate the potential position in the octagonal sequence\n    potential_position = (2 + (n ** 0.5)) / 3\n    \n    # Check if the potential position is an integer\n    return potential_position.is_integer()\n\ndef nth_octagonal_number(n):\n    \"\"\"\n    This function calculates the nth octagonal number.\n    The nth octagonal number is given by the formula: O_n = n * (3 * n - 2).\n    \n    Parameters:\n    n (int): The position in the octagonal sequence.\n    \n    Returns:\n    int: The nth octagonal number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return n * (3 * n - 2)\n\n# Example usage:\nn = 5\nprint(f\"The {n}th octagonal number is: {nth_octagonal_number(n)}\")\nprint(f\"Is {n} an octagonal number? {is_octagonal(n)}\")\n\n\n",
        "base_tests": [
            "assert is_octagonal(5) == 65",
            "assert is_octagonal(10) == 280",
            "assert is_octagonal(15) == 645"
        ],
        "tests": [
            "assert is_octagonal(1) == 1"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'is_octagonal' to find the nth octagonal number.",
        "instruction": "Extend the function to return a list of the first n octagonal numbers if n is a list.",
        "code_before": "def is_octagonal(n):\n    \"\"\"\n    This function checks if a given number 'n' is an octagonal number.\n    An octagonal number is a figurate number that represents an octagon.\n    The nth octagonal number is given by the formula: O_n = n * (3 * n - 2).\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if 'n' is an octagonal number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    \n    # Calculate the potential position in the octagonal sequence\n    potential_position = (2 + (n ** 0.5)) / 3\n    \n    # Check if the potential position is an integer\n    return potential_position.is_integer()\n\ndef nth_octagonal_number(n):\n    \"\"\"\n    This function calculates the nth octagonal number.\n    The nth octagonal number is given by the formula: O_n = n * (3 * n - 2).\n    \n    Parameters:\n    n (int): The position in the octagonal sequence.\n    \n    Returns:\n    int: The nth octagonal number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return n * (3 * n - 2)\n\n# Example usage:\nn = 5\nprint(f\"The {n}th octagonal number is: {nth_octagonal_number(n)}\")\nprint(f\"Is {n} an octagonal number? {is_octagonal(n)}\")\n\n\n",
        "base_tests": [
            "assert is_octagonal(5) == 65",
            "assert is_octagonal(10) == 280",
            "assert is_octagonal(15) == 645"
        ],
        "tests": [
            "assert is_octagonal([1, 2, 3]) == [1, 8, 21]"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'is_octagonal' to find the nth octagonal number.",
        "instruction": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as int.",
        "code_before": "def is_octagonal(n):\n    \"\"\"\n    This function checks if a given number 'n' is an octagonal number.\n    An octagonal number is a figurate number that represents an octagon.\n    The nth octagonal number is given by the formula: O_n = n * (3 * n - 2).\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if 'n' is an octagonal number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    \n    # Calculate the potential position in the octagonal sequence\n    potential_position = (2 + (n ** 0.5)) / 3\n    \n    # Check if the potential position is an integer\n    return potential_position.is_integer()\n\ndef nth_octagonal_number(n):\n    \"\"\"\n    This function calculates the nth octagonal number.\n    The nth octagonal number is given by the formula: O_n = n * (3 * n - 2).\n    \n    Parameters:\n    n (int): The position in the octagonal sequence.\n    \n    Returns:\n    int: The nth octagonal number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return n * (3 * n - 2)\n\n# Example usage:\nn = 5\nprint(f\"The {n}th octagonal number is: {nth_octagonal_number(n)}\")\nprint(f\"Is {n} an octagonal number? {is_octagonal(n)}\")\n\n\n",
        "base_tests": [
            "assert is_octagonal(5) == 65",
            "assert is_octagonal(10) == 280",
            "assert is_octagonal(15) == 645"
        ],
        "tests": [
            "assert is_octagonal.__annotations__ == {'n': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'is_octagonal' to find the nth octagonal number.",
        "instruction": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.",
        "code_before": "def is_octagonal(n):\n    \"\"\"\n    This function checks if a given number 'n' is an octagonal number.\n    An octagonal number is a figurate number that represents an octagon.\n    The nth octagonal number is given by the formula: O_n = n * (3 * n - 2).\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if 'n' is an octagonal number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    \n    # Calculate the potential position in the octagonal sequence\n    potential_position = (2 + (n ** 0.5)) / 3\n    \n    # Check if the potential position is an integer\n    return potential_position.is_integer()\n\ndef nth_octagonal_number(n):\n    \"\"\"\n    This function calculates the nth octagonal number.\n    The nth octagonal number is given by the formula: O_n = n * (3 * n - 2).\n    \n    Parameters:\n    n (int): The position in the octagonal sequence.\n    \n    Returns:\n    int: The nth octagonal number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return n * (3 * n - 2)\n\n# Example usage:\nn = 5\nprint(f\"The {n}th octagonal number is: {nth_octagonal_number(n)}\")\nprint(f\"Is {n} an octagonal number? {is_octagonal(n)}\")\n\n\n",
        "base_tests": [
            "assert is_octagonal(5) == 65",
            "assert is_octagonal(10) == 280",
            "assert is_octagonal(15) == 645"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(is_octagonal)"
        ],
        "ins_type": "Code Standard"
    },
    {
        "prompt": "Write a function called 'max_len_sub' to find the maximum length of the subsequence with difference between adjacent elements for the given array.",
        "instruction": "The function should accept an array of integers and an integer as input, and return an integer representing the maximum length of the subsequence.",
        "code_before": "def max_len_sub(arr, diff):\n    \"\"\"\n    Finds the maximum length of the subsequence with difference between adjacent elements\n    equal to the given difference.\n\n    :param arr: List of integers\n    :param diff: Integer, the required difference between adjacent elements\n    :return: Integer, the maximum length of the subsequence\n    \"\"\"\n    if not arr:\n        return 0\n\n    # Dictionary to store the maximum length of subsequence ending with a particular element\n    dp = {}\n\n    for num in arr:\n        # If num - diff is in dp, it means we can extend the subsequence ending with num - diff\n        if num - diff in dp:\n            dp[num] = dp[num - diff] + 1\n        else:\n            dp[num] = 1\n\n    # The result is the maximum value in the dp dictionary\n    return max(dp.values())\n\n\n",
        "base_tests": [
            "assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5",
            "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4",
            "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"
        ],
        "tests": [
            "assert isinstance(max_len_sub([1, 2, 3], 3), int)"
        ],
        "ins_type": "Input-Output Conditions"
    },
    {
        "prompt": "Write a function called 'max_len_sub' to find the maximum length of the subsequence with difference between adjacent elements for the given array.",
        "instruction": "The function should raise a TypeError if the input array is not a list or if the second parameter is not an integer.",
        "code_before": "def max_len_sub(arr, diff):\n    \"\"\"\n    Finds the maximum length of the subsequence with difference between adjacent elements\n    equal to the given difference.\n\n    :param arr: List of integers\n    :param diff: Integer, the required difference between adjacent elements\n    :return: Integer, the maximum length of the subsequence\n    \"\"\"\n    if not arr:\n        return 0\n\n    # Dictionary to store the maximum length of subsequence ending with a particular element\n    dp = {}\n\n    for num in arr:\n        # If num - diff is in dp, it means we can extend the subsequence ending with num - diff\n        if num - diff in dp:\n            dp[num] = dp[num - diff] + 1\n        else:\n            dp[num] = 1\n\n    # The result is the maximum value in the dp dictionary\n    return max(dp.values())\n\n\n",
        "base_tests": [
            "assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5",
            "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4",
            "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"
        ],
        "tests": [
            "try: max_len_sub('not a list', 3)\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'\ntry: max_len_sub([1, 2, 3], 'not an int')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"
        ],
        "ins_type": "Exception Handling"
    },
    {
        "prompt": "Write a function called 'max_len_sub' to find the maximum length of the subsequence with difference between adjacent elements for the given array.",
        "instruction": "The function should return 0 if the input array is empty, as there are no subsequences possible.",
        "code_before": "def max_len_sub(arr, diff):\n    \"\"\"\n    Finds the maximum length of the subsequence with difference between adjacent elements\n    equal to the given difference.\n\n    :param arr: List of integers\n    :param diff: Integer, the required difference between adjacent elements\n    :return: Integer, the maximum length of the subsequence\n    \"\"\"\n    if not arr:\n        return 0\n\n    # Dictionary to store the maximum length of subsequence ending with a particular element\n    dp = {}\n\n    for num in arr:\n        # If num - diff is in dp, it means we can extend the subsequence ending with num - diff\n        if num - diff in dp:\n            dp[num] = dp[num - diff] + 1\n        else:\n            dp[num] = 1\n\n    # The result is the maximum value in the dp dictionary\n    return max(dp.values())\n\n\n",
        "base_tests": [
            "assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5",
            "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4",
            "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"
        ],
        "tests": [
            "assert max_len_sub([], 3) == 0"
        ],
        "ins_type": "Edge Case Handling"
    },
    {
        "prompt": "Write a function called 'max_len_sub' to find the maximum length of the subsequence with difference between adjacent elements for the given array.",
        "instruction": "Extend the function to handle cases where the difference between adjacent elements can be negative, and still find the maximum length of the subsequence.",
        "code_before": "def max_len_sub(arr, diff):\n    \"\"\"\n    Finds the maximum length of the subsequence with difference between adjacent elements\n    equal to the given difference.\n\n    :param arr: List of integers\n    :param diff: Integer, the required difference between adjacent elements\n    :return: Integer, the maximum length of the subsequence\n    \"\"\"\n    if not arr:\n        return 0\n\n    # Dictionary to store the maximum length of subsequence ending with a particular element\n    dp = {}\n\n    for num in arr:\n        # If num - diff is in dp, it means we can extend the subsequence ending with num - diff\n        if num - diff in dp:\n            dp[num] = dp[num - diff] + 1\n        else:\n            dp[num] = 1\n\n    # The result is the maximum value in the dp dictionary\n    return max(dp.values())\n\n\n",
        "base_tests": [
            "assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5",
            "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4",
            "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"
        ],
        "tests": [
            "assert max_len_sub([10, 7, 4, 1, -2], -3) == 5"
        ],
        "ins_type": "Functionality Extension"
    },
    {
        "prompt": "Write a function called 'max_len_sub' to find the maximum length of the subsequence with difference between adjacent elements for the given array.",
        "instruction": "The function should include type annotations for its parameters and return type, indicating that it accepts a list of integers and an integer, and returns an integer.",
        "code_before": "def max_len_sub(arr, diff):\n    \"\"\"\n    Finds the maximum length of the subsequence with difference between adjacent elements\n    equal to the given difference.\n\n    :param arr: List of integers\n    :param diff: Integer, the required difference between adjacent elements\n    :return: Integer, the maximum length of the subsequence\n    \"\"\"\n    if not arr:\n        return 0\n\n    # Dictionary to store the maximum length of subsequence ending with a particular element\n    dp = {}\n\n    for num in arr:\n        # If num - diff is in dp, it means we can extend the subsequence ending with num - diff\n        if num - diff in dp:\n            dp[num] = dp[num - diff] + 1\n        else:\n            dp[num] = 1\n\n    # The result is the maximum value in the dp dictionary\n    return max(dp.values())\n\n\n",
        "base_tests": [
            "assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5",
            "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4",
            "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"
        ],
        "tests": [
            "assert max_len_sub.__annotations__ == {'arr': list, 'diff': int, 'return': int}"
        ],
        "ins_type": "Annotation Coverage"
    },
    {
        "prompt": "Write a function called 'max_len_sub' to find the maximum length of the subsequence with difference between adjacent elements for the given array.",
        "instruction": "The function should follow PEP 8 guidelines, including proper naming conventions, indentation, and spacing.",
        "code_before": "def max_len_sub(arr, diff):\n    \"\"\"\n    Finds the maximum length of the subsequence with difference between adjacent elements\n    equal to the given difference.\n\n    :param arr: List of integers\n    :param diff: Integer, the required difference between adjacent elements\n    :return: Integer, the maximum length of the subsequence\n    \"\"\"\n    if not arr:\n        return 0\n\n    # Dictionary to store the maximum length of subsequence ending with a particular element\n    dp = {}\n\n    for num in arr:\n        # If num - diff is in dp, it means we can extend the subsequence ending with num - diff\n        if num - diff in dp:\n            dp[num] = dp[num - diff] + 1\n        else:\n            dp[num] = 1\n\n    # The result is the maximum value in the dp dictionary\n    return max(dp.values())\n\n\n",
        "base_tests": [
            "assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5",
            "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4",
            "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"
        ],
        "tests": [
            "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(max_len_sub)"
        ],
        "ins_type": "Code Standard"
    }
]