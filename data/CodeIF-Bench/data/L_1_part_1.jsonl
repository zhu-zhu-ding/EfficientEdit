{"prompt": "Write a python function called 'remove_occ' to remove first and last occurrence of a given character from the string.", "test": ["assert remove_occ(\"hello\",\"l\") == \"heo\"", "assert remove_occ(\"abcda\",\"a\") == \"bcd\"", "assert remove_occ(\"PHP\",\"P\") == \"H\""], "code": "def remove_occ(s,ch): \r\n    for i in range(len(s)): \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    for i in range(len(s) - 1,-1,-1):  \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    return s ", "task_id": 11, "requirements": {"Exception Handling": {"requirement": "The function should raise a ValueError with the message 'Second parameter must be a single character.' if the second parameter is not a single character.", "unit_test": "try: remove_occ('hello', 'll')\nexcept ValueError as e: assert str(e) == 'Second parameter must be a single character.'"}, "Edge Case Handling": {"requirement": "The function should return the original string if the character to be removed does not exist in the string.", "unit_test": "assert remove_occ('hello', 'x') == 'hello'"}, "Functionality Extension": {"requirement": "Extend the function to remove all occurrences of the character if a third parameter 'all' is set to True.", "unit_test": "assert remove_occ('banana', 'a', all=True) == 'bnn'"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type, including two parameters: 's': str, 'ch': str, and a return type: str.", "unit_test": "assert remove_occ.__annotations__ == {'s': str, 'ch': str, 'return': str}"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 3 or less.", "unit_test": "from mccabe import get_code_complexity\nimport inspect\nsource_code = inspect.getsource(remove_occ)\nassert get_code_complexity(source_code) <= 3"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 style guidelines, including proper indentation and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(remove_occ)"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function called 'sort_matrix' to sort a given matrix in ascending order according to the sum of its rows.", "test": ["assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]", "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]", "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"], "code": "def sort_matrix(M):\r\n    result = sorted(M, key=sum)\r\n    return result", "task_id": 12, "requirements": {"Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a list of lists or if any element in the matrix is not an integer.", "unit_test": "try: sort_matrix('not a matrix')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'\ntry: sort_matrix([[1, 2], [3, 'a']])\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"}, "Edge Case Handling": {"requirement": "The function should correctly handle an empty matrix by returning an empty matrix.", "unit_test": "assert sort_matrix([]) == []"}, "Functionality Extension": {"requirement": "Extend the function to handle matrices with rows of varying lengths by treating missing values as zeros.", "unit_test": "assert sort_matrix([[1, 2, 3], [4, 5], [6]]) == [[6], [4, 5], [1, 2, 3]]"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type, including parameters: 'matrix': 'list[list[int]]', and a return type: 'list[list[int]]'.", "unit_test": "def test_annotations():\n    from typing import get_type_hints\n    hints = get_type_hints(sort_matrix)\n    assert hints == {'matrix': 'list[list[int]]', 'return': 'list[list[int]]'}\ntest_annotations()"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper indentation, spacing, and naming conventions.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    code_string = inspect.getsource(function_name)\n    with open(filename, \"w\") as file:\n        file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=True)\n        result = style.check_files([filename])\n        if result.total_errors > 0:\n            print(f\"PEP 8 violations found: {result.total_errors} errors.\")\n        if result.total_errors > 0:\n            print(f\"PEP 8 violations found: {result.total_errors} errors.\")\n        os.remove(filename)\n    assert result.total_errors == 0\ncheck_code_style(sort_matrix)"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Functionality Extension", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a function called 'count_common' to count the most common words in a dictionary.", "test": ["assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]", "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]", "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"], "code": "from collections import Counter\r\ndef count_common(words):\r\n  word_counts = Counter(words)\r\n  top_four = word_counts.most_common(4)\r\n  return (top_four)\r\n", "task_id": 13, "requirements": {"Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a list of strings.", "unit_test": "try: count_common('not a list')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'\ntry: count_common([123, 'word'])\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"}, "Edge Case Handling": {"requirement": "The function should handle an empty list input by returning an empty list.", "unit_test": "assert count_common([]) == []"}, "Functionality Extension": {"requirement": "Extend the function to allow an optional parameter that specifies the number of top frequent words to return.", "unit_test": "assert count_common(['apple', 'banana', 'apple', 'orange', 'banana', 'banana'], 2) == [('banana', 3), ('apple', 2)]"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type, including parameters: 'words': list, and a return type: list.", "unit_test": "assert count_common.__annotations__ == {'words': list, 'return': list}"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage"]}
{"prompt": "Write a python function called 'find_volume' to find the volume of a triangular prism.", "test": ["assert find_volume(10,8,6) == 240", "assert find_volume(3,2,2) == 6", "assert find_volume(1,2,1) == 1"], "code": "def find_volume(l,b,h) : \r\n    return ((l * b * h) / 2) ", "task_id": 14, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept three positive numerical inputs representing the base area, height, and length of the triangular prism, and return a positive numerical output representing the volume.The inputs can be either integers or floating-point numbers.", "unit_test": ["assert find_volume(5.5, 3.2, 4.1) == 72.16", "assert find_volume(7, 2, 3) == 42"]}, "Exception Handling": {"requirement": "The function should raise a ValueError with error message 'All dimensions must be positive numbers.' if any of the inputs are non-positive or non-numeric.", "unit_test": ["try: find_volume(-1, 2, 3)\nexcept ValueError as e: assert str(e) == 'All dimensions must be positive numbers.'\nelse: assert False, 'TypeError not raised'", "try: find_volume('a', 2, 3)\nexcept ValueError as e: assert str(e) == 'All dimensions must be positive numbers.'\nelse: assert False, 'TypeError not raised'"]}, "Edge Case Handling": {"requirement": "The function should correctly handle edge cases where one or more dimensions are at their minimum positive value.", "unit_test": ["assert find_volume(0.0001, 0.0001, 0.0001) == 5e-13", "assert find_volume(1, 1, 1) == 0.5"]}, "Functionality Extension": {"requirement": "Extend the function to handle inputs as a list or tuple of three elements, representing the base area, height, and length.", "unit_test": ["assert find_volume([10, 8, 6]) == 240", "assert find_volume((3, 2, 2)) == 6"]}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type, including three parameters: 'base_area': float, 'height': float, 'length': float, and a return type: float, and have a docstring explaining its purpose and usage: 'Calculate the volume of a triangular prism.'", "unit_test": ["assert find_volume.__annotations__ == {'base_area': float, 'height': float, 'length': float, 'return': float}", "assert 'Calculate the volume of a triangular prism' in find_volume.__doc__"]}, "Code Complexity": {"requirement": "The function should maintain a cyclomatic complexity of 1, indicating a straightforward calculation without any branching.", "unit_test": ["from mccabe import get_code_complexity\nimport inspect\nsource_code = inspect.getsource(find_volume)\nassert get_code_complexity(source_code) <= 1"]}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": ["import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_volume)"]}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function called 'split_lowerstring' to split a string at lowercase letters.", "test": ["assert split_lowerstring(\"AbCd\")==['bC','d']", "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']", "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"], "code": "import re\r\ndef split_lowerstring(text):\r\n return (re.findall('[a-z][^a-z]*', text))", "task_id": 15, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept a single string input and return a list of strings, each representing a segment of the original string split at lowercase letters.", "unit_test": "assert isinstance(split_lowerstring('Test'), list) and all(isinstance(i, str) for i in split_lowerstring('Test'))"}, "Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a string.", "unit_test": "try: split_lowerstring(123); assert False, 'Expected TypeError' except TypeError: pass"}, "Edge Case Handling": {"requirement": "The function should return an empty list if the input string contains no lowercase letters.", "unit_test": "assert split_lowerstring('ABC') == []"}, "Functionality Extension": {"requirement": "Extend the function to optionally include the uppercase letters at the start of each segment in the output list when include_lower = True", "unit_test": "assert split_lowerstring('AbCd', include_lower=True) == ['Ab', 'Cd']"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type, including parameters: 'text': str, and a return type: list.", "unit_test": "assert 'def split_lowerstring(text: str) -> list:' in inspect.getsource(split_lowerstring)"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a single path through the code.", "unit_test": "from mccabe import get_code_complexity\nimport inspect\nsource_code = inspect.getsource(split_lowerstring)\nassert get_code_complexity(source_code) <= 1"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper indentation and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(split_lowerstring)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function called 'text_lowercase_underscore' to find sequences of lowercase letters joined with an underscore.", "test": ["assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')", "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')", "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"], "code": "import re\r\ndef text_lowercase_underscore(text):\r\n        patterns = '^[a-z]+_[a-z]+$'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')", "task_id": 16, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept a string as input and return a string as output, specifically 'Found a match!' or 'Not matched!'.", "unit_test": "assert isinstance(text_lowercase_underscore('abc_def'), str)"}, "Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a string.", "unit_test": "try:\n    text_lowercase_underscore(123)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for non-string input'"}, "Edge Case Handling": {"requirement": "The function should correctly handle an empty string input by returning 'Not matched!'.", "unit_test": "assert text_lowercase_underscore('') == 'Not matched!'"}, "Functionality Extension": {"requirement": "Extend the function to handle multiple sequences separated by underscores and return 'Found a match!' if at least one sequence matches.", "unit_test": "assert text_lowercase_underscore('abc_def_ghi') == 'Found a match!'"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type, including parameters: 'text': str, and a return type: str.", "unit_test": "assert text_lowercase_underscore.__annotations__ == {'text': str, 'return': str}"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a single decision point.", "unit_test": "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(text_lowercase_underscore))[0].complexity == 1"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper indentation and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(text_lowercase_underscore)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function named 'square_perimeter' to find the perimeter of a square.", "test": ["assert square_perimeter(10)==40", "assert square_perimeter(5)==20", "assert square_perimeter(4)==16"], "code": "def square_perimeter(a):\r\n  perimeter=4*a\r\n  return perimeter", "task_id": 17, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept only non-negative integers as input and return a non-negative integer as output.", "unit_test": "assert square_perimeter(0) == 0\nassert square_perimeter(15) == 60\ntry:\n    square_perimeter(-5)\nexcept ValueError:\n    pass\nelse:\n    assert False, 'Expected ValueError for negative input'"}, "Exception Handling": {"requirement": "The function should raise a ValueError if the input is negative.", "unit_test": "try:\n    square_perimeter(-1)\nexcept ValueError:\n    pass\nelse:\n    assert False, 'Expected ValueError for negative input'"}, "Edge Case Handling": {"requirement": "The function should correctly handle the edge case where the side length is zero.", "unit_test": "assert square_perimeter(0) == 0"}, "Functionality Extension": {"requirement": "Extend the function to handle floating-point numbers by rounding them to the nearest integer using the standard rounding rule before calculating the perimeter.", "unit_test": "assert square_perimeter(4.5) == 20\nassert square_perimeter(3.7) == 16"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type, including parameters: 'a': int, and a return type: int.", "unit_test": "assert square_perimeter.__annotations__ == {'a': int, 'return': int}"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a single path through the code.", "unit_test": "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(square_perimeter))[0].complexity == 1"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(square_perimeter)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function called 'remove_dirty_chars' to remove characters from the first string which are present in the second string.", "test": ["assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'", "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'", "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "], "code": "NO_OF_CHARS = 256\r\ndef str_to_list(string): \r\n\ttemp = [] \r\n\tfor x in string: \r\n\t\ttemp.append(x) \r\n\treturn temp \r\ndef lst_to_string(List): \r\n\treturn ''.join(List) \r\ndef get_char_count_array(string): \r\n\tcount = [0] * NO_OF_CHARS \r\n\tfor i in string: \r\n\t\tcount[ord(i)] += 1\r\n\treturn count \r\ndef remove_dirty_chars(string, second_string): \r\n\tcount = get_char_count_array(second_string) \r\n\tip_ind = 0\r\n\tres_ind = 0\r\n\ttemp = '' \r\n\tstr_list = str_to_list(string) \r\n\twhile ip_ind != len(str_list): \r\n\t\ttemp = str_list[ip_ind] \r\n\t\tif count[ord(temp)] == 0: \r\n\t\t\tstr_list[res_ind] = str_list[ip_ind] \r\n\t\t\tres_ind += 1\r\n\t\tip_ind+=1\r\n\treturn lst_to_string(str_list[0:res_ind]) ", "task_id": 18, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept two strings as input and return a string as output. The input strings should only contain alphabetic characters. If the input strings contain non-alphabetic characters, the function should raise a ValueError, and an assertion error should occur with the message: 'Input strings must only contain alphabetic characters.'", "unit_test": ["assert remove_dirty_chars('hello', 'world') == 'he', 'The function did not return the expected output for valid inputs.'", "try: remove_dirty_chars('hell0', 'world')\nexcept ValueError as e: assert str(e) == 'Input strings must only contain alphabetic characters.'"]}, "Exception Handling": {"requirement": "The function should raise a TypeError if either of the inputs is not a string.", "unit_test": "try:\n    remove_dirty_chars(123, 'abc')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for non-string input'"}, "Edge Case Handling": {"requirement": "The function should return the original string if the second string is empty.", "unit_test": "assert remove_dirty_chars('example', '') == 'example', 'Function should return the original string if the second string is empty.'"}, "Functionality Extension": {"requirement": "The function should be extended to handle case-insensitive character removal.", "unit_test": "assert remove_dirty_chars('HelloWorld', 'hELLO') == 'World', 'Function should handle case-insensitive character removal.'"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type.The parameters should be annotated as 'string': str and 'second_string': str, and the return type is str.", "unit_test": "assert remove_dirty_chars.__annotations__ == {'string': str, 'second_string': str, 'return': str}, 'Function should have correct type annotations.'"}, "Code Standard": {"requirement": "The function should follow PEP 8 style guidelines, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(remove_dirty_chars)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a function named 'test_duplicate' to find whether a given array of integers contains any duplicate element.", "test": ["assert test_duplicate(([1,2,3,4,5]))==False", "assert test_duplicate(([1,2,3,4, 4]))==True", "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"], "code": "def test_duplicate(arraynums):\r\n    nums_set = set(arraynums)    \r\n    return len(arraynums) != len(nums_set)     ", "task_id": 19, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept a list of integers and return a boolean indicating the presence of duplicates. It should raise a TypeError if the input is not a list.", "unit_test": ["assert test_duplicate([1, 2, 3, 4, 5]) == False", "assert test_duplicate([1, 2, 3, 4, 4]) == True", "assert test_duplicate([1, 1, 2, 2, 3, 3, 4, 4, 5]) == True", "try:\n    test_duplicate('12345')\n    assert False, 'TypeError not raised'\nexcept TypeError:\n    pass"]}, "Exception Handling": {"requirement": "The function should handle exceptions gracefully and raise a ValueError with the message 'Input must be a list of integers' if the input is not a list.", "unit_test": ["try:\n    test_duplicate(None)\n    assert False, 'TypeError not raised'\nexcept TypeError as e:\n    assert str(e) == 'Input must be a list of integers'"]}, "Edge Case Handling": {"requirement": "The function should correctly handle edge cases such as an empty list and a list with one element.", "unit_test": ["assert test_duplicate([]) == False", "assert test_duplicate([1]) == False"]}, "Functionality Extension": {"requirement": "Extend the function to return the list of duplicate elements if any are found, otherwise return an empty list.", "unit_test": ["assert test_duplicate([1, 2, 3, 4, 5]) == []", "assert test_duplicate([1, 2, 3, 4, 4]) == [4]", "assert test_duplicate([1, 1, 2, 2, 3, 3, 4, 4, 5]) == [1, 2, 3, 4]"]}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'arraynums': list, and the return type should be annotated as bool.", "unit_test": ["assert test_duplicate.__annotations__ == {'arraynums': list, 'return': bool}"]}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": ["import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(test_duplicate)"]}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a function called 'is_woodall' to check if the given number is woodball or not.", "test": ["assert is_woodall(383) == True", "assert is_woodall(254) == False", "assert is_woodall(200) == False"], "code": "def is_woodall(x): \r\n\tif (x % 2 == 0): \r\n\t\treturn False\r\n\tif (x == 1): \r\n\t\treturn True\r\n\tx = x + 1 \r\n\tp = 0\r\n\twhile (x % 2 == 0): \r\n\t\tx = x/2\r\n\t\tp = p + 1\r\n\t\tif (p == x): \r\n\t\t\treturn True\r\n\treturn False", "task_id": 20, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept an integer as input and return a boolean indicating whether the number is a Woodall number.", "unit_test": ["assert isinstance(is_woodall(383), bool)", "assert isinstance(is_woodall(254), bool)"]}, "Exception Handling": {"requirement": "The function should raise a TypeError if the input is not an integer.", "unit_test": ["try: is_woodall('383')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'", "try: is_woodall(3.83)\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"]}, "Edge Case Handling": {"requirement": "The function should correctly handle edge cases such as very large integers and zero.", "unit_test": ["assert is_woodall(0) == False", "assert is_woodall(1) == True", "assert is_woodall(999999999999) == False"]}, "Functionality Extension": {"requirement": "Extend the function to return a list of all Woodall numbers up to a given number if the input is a positive integer.", "unit_test": ["assert is_woodall(10) == [1, 7]", "assert is_woodall(15) == [1, 7, 15]"]}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'x': int, and the return type should be annotated as bool.", "unit_test": ["assert is_woodall.__annotations__ == {'x': int, 'return': bool}"]}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a simple, linear function.", "unit_test": ["import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(is_woodall))[0].complexity == 1"]}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": ["import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(is_woodall)"]}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function named 'multiples_of_num' to find m number of multiples of n.", "test": ["assert multiples_of_num(4,3)== [3,6,9,12]", "assert multiples_of_num(2,5)== [5,10]", "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"], "code": "def multiples_of_num(m,n): \r\n    multiples_of_num= list(range(n,(m+1)*n, n)) \r\n    return list(multiples_of_num)", "task_id": 21, "requirements": {"Exception Handling": {"requirement": "The function should raise a ValueError if either m or n is negative.", "unit_test": ["try: multiples_of_num(-1, 5)\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError'", "try: multiples_of_num(3, -2)\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError'"]}, "Edge Case Handling": {"requirement": "The function should handle the edge case where m is zero, returning an empty list.", "unit_test": ["assert multiples_of_num(0, 5) == []", "assert multiples_of_num(0, 0) == []"]}, "Functionality Extension": {"requirement": "Extend the function to handle cases where n is a floating-point number, returning multiples as floating-point numbers.", "unit_test": ["assert multiples_of_num(3, 2.5) == [2.5, 5.0, 7.5]", "assert multiples_of_num(4, 1.1) == [1.1, 2.2, 3.3, 4.4]"]}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'm': int, 'n': int, and the return type should be annotated as list.", "unit_test": ["assert multiples_of_num.__annotations__ == {'m': int, 'n': int, 'return': list}"]}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a single path through the function.", "unit_test": ["import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(multiples_of_num))[0].complexity == 1"]}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": ["import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(multiples_of_num)"]}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function 'find_first_duplicate' to find the first duplicate element in a given array of integers.", "test": ["assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4", "assert find_first_duplicate([1, 2, 3, 4])==-1", "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"], "code": "def find_first_duplicate(nums):\r\n    num_set = set()\r\n    no_duplicate = -1\r\n\r\n    for i in range(len(nums)):\r\n\r\n        if nums[i] in num_set:\r\n            return nums[i]\r\n        else:\r\n            num_set.add(nums[i])\r\n\r\n    return no_duplicate", "task_id": 22, "requirements": {"Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a list of integers.", "unit_test": "try: find_first_duplicate('not a list')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"}, "Edge Case Handling": {"requirement": "The function should handle an empty list by returning -1.", "unit_test": "assert find_first_duplicate([]) == -1"}, "Functionality Extension": {"requirement": "Extend the function to return a list of all duplicate elements in the order they first appear, or an empty list if there are no duplicates.", "unit_test": "assert find_first_duplicate([1, 2, 3, 2, 4, 5, 4]) == [2, 4]"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'nums': list, and the return type should be annotated as int.", "unit_test": "assert find_first_duplicate.__annotations__ == {'nums': list, 'return': int}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 style guidelines, including proper indentation and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_first_duplicate)"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a python function named 'maximum_sum' to find the maximum sum of elements of list in a list of lists.", "test": ["assert maximum_sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33", "assert maximum_sum([[0,1,1],[1,1,2],[3,2,1]]) == 6", "assert maximum_sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"], "code": "def maximum_sum(list1): \r\n    maxi = -100000\r\n    for x in list1: \r\n        sum = 0 \r\n        for y in x: \r\n            sum+= y      \r\n        maxi = max(sum,maxi)     \r\n    return maxi ", "task_id": 23, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept a list of lists containing integers and return an integer representing the maximum sum of elements from any sublist.", "unit_test": "assert isinstance(maximum_sum([[1, 2], [3, 4]]), int)"}, "Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a list of lists or if any sublist contains non-integer elements.", "unit_test": ["try:\n    maximum_sum([[1, 2], [3, 'a']])\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass", "try:\n    maximum_sum(123)\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass"]}, "Edge Case Handling": {"requirement": "The function should return 0 if the input list is empty or if all sublists are empty.", "unit_test": "assert maximum_sum([]) == 0\nassert maximum_sum([[], [], []]) == 0"}, "Functionality Extension": {"requirement": "Extend the function to handle negative integers and ensure it returns the maximum sum correctly.", "unit_test": "assert maximum_sum([[-1, -2, -3], [-4, -5, -6], [-10, -11, -12], [-7, -8, -9]]) == -6"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'list1': list[list[int]], and the return type should be annotated as int.", "unit_test": "assert maximum_sum.__annotations__ == {'list1': 'list[list[int]]', 'return': 'int'}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(maximum_sum)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a function called 'binary_to_decimal' to convert the given binary number to its decimal equivalent.", "test": ["assert binary_to_decimal(100) == 4", "assert binary_to_decimal(1011) == 11", "assert binary_to_decimal(1101101) == 109"], "code": "def binary_to_decimal(binary): \r\n    binary1 = binary \r\n    decimal, i, n = 0, 0, 0\r\n    while(binary != 0): \r\n        dec = binary % 10\r\n        decimal = decimal + dec * pow(2, i) \r\n        binary = binary//10\r\n        i += 1\r\n    return (decimal)", "task_id": 24, "requirements": {"Exception Handling": {"requirement": "The function should raise a ValueError with a descriptive error message as 'Invalid binary number' if the input is not a valid binary string.", "unit_test": ["try:\n    binary_to_decimal('102')\n    assert False, 'Expected ValueError'\nexcept ValueError as e:\n    assert str(e) == 'Invalid binary number'", "try:\n    binary_to_decimal('abc')\n    assert False, 'Expected ValueError'\nexcept ValueError as e:\n    assert str(e) == 'Invalid binary number'"]}, "Edge Case Handling": {"requirement": "The function should correctly handle the edge case of an empty string by returning 0.", "unit_test": ["assert binary_to_decimal('') == 0"]}, "Functionality Extension": {"requirement": "Extend the function to handle binary numbers with leading zeros correctly.", "unit_test": ["assert binary_to_decimal('000100') == 4", "assert binary_to_decimal('0000') == 0"]}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'binary': str, and the return type should be annotated as int.", "unit_test": ["assert 'def binary_to_decimal(binary: str) -> int' in inspect.getsource(binary_to_decimal)"]}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a single path through the code.", "unit_test": ["import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(binary_to_decimal))[0].complexity == 1"]}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": ["import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(binary_to_decimal)"]}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a python function called 'find_product' to find the product of non-repeated elements in a given array.", "test": ["assert find_product([1,1,2,3],4) == 6", "assert find_product([1,2,3,1,1],5) == 6", "assert find_product([1,1,4,5,6],5) == 120"], "code": "def find_product(arr,n): \r\n    arr.sort() \r\n    prod = 1\r\n    for i in range(0,n,1): \r\n        if (arr[i - 1] != arr[i]): \r\n            prod = prod * arr[i] \r\n    return prod; ", "task_id": 25, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept a list of integers as input and return an integer as output, representing the product of non-repeated elements.", "unit_test": "assert isinstance(find_product([1, 2, 3], 3), int)"}, "Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a list of integers.", "unit_test": "try: find_product('not a list', 3)\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"}, "Edge Case Handling": {"requirement": "The function should return 1 if the input list is empty, as there are no elements to multiply.", "unit_test": "assert find_product([], 0) == 1"}, "Functionality Extension": {"requirement": "Extend the function to handle negative numbers correctly, ensuring the product is calculated accurately.", "unit_test": "assert find_product([-1, -2, 3, 3], 4) == 2"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'arr': list, 'n': int, and the return type should be annotated as int.", "unit_test": "assert find_product.__annotations__ == {'arr': list, 'n': int, 'return': int}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_product)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a function 'check_k_elements' to check if the given tuple list has all k elements.", "test": ["assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True", "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True", "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"], "code": "def check_k_elements(test_list, K):\r\n  res = True\r\n  for tup in test_list:\r\n    for ele in tup:\r\n      if ele != K:\r\n        res = False\r\n  return (res) ", "task_id": 26, "requirements": {"Input-Output Conditions": {"requirement": "The function should return a boolean value indicating whether all tuples in the list contain exactly k elements.", "unit_test": "assert isinstance(check_k_elements([(1, 2), (3, 4)], 2), bool)"}, "Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a list of tuples or if k is not an integer.", "unit_test": "try:\n    check_k_elements('not a tuple list', 2)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    check_k_elements([(1, 2), (3, 4)], 'not an integer')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"}, "Edge Case Handling": {"requirement": "The function should handle edge cases such as an empty list or tuples with zero elements.", "unit_test": "assert check_k_elements([], 0) == True\nassert check_k_elements([()], 0) == True"}, "Functionality Extension": {"requirement": "Extend the function to return the count of tuples that have exactly k elements.", "unit_test": "assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == 1"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'test_list': list[tuple], 'K': int, and the return type should be annotated as bool.", "unit_test": "assert check_k_elements.__annotations__ == {'test_list': list[tuple], 'K': int, 'return': bool}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(check_k_elements)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a python function named 'remove' to remove all digits from a list of strings.", "test": ["assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']", "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']", "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"], "code": "import re  \r\ndef remove(list): \r\n    pattern = '[0-9]'\r\n    list = [re.sub(pattern, '', i) for i in list] \r\n    return list", "task_id": 27, "requirements": {"Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a list or if any element in the list is not a string.", "unit_test": "try:\n    remove('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    remove([123, 'valid', 456])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"}, "Edge Case Handling": {"requirement": "The function should handle edge cases such as an empty list or strings with no digits gracefully.", "unit_test": "assert remove([]) == []\nassert remove(['no digits here']) == ['no digits here']"}, "Functionality Extension": {"requirement": "Extend the function to include an additional parameter specifying other characters to be removed, in addition to digits.", "unit_test": "assert remove_extended(['abcd123', '456defg'], 'abcdef') == ['d', 'g']"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'list': list[str], and the return type should be annotated as list[str].", "unit_test": "assert remove.__annotations__ == {'list': list[str], 'return': list[str]}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(remove)"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a python function called 'binomial_coeff' to find binomial co-efficient.", "test": ["assert binomial_coeff(5,2) == 10", "assert binomial_coeff(4,3) == 4", "assert binomial_coeff(3,2) == 3"], "code": "def binomial_coeff(n,k): \r\n    if k > n : \r\n       return 0\r\n    if k==0 or k ==n : \r\n        return 1 \r\n    return binomial_coeff(n-1,k-1) + binomial_coeff(n-1,k) ", "task_id": 28, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept two non-negative integer inputs n and k, and return an integer output representing the binomial coefficient.", "unit_test": "assert isinstance(binomial_coeff(5, 2), int)"}, "Exception Handling": {"requirement": "The function should raise a ValueError with a descriptive message as 'Inputs must be non-negative and k must not be greater than n' if either input is negative or if k is greater than n.", "unit_test": "try: binomial_coeff(-1, 2)\nexcept ValueError as e: assert str(e) == 'Inputs must be non-negative and k must not be greater than n'"}, "Edge Case Handling": {"requirement": "The function should correctly handle edge cases such as when n or k is 0, or when n equals k.", "unit_test": "assert binomial_coeff(0, 0) == 1\nassert binomial_coeff(5, 0) == 1\nassert binomial_coeff(5, 5) == 1"}, "Functionality Extension": {"requirement": "Extend the function to handle large values of n and k efficiently using memoization or iterative approach.", "unit_test": "assert binomial_coeff(100, 50) == 100891344545564193334812497256"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, 'k': int, and the return type should be annotated as int.", "unit_test": "assert binomial_coeff.__annotations__ == {'n': int, 'k': int, 'return': int}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(binomial_coeff)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a python function 'get_odd_occurrence' to find the element occurring odd number of times.", "test": ["assert get_odd_occurrence([1,2,3,1,2,3,1],7) == 1", "assert get_odd_occurrence([1,2,3,2,3,1,3],7) == 3", "assert get_odd_occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"], "code": "def get_odd_occurrence(arr,arr_size):   \r\n    for i in range(0,arr_size): \r\n        count = 0\r\n        for j in range(0,arr_size): \r\n            if arr[i] == arr[j]: \r\n                count+=1     \r\n        if (count % 2 != 0): \r\n            return arr[i]     \r\n    return -1", "task_id": 29, "requirements": {"Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a list of integers.", "unit_test": "try:\n    get_odd_occurrence('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    get_odd_occurrence([1, 'two', 3])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"}, "Edge Case Handling": {"requirement": "The function should handle an empty list by returning None.", "unit_test": "assert get_odd_occurrence([]) is None"}, "Functionality Extension": {"requirement": "The function should be able to handle lists with multiple elements occurring an odd number of times and return a list of such elements. The parameter should be annotated as arr: list, arr_size: int, and the return type should be annotated as int.", "unit_test": "assert get_odd_occurrence([1, 2, 3, 1, 2, 3, 1, 3]) == [1, 3]"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type, including two parameters: 'arr': list, 'arr_size': int, and a return type: int.", "unit_test": "assert get_odd_occurrence.__annotations__ == {'arr': list, 'arr_size': int, 'return': int}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(get_odd_occurrence)"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a python function called 'count_substring_with_equal_ends' to count all the substrings starting and ending with same characters.", "test": ["assert count_substring_with_equal_ends(\"abc\") == 3", "assert count_substring_with_equal_ends(\"abcda\") == 6", "assert count_substring_with_equal_ends(\"ab\") == 2"], "code": "def check_equality(s): \r\n    return (ord(s[0]) == ord(s[len(s) - 1])); \r\ndef count_substring_with_equal_ends(s): \r\n    result = 0; \r\n    n = len(s); \r\n    for i in range(n): \r\n        for j in range(1,n-i+1):  \r\n            if (check_equality(s[i:i+j])): \r\n                result+=1; \r\n    return result; ", "task_id": 30, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept a string input and return an integer representing the count of substrings starting and ending with the same character.", "unit_test": "assert isinstance(count_substring_with_equal_ends('abc'), int)"}, "Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a string.", "unit_test": "try: count_substring_with_equal_ends(123)\n    assert False, 'Expected TypeError'\nexcept TypeError: pass"}, "Edge Case Handling": {"requirement": "The function should return 0 for an empty string input.", "unit_test": "assert count_substring_with_equal_ends('') == 0"}, "Functionality Extension": {"requirement": "Extend the function to handle strings with special characters and spaces, but only count alphabetic characters.", "unit_test": "assert count_substring_with_equal_ends('a b a') == 4"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 's': str, and the return type should be annotated as int.", "unit_test": "assert count_substring_with_equal_ends.__annotations__ == {'s': str, 'return': int}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(count_substring_with_equal_ends)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a function named 'func' to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.", "test": ["assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]", "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]", "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"], "code": "def func(nums, k):\r\n    import collections\r\n    d = collections.defaultdict(int)\r\n    for row in nums:\r\n        for i in row:\r\n            d[i] += 1\r\n    temp = []\r\n    import heapq\r\n    for key, v in d.items():\r\n        if len(temp) < k:\r\n            temp.append((v, key))\r\n            if len(temp) == k:\r\n                heapq.heapify(temp)\r\n        else:\r\n            if v > temp[0][0]:\r\n                heapq.heappop(temp)\r\n                heapq.heappush(temp, (v, key))\r\n    result = []\r\n    while temp:\r\n        v, key = heapq.heappop(temp)\r\n        result.append(key)\r\n    return result", "task_id": 31, "requirements": {"Exception Handling": {"requirement": "The function should raise a ValueError as 'k cannot be greater than the number of distinct integers' if k is greater than the total number of distinct integers across all lists.", "unit_test": "try:\n    func([[1, 2], [3, 4]], 5)\nexcept ValueError as e:\n    assert str(e) == 'k cannot be greater than the number of distinct integers'"}, "Edge Case Handling": {"requirement": "The function should return an empty list if all input lists are empty.", "unit_test": "assert func([[], [], []], 0) == []"}, "Functionality Extension": {"requirement": "Extend the function to handle cases where k is zero, returning an empty list.", "unit_test": "assert func([[1, 2, 3], [4, 5, 6]], 0) == []"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'nums': List[List[int]], 'k': int, and the return type should be annotated as List[int].", "unit_test": "assert 'def func(nums: List[List[int]], k: int) -> List[int]:' in inspect.getsource(func)"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 style guidelines, including proper indentation and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(func)"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a python function called 'max_prime_factors' to find the largest prime factor of a given number.", "test": ["assert max_prime_factors(15) == 5", "assert max_prime_factors(6) == 3", "assert max_prime_factors(2) == 2"], "code": "import math \r\ndef max_prime_factors (n): \r\n    maxPrime = -1 \r\n    while n%2 == 0: \r\n        maxPrime = 2\r\n        n >>= 1    \r\n    for i in range(3,int(math.sqrt(n))+1,2): \r\n        while n % i == 0: \r\n            maxPrime = i \r\n            n = n / i \r\n    if n > 2: \r\n        maxPrime = n  \r\n    return int(maxPrime)", "task_id": 32, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept a positive integer as input and return the largest prime factor as an integer.", "unit_test": ["assert isinstance(max_prime_factors(15), int)"]}, "Exception Handling": {"requirement": "The function should raise a ValueError as 'Input must be a positive integer' with a descriptive error message if the input is not a positive integer.", "unit_test": ["try:\n    max_prime_factors(-10)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a positive integer'\ntry:\n    max_prime_factors(0)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a positive integer' "]}, "Edge Case Handling": {"requirement": "The function should correctly handle the smallest prime number, which is 2, and return 2 as its largest prime factor.", "unit_test": ["assert max_prime_factors(2) == 2"]}, "Functionality Extension": {"requirement": "Extend the function to return a list of prime factors of the given number. Add a parameter return_all (default value False). When return_all is True, return all the prime factors, otherwise return only the largest prime factor.", "unit_test": ["assert max_prime_factors(15, return_all=True) == [3, 5]", "assert max_prime_factors(6, return_all=True) == [2, 3]"]}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as int.", "unit_test": ["assert max_prime_factors.__annotations__ == {'n': int, 'return': int}"]}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 5 or less.", "unit_test": ["import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(max_prime_factors))[0].complexity <= 5"]}, "Code Standard": {"requirement": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.", "unit_test": ["import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(max_prime_factors)"]}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a python function called 'decimal_to_binary' to convert a decimal number to binary number.", "test": ["assert decimal_to_binary(10) == 1010", "assert decimal_to_binary(1) == 1", "assert decimal_to_binary(20) == 10100"], "code": "def decimal_to_binary(N): \r\n    B_Number = 0\r\n    cnt = 0\r\n    while (N != 0): \r\n        rem = N % 2\r\n        c = pow(10,cnt)  \r\n        B_Number += rem*c  \r\n        N //= 2 \r\n        cnt += 1\r\n    return B_Number  ", "task_id": 33, "requirements": {"Exception Handling": {"requirement": "The function should raise a ValueError if the input is not a non-negative integer.", "unit_test": ["try: decimal_to_binary(-1)\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError'", "try: decimal_to_binary('10')\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError'"]}, "Edge Case Handling": {"requirement": "The function should correctly handle the edge case where the input is zero.", "unit_test": ["assert decimal_to_binary(0) == '0'"]}, "Functionality Extension": {"requirement": "Extend the function to handle a list of decimal numbers, returning a list of binary strings.", "unit_test": ["assert decimal_to_binary([10, 1, 20]) == ['1010', '1', '10100']", "assert decimal_to_binary([0, 5]) == ['0', '101']"]}, "Annotation Coverage": {"requirement": "The function should include type annotations for input parameters and return type. The parameter should be annotated as 'N': int, and the return type should be annotated as str.", "unit_test": ["assert 'def decimal_to_binary(N: int) -> str:' in inspect.getsource(decimal_to_binary)"]}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a simple linear function.", "unit_test": ["import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(decimal_to_binary))[0].complexity == 1"]}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": ["import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(decimal_to_binary)"]}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a python function called 'find_missing' to find the missing number in a sorted array.", "test": ["assert find_missing([1,2,3,5],4) == 4", "assert find_missing([1,3,4,5],4) == 2", "assert find_missing([1,2,3,5,6,7],5) == 4"], "code": "def find_missing(ar,N): \r\n    l = 0\r\n    r = N - 1\r\n    while (l <= r):  \r\n        mid = (l + r) / 2\r\n        mid= int (mid) \r\n        if (ar[mid] != mid + 1 and ar[mid - 1] == mid): \r\n            return (mid + 1)  \r\n        elif (ar[mid] != mid + 1): \r\n            r = mid - 1 \r\n        else: \r\n            l = mid + 1\r\n    return (-1) ", "task_id": 34, "requirements": {"Exception Handling": {"requirement": "The function should raise a ValueError with a descriptive message as 'Input list must be sorted.' if the input list is not sorted.", "unit_test": "try:\n    find_missing([3,1,2,4], 4)\nexcept ValueError as e:\n    assert str(e) == 'Input list must be sorted.'"}, "Edge Case Handling": {"requirement": "The function should correctly handle the edge case where the missing number is the smallest number in the sequence.", "unit_test": "assert find_missing([2,3,4,5], 4) == 1"}, "Functionality Extension": {"requirement": "Extend the function to handle cases where multiple numbers are missing, returning a list of all missing numbers.", "unit_test": "assert find_missing([1,3,6], 3) == [2, 4, 5]"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'ar': list, 'N': int, and the return type should be annotated as int.", "unit_test": "assert find_missing.__annotations__ == {'ar': list, 'N': int, 'return': int}"}, "Code Standard": {"requirement": "The function should follow PEP 8 style guidelines, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_missing)"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a function called 'find_rect_num' to find the n-th rectangular number.", "test": ["assert find_rect_num(4) == 20", "assert find_rect_num(5) == 30", "assert find_rect_num(6) == 42"], "code": "def find_rect_num(n):\r\n  return n*(n + 1) ", "task_id": 35, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept a single integer input and return an integer output representing the n-th rectangular number.", "unit_test": "assert isinstance(find_rect_num(7), int)"}, "Exception Handling": {"requirement": "The function should raise a ValueError if the input is not a positive integer.", "unit_test": "try: find_rect_num(-1)\nexcept ValueError: pass\nelse: assert False, 'Expected ValueError for negative input'"}, "Edge Case Handling": {"requirement": "The function should correctly handle the edge case where n is 1, returning 2 as the first rectangular number.", "unit_test": "assert find_rect_num(1) == 2"}, "Functionality Extension": {"requirement": "Extend the function to handle a list of integers, returning a list of corresponding rectangular numbers.", "unit_test": "assert find_rect_num([1, 2, 3]) == [2, 6, 12]"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as int.", "unit_test": "assert find_rect_num.__annotations__ == {'n': int, 'return': int}"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a straightforward implementation without unnecessary branching.", "unit_test": "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(find_rect_num))[0].complexity == 1"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_rect_num)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a python function called 'find_nth_digit' to find the nth digit in the proper fraction of two given numbers.", "test": ["assert find_nth_digit(1,2,1) == 5", "assert find_nth_digit(3,5,1) == 6", "assert find_nth_digit(5,6,5) == 3"], "code": "def find_nth_digit(p,q,N) :  \r\n    while (N > 0) : \r\n        N -= 1;  \r\n        p *= 10;  \r\n        res = p // q;  \r\n        p %= q;  \r\n    return res;  ", "task_id": 36, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept two integers as input and return an integer representing the nth digit of the decimal representation of the fraction.", "unit_test": "assert isinstance(find_nth_digit(1, 2, 1), int)"}, "Exception Handling": {"requirement": "The function should raise a ValueError as 'Denominator cannot be zero' if the denominator is zero, as division by zero is undefined.", "unit_test": "try:\n    find_nth_digit(1, 0, 1)\nexcept ValueError as e:\n    assert str(e) == 'Denominator cannot be zero'"}, "Edge Case Handling": {"requirement": "The function should correctly handle the case where the numerator is zero, returning 0 for any nth digit.", "unit_test": "assert find_nth_digit(0, 5, 1) == 0"}, "Functionality Extension": {"requirement": "Extend the function to handle negative numerators and denominators, returning the nth digit of the absolute value of the fraction.", "unit_test": "assert find_nth_digit(-1, 2, 1) == 5"}, "Annotation Coverage": {"requirement": "The function should include type annotations for all parameters and the return type. The parameter should be annotated as 'p': int, 'q': int, 'N': int, and the return type should be annotated as int.", "unit_test": "assert find_nth_digit.__annotations__ == {'p': int, 'q': int, 'N': int, 'return': int}"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 5 or less to ensure maintainability.", "unit_test": "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(find_nth_digit))[0].complexity <= 5"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper indentation, naming conventions, and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_nth_digit)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function called 'sort_mixed_list' to sort a given mixed list of integers and strings.", "test": ["assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"], "code": "def sort_mixed_list(mixed_list):\r\n    int_part = sorted([i for i in mixed_list if type(i) is int])\r\n    str_part = sorted([i for i in mixed_list if type(i) is str])\r\n    return int_part + str_part", "task_id": 37, "requirements": {"Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a list or if the list contains elements that are neither integers nor strings.", "unit_test": "try:\n    sort_mixed_list('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'Expected TypeError'\n\ntry:\n    sort_mixed_list([1, 'apple', 3.5])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'Expected TypeError'"}, "Edge Case Handling": {"requirement": "The function should correctly handle an empty list by returning an empty list.", "unit_test": "assert sort_mixed_list([]) == []"}, "Functionality Extension": {"requirement": "Extend the function to optionally sort strings in reverse lexicographical order if a parameter 'reverse_strings' is set to True.", "unit_test": "assert sort_mixed_list([3, 'banana', 2, 'apple', 1, 'cherry'], reverse_strings=True) == [1, 2, 3, 'cherry', 'banana', 'apple']"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'mixed_list': list[Union[int, str]], and the return type should be annotated as list[Union[int, str]].", "unit_test": "from typing import Union\nassert sort_mixed_list.__annotations__ == {'mixed_list': list[Union[int, str]], 'return' : list}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(sort_mixed_list)"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a function called 'div_even_odd' to find the division of first even and odd number of a given list.", "test": ["assert div_even_odd([1,3,5,7,4,1,6,8])==4", "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2", "assert div_even_odd([1,5,7,9,10])==10"], "code": "def div_even_odd(list1):\r\n    first_even = next((el for el in list1 if el%2==0),-1)\r\n    first_odd = next((el for el in list1 if el%2!=0),-1)\r\n    return (first_even/first_odd)", "task_id": 38, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept a list of integers and return a float or integer representing the division of the first even number by the first odd number.", "unit_test": "assert isinstance(div_even_odd([2, 3, 4, 5]), (int, float))"}, "Exception Handling": {"requirement": "The function should raise a ValueError with a descriptive message as 'List must contain at least one even and one odd number.' if the list does not contain at least one even and one odd number.", "unit_test": "try:\n    div_even_odd([2, 4, 6])\n    assert False\nexcept ValueError as e: assert str(e) == 'List must contain at least one even and one odd number.'"}, "Edge Case Handling": {"requirement": "The function should correctly handle lists where the first even or odd number is zero, returning zero if the first even number is zero.", "unit_test": "assert div_even_odd([0, 1, 2, 3]) == 0"}, "Functionality Extension": {"requirement": "Extend the function to handle lists with negative numbers, correctly performing division with negative values.", "unit_test": "assert div_even_odd([-2, 3, 4, 5]) == -2 / 3"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type, including parameters: 'list1': list, and a return type: (int, float).", "unit_test": "assert div_even_odd.__annotations__ == {'list1': list, 'return': (int, float)}"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 3 or less.", "unit_test": "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(div_even_odd))[0].complexity == 1"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper indentation and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(div_even_odd)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function  called 'rearange_string' to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.", "test": ["assert rearange_string(\"aab\")==('aba')", "assert rearange_string(\"aabb\")==('abab')", "assert rearange_string(\"abccdd\")==('cdabcd')"], "code": "import heapq\r\nfrom collections import Counter\r\ndef rearange_string(S):\r\n    ctr = Counter(S)\r\n    heap = [(-value, key) for key, value in ctr.items()]\r\n    heapq.heapify(heap)\r\n    if (-heap[0][0]) * 2 > len(S) + 1: \r\n        return \"\"\r\n    ans = []\r\n    while len(heap) >= 2:\r\n        nct1, char1 = heapq.heappop(heap)\r\n        nct2, char2 = heapq.heappop(heap)\r\n        ans.extend([char1, char2])\r\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\r\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\r\n    return \"\".join(ans) + (heap[0][1] if heap else \"\")", "task_id": 39, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept a string as input and return a string where no two adjacent characters are the same. The input should be a non-empty string consisting only of lowercase letters.", "unit_test": "assert isinstance(rearange_string('abc'), str)\nassert rearange_string('') == ''"}, "Exception Handling": {"requirement": "The function should raise a ValueError if the input is not a string or if it contains characters other than lowercase letters.", "unit_test": "try:\n    rearange_string(123)\nexcept ValueError:\n    pass\nelse:\n    assert False\ntry:\n    rearange_string('abc123')\nexcept ValueError:\n    pass\nelse:\n    assert False"}, "Edge Case Handling": {"requirement": "The function should handle edge cases such as strings with all identical characters by returning an empty string, as rearrangement is not possible.", "unit_test": "assert rearange_string('aaaa') == ''\nassert rearange_string('') == ''"}, "Functionality Extension": {"requirement": "Extend the function to return all possible valid rearrangements if more than one exists.", "unit_test": "assert set(rearange_string('aabb')) == {'abab', 'baba'}"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type, including parameters: 'S': str, and a return type: str, and should have a docstring explaining its purpose and usage: 'Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.'", "unit_test": "assert rearange_string.__annotations__ == {'S': str, 'return': str}\nassert rearange_string.__doc__ == 'Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.'"}, "Code Standard": {"requirement": "The code should adhere to PEP 8 standards, including proper indentation, spacing, and naming conventions.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(rearange_string)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a function called 'freq_element' to find frequency of the elements in a given list of lists using collections module.", "test": ["assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})", "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})", "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"], "code": "from collections import Counter\r\nfrom itertools import chain\r\ndef freq_element(nums):\r\n  result = Counter(chain.from_iterable(nums))\r\n  return result", "task_id": 40, "requirements": {"Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a list of lists.", "unit_test": "try\n    freq_element('not a list')\n    assert False\nexcept TypeError: assert True"}, "Edge Case Handling": {"requirement": "The function should return an empty dictionary if the input is an empty list.", "unit_test": "assert freq_element([]) == {}"}, "Functionality Extension": {"requirement": "Extend the function to handle nested lists of arbitrary depth and return the frequency of all integers.", "unit_test": "assert freq_element([[1, [2, [3, 2]], 2], [4, 5, [6, 2]], [7, 1, [9, 5]]]) == {1: 2, 2: 4, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 9: 1}"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'nums': list[list[int]], and the return type should be annotated as dict[int, int].", "unit_test": "assert freq_element.__annotations__ == {'nums': 'list[list[int]]', 'return': 'dict[int, int]'}"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a single path through the code.", "unit_test": "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(freq_element))[0].complexity == 1"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper indentation and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(freq_element)"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function called 'filter_evennumbers' to filter even numbers using lambda function.", "test": ["assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[2, 4, 6, 8, 10]", "assert filter_evennumbers([10,20,45,67,84,93])==[10,20,84]", "assert filter_evennumbers([5,7,9,8,6,4,3])==[8,6,4]"], "code": "def filter_evennumbers(nums):\r\n even_nums = list(filter(lambda x: x%2 == 0, nums))\r\n return even_nums", "task_id": 41, "requirements": {"Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a list of integers.", "unit_test": "try: filter_evennumbers('not a list')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"}, "Edge Case Handling": {"requirement": "The function should return an empty list if the input list is empty.", "unit_test": "assert filter_evennumbers([]) == []"}, "Functionality Extension": {"requirement": "Extend the function to handle lists containing non-integer types by filtering them out before processing.", "unit_test": "assert filter_evennumbers([2, 'a', 4.5, 6, 'b']) == [2, 6]"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type, including parameters: 'nums': list, and a return type: list.", "unit_test": "assert filter_evennumbers.__annotations__ == {'nums': list, 'return': list}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(filter_evennumbers)"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a python function called 'find_sum' to find the sum of repeated elements in a given array.", "test": ["assert find_sum([1,2,3,1,1,4,5,6],8) == 3", "assert find_sum([1,2,3,1,1],5) == 3", "assert find_sum([1,1,2],3) == 2"], "code": "def find_sum(arr,n): \r\n    return sum([x for x in arr if arr.count(x) > 1])", "task_id": 42, "requirements": {"Input-Output Conditions": {"requirement": "The function should return 0 if there are no repeated elements in the array.", "unit_test": "assert find_sum([1, 2, 3, 4, 5], 5) == 0"}, "Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a list.", "unit_test": "try:\n    find_sum('not a list', 5)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"}, "Edge Case Handling": {"requirement": "The function should handle an empty array and return 0.", "unit_test": "assert find_sum([], 0) == 0"}, "Functionality Extension": {"requirement": "The function should be able to handle arrays with negative numbers and return the correct sum of repeated elements.", "unit_test": "assert find_sum([-1, -2, -3, -1, -1], 5) == -2"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'arr': list, 'n': int, and the return type should be annotated as int.", "unit_test": "assert 'def find_sum(arr: list, n: int) -> int:' in inspect.getsource(find_sum)"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 5 or less.", "unit_test": "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(find_sum))[0].complexity <=5"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 style guidelines.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_sum)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function called 'text_match' to find sequences of lowercase letters joined with an underscore using regex.", "test": ["assert text_match(\"aab_cbbbc\") == 'Found a match!'", "assert text_match(\"aab_Abbbc\") == 'Not matched!'", "assert text_match(\"Aaab_abbbc\") == 'Not matched!'"], "code": "import re\r\ndef text_match(text):\r\n  patterns = '^[a-z]+_[a-z]+$'\r\n  if re.search(patterns,  text):\r\n    return ('Found a match!')\r\n  else:\r\n    return ('Not matched!')", "task_id": 43, "requirements": {"Input-Output Conditions": {"requirement": "The function should return 'Not matched!' for any input that does not contain sequences of lowercase letters joined by an underscore.", "unit_test": "assert text_match('123_456') == 'Not matched!'"}, "Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a string.", "unit_test": "try:\n    text_match(12345)\nexcept TypeError:\n    assert True\nelse:\n    assert False"}, "Edge Case Handling": {"requirement": "The function should return 'Not matched!' for an empty string input.", "unit_test": "assert text_match('') == 'Not matched!'"}, "Functionality Extension": {"requirement": "Extend the function to handle sequences of lowercase letters joined by multiple underscores.", "unit_test": "assert text_match('abc_def_ghi') == 'Found a match!'"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'text': str, and the return type should be annotated as str.", "unit_test": "assert text_match.__annotations__ == {'text': str, 'return': str}"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a simple linear flow.", "unit_test": "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(text_match))[0].complexity ==1"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 style guidelines, including proper indentation and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(cc_visit)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function called 'text_match_string' that matches a word at the beginning of a string.", "test": ["assert text_match_string(\" python\")==('Not matched!')", "assert text_match_string(\"python\")==('Found a match!')", "assert text_match_string(\"  lang\")==('Not matched!')"], "code": "import re\r\ndef text_match_string(text):\r\n        patterns = '^\\w+'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return 'Not matched!'", "task_id": 44, "requirements": {"Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a string.", "unit_test": ["try: text_match_string(123); assert False, 'TypeError not raised' except TypeError: pass", "try: text_match_string(None); assert False, 'TypeError not raised' except TypeError: pass"]}, "Edge Case Handling": {"requirement": "The function should correctly handle edge cases such as an empty string or a string with only spaces.", "unit_test": ["assert text_match_string('') == 'Not matched!'", "assert text_match_string('   ') == 'Not matched!'"]}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'text': str, and the return type should be annotated as str.", "unit_test": ["assert text_match_string.__annotations__ == {'text': str, 'return': str}"]}, "Code Standard": {"requirement": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.", "unit_test": ["import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(text_match_string)"]}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a function called 'get_gcd' to find the gcd of the given array elements.", "test": ["assert get_gcd([2, 4, 6, 8, 16]) == 2", "assert get_gcd([1, 2, 3]) == 1", "assert get_gcd([2, 4, 6, 8]) == 2 "], "code": "def find_gcd(x, y): \r\n\twhile(y): \r\n\t\tx, y = y, x % y \r\n\treturn x \r\ndef get_gcd(l):\r\n  num1 = l[0]\r\n  num2 = l[1]\r\n  gcd = find_gcd(num1, num2)\r\n  for i in range(2, len(l)):\r\n    gcd = find_gcd(gcd, l[i])\r\n  return gcd", "task_id": 45, "requirements": {"Exception Handling": {"requirement": "The function should raise a ValueError with error message 'Input list cannot be empty.' if the input list is empty.", "unit_test": "try: get_gcd([])\nexcept ValueError as e: assert str(e) == 'Input list cannot be empty.'"}, "Functionality Extension": {"requirement": "Extend the function to handle lists containing zero, returning the GCD of the non-zero elements.", "unit_test": "assert get_gcd([0, 0, 6, 9]) == 3"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'numbers': list, and the return type should be annotated as int.", "unit_test": "assert get_gcd.__annotations__ == {'numbers': list, 'return': int}"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of no more than 5.", "unit_test": "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(get_gcd))[0].complexity <=1"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(get_gcd)"}}, "multi-turn": ["Exception Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a python function called 'test_distinct' to determine whether all the numbers are different from each other are not.", "test": ["assert test_distinct([1,5,7,9]) == True", "assert test_distinct([2,4,5,5,7,9]) == False", "assert test_distinct([1,2,3]) == True"], "code": "def test_distinct(data):\r\n  if len(data) == len(set(data)):\r\n    return True\r\n  else:\r\n    return False;", "task_id": 46, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept a list of integers as input and return a boolean indicating whether all numbers are distinct.", "unit_test": "assert test_distinct([1, 2, 3, 4]) == True\nassert test_distinct([1, 1, 2, 3]) == False"}, "Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a list or if the list contains non-integer elements.", "unit_test": "try:\n    test_distinct('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    test_distinct([1, 'a', 3])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"}, "Edge Case Handling": {"requirement": "The function should correctly handle edge cases such as an empty list or a list with a single element.", "unit_test": "assert test_distinct([]) == True\nassert test_distinct([42]) == True"}, "Functionality Extension": {"requirement": "Extend the function to handle lists of floating-point numbers and return whether all numbers are distinct.", "unit_test": "assert test_distinct([1.1, 2.2, 3.3]) == True\nassert test_distinct([1.1, 2.2, 2.2]) == False"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters called 'numbers' and return type. The parameter should be annotated as 'numbers': list, and the return type should be annotated as bool.", "unit_test": "assert test_distinct.__annotations__ == {'numbers': list, 'return': bool}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(test_distinct)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a python function called 'compute_last_digit' to find the last digit when factorial of a divides factorial of b.", "test": ["assert compute_last_digit(2,4) == 2", "assert compute_last_digit(6,8) == 6", "assert compute_last_digit(1,2) == 2"], "code": "def compute_last_digit(A,B): \r\n    variable = 1\r\n    if (A == B): \r\n        return 1\r\n    elif ((B - A) >= 5):  \r\n        return 0\r\n    else:   \r\n        for i in range(A + 1,B + 1): \r\n            variable = (variable * (i % 10)) % 10\r\n        return variable % 10", "task_id": 47, "requirements": {"Exception Handling": {"requirement": "The function should raise a ValueError with a descriptive message 'a should not be greater than b' if a is greater than b.", "unit_test": "try:\n    compute_last_digit(5, 3)\nexcept ValueError as e:\n    assert str(e) == 'a should not be greater than b'"}, "Edge Case Handling": {"requirement": "The function should correctly handle the edge case where a equals b, returning 1 since factorial(a) divided by factorial(b) is 1.", "unit_test": "assert compute_last_digit(5, 5) == 1"}, "Functionality Extension": {"requirement": "Extend the function to handle cases where a or b is zero, returning 1 since factorial(0) is 1.", "unit_test": "assert compute_last_digit(0, 5) == 1"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters 'a','b' and return type, indicating that both parameters are integers and the return type is an integer.", "unit_test": "assert compute_last_digit.__annotations__ == {'a': int, 'b': int, 'return': int}"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 3 or less, ensuring that the logic is straightforward and easy to follow.", "unit_test": "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(compute_last_digit))[0].complexity <=3"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity"]}
{"prompt": "Write a python function called 'odd_bit_set_number' to set all odd bits of a given number.", "test": ["assert odd_bit_set_number(10) == 15", "assert odd_bit_set_number(20) == 21", "assert odd_bit_set_number(30) == 31"], "code": "def odd_bit_set_number(n):\r\n    count = 0;res = 0;temp = n\r\n    while temp > 0:\r\n        if count % 2 == 0:\r\n            res |= (1 << count)\r\n        count += 1\r\n        temp >>= 1\r\n    return (n | res)", "task_id": 48, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept an integer as input and return an integer with all odd bits set.", "unit_test": "assert isinstance(odd_bit_set_number(10), int)"}, "Exception Handling": {"requirement": "The function should raise a TypeError if the input is not an integer.", "unit_test": "try: odd_bit_set_number('10')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"}, "Edge Case Handling": {"requirement": "The function should correctly handle the edge case where the input is 0, returning 1.", "unit_test": "assert odd_bit_set_number(0) == 1"}, "Functionality Extension": {"requirement": "Extend the function to handle negative integers by setting all odd bits in their absolute value.", "unit_test": "assert odd_bit_set_number(-10) == 15"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as int.", "unit_test": "assert odd_bit_set_number.__annotations__ == {'n': int, 'return': int}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(odd_bit_set_number)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a function called 'specified_element' to extract every first or specified element from a given two-dimensional list.", "test": ["assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],0)==[1, 4, 7]", "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],2)==[3, 6, 9]", "assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]],1)==[2,5,1]"], "code": "def specified_element(nums, N):\r\n    result = [i[N] for i in nums]\r\n    return result\r\n    ", "task_id": 49, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept a two-dimensional list and an integer index, returning a list of elements from each sublist at the specified index. The function should return an empty list if the input list is empty.", "unit_test": "assert specified_element([], 0) == []"}, "Exception Handling": {"requirement": "The function should raise an IndexError with a descriptive message 'Index out of range for sublist' if the specified index is out of range for any sublist.", "unit_test": "try: specified_element([[1, 2], [3, 4]], 3)\nexcept IndexError as e: assert str(e) == 'Index out of range for sublist'"}, "Edge Case Handling": {"requirement": "The function should handle cases where sublists are of varying lengths, extracting elements only from sublists where the index is valid.", "unit_test": "assert specified_element([[1, 2], [3], [4, 5, 6]], 1) == [2, 5]"}, "Functionality Extension": {"requirement": "Extend the function to allow negative indices, which should extract elements from the end of each sublist.", "unit_test": "assert specified_element([[1, 2, 3], [4, 5, 6], [7, 8, 9]], -1) == [3, 6, 9]"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper indentation, spacing, and naming conventions.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(specified_element)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Code Standard"]}
{"prompt": "Write a function called 'min_length_list' to find the list with minimum length using lambda function.", "test": ["assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])", "assert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1,[1])", "assert min_length_list([[3,4,5],[6,7,8,9],[10,11,12],[1,2]])==(2,[1,2])"], "code": "def min_length_list(input_list):\r\n    min_length = min(len(x) for x in input_list )  \r\n    min_list = min(input_list, key = lambda i: len(i))\r\n    return(min_length, min_list)", "task_id": 50, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept a list of lists and return a tuple containing the length of the shortest list and the list itself.", "unit_test": "assert min_length_list([[1, 2], [3, 4, 5], [6]]) == (1, [6])"}, "Exception Handling": {"requirement": "The function should raise a ValueError with a descriptive message 'Input must be a list of lists.' if the input is not a list of lists.", "unit_test": "try: min_length_list('not a list of lists')\nexcept ValueError as e: assert str(e) == 'Input must be a list of lists.'"}, "Edge Case Handling": {"requirement": "The function should correctly handle an edge case where all lists are of the same length, returning the first such list.", "unit_test": "assert min_length_list([[1, 2], [3, 4], [5, 6]]) == (2, [1, 2])"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'lists': list[list], and the return type should be annotated as tuple[int, list].", "unit_test": "assert min_length_list.__annotations__ == {'lists': 'list[list]', 'return': 'tuple[int, list]'}"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage"]}
{"prompt": "Write a function called 'check_equilateral' to print check if the triangle is equilateral or not.", "test": ["assert check_equilateral(6,8,12)==False ", "assert check_equilateral(6,6,12)==False", "assert check_equilateral(6,6,6)==True"], "code": "def check_equilateral(x,y,z):\r\n  if x == y == z:\r\n\t   return True\r\n  else:\r\n     return False", "task_id": 51, "requirements": {"Exception Handling": {"requirement": "The function should raise a ValueError if any of the inputs are non-positive integers.", "unit_test": "try:\n    check_equilateral(-1, 3, 3)\nexcept ValueError:\n    pass\nelse:\n    assert False, 'Expected ValueError'\n\ntry:\n    check_equilateral(0, 3, 3)\nexcept ValueError:\n    pass\nelse:\n    assert False, 'Expected ValueError'"}, "Edge Case Handling": {"requirement": "The function should correctly handle the case where all sides are zero, returning False.", "unit_test": "assert check_equilateral(0, 0, 0) == False"}, "Functionality Extension": {"requirement": "Extend the function to also check if the triangle is isosceles, returning 'isosceles' if true.", "unit_test": "assert check_equilateral(5, 5, 3) == 'isosceles'"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'a': int, 'b': int, 'c': int, and the return type should be annotated as bool.", "unit_test": "assert check_equilateral.__annotations__ == {'a': int, 'b': int, 'c': int, 'return': bool}"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a simple conditional check.", "unit_test": "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(check_equilateral))[0].complexity ==1"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper indentation and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(check_equilateral)"}}, "multi-turn": ["Exception Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function called 'parallelogram_area' to caluclate area of a parallelogram.", "test": ["assert parallelogram_area(10,20)==200", "assert parallelogram_area(15,20)==300", "assert parallelogram_area(8,9)==72"], "code": "def parallelogram_area(b,h):\r\n  area=b*h\r\n  return area", "task_id": 52, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept two positive numerical inputs representing the base and height of the parallelogram and return a positive numerical output representing the area.", "unit_test": ["assert parallelogram_area(5, 10) == 50", "assert parallelogram_area(0, 10) == 0", "assert parallelogram_area(10, 0) == 0", "assert parallelogram_area(0, 0) == 0"]}, "Exception Handling": {"requirement": "The function should raise a TypeError if the inputs are not numerical.", "unit_test": ["try:\n    parallelogram_area('10', 20)\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass", "try:\n    parallelogram_area(10, '20')\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass", "try:\n    parallelogram_area('10', '20')\n    assert False, 'Expected TypeError'\nexcept TypeError:\n    pass"]}, "Edge Case Handling": {"requirement": "The function should correctly handle edge cases where the base or height is zero, returning an area of zero.", "unit_test": ["assert parallelogram_area(0, 10) == 0", "assert parallelogram_area(10, 0) == 0", "assert parallelogram_area(0, 0) == 0"]}, "Functionality Extension": {"requirement": "Extend the function to accept a list of tuples where each tuple contains the base and height of a parallelogram, and return a list of areas.", "unit_test": ["assert parallelogram_area_list([(10, 20), (15, 20), (8, 9)]) == [200, 300, 72]", "assert parallelogram_area_list([(0, 10), (10, 0), (0, 0)]) == [0, 0, 0]"]}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'base': float, 'height': float, and the return type should be annotated as float.", "unit_test": ["assert parallelogram_area.__annotations__ == {'base': float, 'height': float, 'return': float}"]}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a simple, linear function.", "unit_test": ["import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(parallelogram_area))[0].complexity ==1"]}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": ["import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(parallelogram_area)"]}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a python function called 'check_equality' to check whether the first and last characters of a given string are equal or not.", "test": ["assert check_equality(\"abcda\") == \"Equal\"", "assert check_equality(\"ab\") == \"Not Equal\"", "assert check_equality(\"mad\") == \"Not Equal\""], "code": "def check_equality(str):\r\n  if (str[0] == str[-1]):  \r\n    return (\"Equal\") \r\n  else:  \r\n    return (\"Not Equal\") ", "task_id": 53, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept only strings as input and return 'Equal' if the first and last characters are the same, otherwise 'Not Equal'.", "unit_test": "assert check_equality('racecar') == 'Equal'\nassert check_equality('hello') == 'Not Equal'\nassert check_equality('a') == 'Equal'"}, "Exception Handling": {"requirement": "The function should raise a TypeError with a descriptive message as 'Input must be a string' if the input is not a string.", "unit_test": "try:\n    check_equality(123)\nexcept TypeError as e:\n    assert str(e) == 'Input must be a string'"}, "Edge Case Handling": {"requirement": "The function should correctly handle empty strings by returning 'Equal'.", "unit_test": "assert check_equality('') == 'Equal'"}, "Functionality Extension": {"requirement": "Extend the function to ignore case sensitivity when comparing the first and last characters.", "unit_test": "assert check_equality('Abca') == 'Equal'\nassert check_equality('AbC') == 'Not Equal'"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 's': str, and the return type should be annotated as str.", "unit_test": "assert check_equality.__annotations__ == {'s': str, 'return': str}"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a simple linear control flow.", "unit_test": "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(check_equality))[0].complexity <=3"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper indentation and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(check_equality)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function called 'counting_sort' to sort the given array by using counting sort.", "test": ["assert counting_sort([1,23,4,5,6,7,8]) == [1, 4, 5, 6, 7, 8, 23]", "assert counting_sort([12, 9, 28, 33, 69, 45]) == [9, 12, 28, 33, 45, 69]", "assert counting_sort([8, 4, 14, 3, 2, 1]) == [1, 2, 3, 4, 8, 14]"], "code": "def counting_sort(my_list):\r\n    max_value = 0\r\n    for i in range(len(my_list)):\r\n        if my_list[i] > max_value:\r\n            max_value = my_list[i]\r\n    buckets = [0] * (max_value + 1)\r\n    for i in my_list:\r\n        buckets[i] += 1\r\n    i = 0\r\n    for j in range(max_value + 1):\r\n         for a in range(buckets[j]):\r\n             my_list[i] = j\r\n             i += 1\r\n    return my_list", "task_id": 54, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept only a list of non-negative integers as input and return a sorted list of integers.", "unit_test": "assert counting_sort([0, 5, 3, 2, 2]) == [0, 2, 2, 3, 5]\nassert counting_sort([10, 0, 5, 5]) == [0, 5, 5, 10]"}, "Exception Handling": {"requirement": "The function should raise a TypeError if the input is not a list or contains non-integer elements.", "unit_test": "try:\n    counting_sort('not a list')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'\n\ntry:\n    counting_sort([1, 'a', 3])\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised'"}, "Edge Case Handling": {"requirement": "The function should correctly handle edge cases such as an empty list or a list with a single element.", "unit_test": "assert counting_sort([]) == []\nassert counting_sort([42]) == [42]"}, "Functionality Extension": {"requirement": "Extend the function to handle lists containing negative integers by sorting them correctly.", "unit_test": "assert counting_sort([-5, -1, -3, 0, 2, 1]) == [-5, -3, -1, 0, 1, 2]"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'arr': list, and the return type should be annotated as list.", "unit_test": "def test_annotations():\n    from typing import get_type_hints\n    hints = get_type_hints(counting_sort)\n    assert hints == {'arr': list, 'return': list}\ntest_annotations()"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(counting_sort)"}}, "multi-turn": ["Functionality Extension", "Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a function called 'tn_gp' to find t-nth term of geometric series.", "test": ["assert tn_gp(1,5,2)==16", "assert tn_gp(1,5,4)==256", "assert tn_gp(2,6,3)==486"], "code": "import math\r\ndef tn_gp(a,n,r):\r\n  tn = a * (math.pow(r, n - 1))\r\n  return tn", "task_id": 55, "requirements": {"Exception Handling": {"requirement": "The function should raise a ValueError with the message 'Term number must be greater than 0' if the term number (n) is less than 1, as it is not possible to have a non-positive term number in a geometric series.", "unit_test": "try:\n    tn_gp(1, 5, 0)\nexcept ValueError as e:\n    assert str(e) == 'Term number must be greater than 0'"}, "Edge Case Handling": {"requirement": "The function should correctly handle the edge case where the common ratio (r) is zero, returning zero for all terms beyond the first.", "unit_test": "assert tn_gp(3, 0, 5) == 0"}, "Functionality Extension": {"requirement": "Extend the function to handle floating-point numbers for the first term and common ratio, returning a floating-point number for the n-th term.", "unit_test": "assert tn_gp(1.5, 2.5, 3) == 9.375"}, "Annotation Coverage": {"requirement": "The function should include type annotations for all parameters and the return type to improve code readability and maintainability. The parameter should be annotated as 'a': int, 'r': int, 'n': int, and the return type should be annotated as int.", "unit_test": "assert tn_gp.__annotations__ == {'a': int, 'r': int, 'n': int, 'return': int}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper indentation, spacing, and naming conventions.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(tn_gp)"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a python function called 'check' to check if a given number is one less than twice its reverse.", "test": ["assert check(70) == False", "assert check(23) == False", "assert check(73) == True"], "code": "def rev(num):    \r\n    rev_num = 0\r\n    while (num > 0):  \r\n        rev_num = (rev_num * 10 + num % 10) \r\n        num = num // 10  \r\n    return rev_num  \r\ndef check(n):    \r\n    return (2 * rev(n) == n + 1)  ", "task_id": 56, "requirements": {"Exception Handling": {"requirement": "The function should raise a TypeError if the input is not an integer.", "unit_test": "try:\n    check('73')\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for non-integer input'"}, "Edge Case Handling": {"requirement": "The function should correctly handle edge cases such as single-digit numbers and zero.", "unit_test": "assert check(0) == False\nassert check(1) == False\nassert check(9) == False"}, "Functionality Extension": {"requirement": "Extend the function to handle negative numbers correctly, considering the reverse of a negative number as negative.", "unit_test": "assert check(-73) == False\nassert check(-37) == True"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as bool.", "unit_test": "assert check.__annotations__ == {'n': int, 'return': bool}"}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a simple, linear control flow.", "unit_test": "import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(check))[0].complexity <=3"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(check)"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a python function called 'find_max_num' to find the largest number that can be formed with the given digits.", "test": ["assert find_max_num([1,2,3],3) == 321", "assert find_max_num([4,5,6,1],4) == 6541", "assert find_max_num([1,2,3,9],4) == 9321"], "code": "def find_max_num(arr,n) : \r\n    arr.sort(reverse = True) \r\n    num = arr[0] \r\n    for i in range(1,n) : \r\n        num = num * 10 + arr[i] \r\n    return num ", "task_id": 57, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept a list of integers and an integer representing the number of digits, and return an integer representing the largest number that can be formed.", "unit_test": "assert find_max_num([7, 8, 9], 3) == 987"}, "Exception Handling": {"requirement": "The function should raise a ValueError with the message 'Number of digits exceeds the length of the list.' if the number of digits specified is greater than the length of the list of digits.", "unit_test": "try:\n    find_max_num([1, 2], 3)\nexcept ValueError as e:\n    assert str(e) == 'Number of digits exceeds the length of the list.'"}, "Edge Case Handling": {"requirement": "The function should correctly handle the edge case where the list of digits is empty, returning 0.", "unit_test": "assert find_max_num([], 0) == 0"}, "Functionality Extension": {"requirement": "Extend the function to handle a list of digits containing duplicate numbers, ensuring the largest number is still formed.", "unit_test": "assert find_max_num([1, 1, 2, 2], 4) == 2211"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'digits': list, 'n': int, and the return type should be annotated as int.", "unit_test": "assert find_max_num.__annotations__ == {'digits': list, 'n': int, 'return': int}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(find_max_num)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a python function called 'opposite_signs' to check whether the given two integers have opposite sign or not.", "test": ["assert opposite_signs(1,-2) == True", "assert opposite_signs(3,2) == False", "assert opposite_signs(-10,-10) == False"], "code": "def opposite_signs(x,y): \r\n    return ((x ^ y) < 0); ", "task_id": 58, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept only integer inputs and return a boolean value indicating whether the integers have opposite signs.", "unit_test": ["assert opposite_signs(5, -5) == True", "assert opposite_signs(0, 0) == False", "assert opposite_signs(-7, 7) == True"]}, "Exception Handling": {"requirement": "The function should raise a TypeError if the inputs are not integers.", "unit_test": ["try:\n    opposite_signs(1.5, -2)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for float input'", "try:\n    opposite_signs('a', 2)\nexcept TypeError:\n    pass\nelse:\n    assert False, 'TypeError not raised for string input'"]}, "Edge Case Handling": {"requirement": "The function should correctly handle edge cases such as zero and large integers.", "unit_test": ["assert opposite_signs(0, -1) == True", "assert opposite_signs(0, 1) == True", "assert opposite_signs(0, 0) == False", "assert opposite_signs(2147483647, -2147483648) == True"]}, "Functionality Extension": {"requirement": "Extend the function to handle a list of integer pairs and return a list of boolean values indicating opposite signs for each pair.", "unit_test": ["assert opposite_signs_list([(1, -2), (3, 2), (-10, -10)]) == [True, False, False]", "assert opposite_signs_list([(0, 0), (0, -1), (1, 1)]) == [False, True, False]"]}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'a': int, 'b': int, and the return type should be annotated as bool.", "unit_test": ["assert opposite_signs.__annotations__ == {'a': int, 'b': int, 'return': bool}"]}, "Code Complexity": {"requirement": "The function should have a cyclomatic complexity of 1, indicating a simple, linear control flow.", "unit_test": ["import inspect\nfrom radon.complexity import cc_visit\nassert cc_visit(inspect.getsource(opposite_signs))[0].complexity <=3"]}, "Code Standard": {"requirement": "The function should adhere to PEP 8 standards, including proper naming conventions and spacing.", "unit_test": ["import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(opposite_signs)"]}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Complexity", "Code Standard"]}
{"prompt": "Write a function called 'is_octagonal' to find the nth octagonal number.", "test": ["assert is_octagonal(5) == 65", "assert is_octagonal(10) == 280", "assert is_octagonal(15) == 645"], "code": "def is_octagonal(n): \r\n\treturn 3 * n * n - 2 * n ", "task_id": 59, "requirements": {"Exception Handling": {"requirement": "The function should raise a ValueError as 'Input must be a positive integer' if the input is not a positive integer.", "unit_test": "try:\n    is_octagonal(-1)\nexcept ValueError as e:\n    assert str(e) == 'Input must be a positive integer'"}, "Edge Case Handling": {"requirement": "The function should correctly handle the edge case where n is 1, returning the first octagonal number.", "unit_test": "assert is_octagonal(1) == 1"}, "Functionality Extension": {"requirement": "Extend the function to return a list of the first n octagonal numbers if n is a list.", "unit_test": "assert is_octagonal([1, 2, 3]) == [1, 8, 21]"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type. The parameter should be annotated as 'n': int, and the return type should be annotated as int.", "unit_test": "assert is_octagonal.__annotations__ == {'n': int, 'return': int}"}, "Code Standard": {"requirement": "The function should adhere to PEP 8 style guidelines, including proper naming conventions and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(is_octagonal)"}}, "multi-turn": ["Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
{"prompt": "Write a function called 'max_len_sub' to find the maximum length of the subsequence with difference between adjacent elements for the given array.", "test": ["assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5", "assert max_len_sub([-2, -1, 5, -1, 4, 0, 3], 7) == 4", "assert max_len_sub([9, 11, 13, 15, 18], 5) == 1"], "code": "def max_len_sub( arr, n): \r\n\tmls=[] \r\n\tmax = 0\r\n\tfor i in range(n): \r\n\t\tmls.append(1) \r\n\tfor i in range(n): \r\n\t\tfor j in range(i): \r\n\t\t\tif (abs(arr[i] - arr[j]) <= 1 and mls[i] < mls[j] + 1): \r\n\t\t\t\tmls[i] = mls[j] + 1\r\n\tfor i in range(n): \r\n\t\tif (max < mls[i]): \r\n\t\t\tmax = mls[i] \r\n\treturn max", "task_id": 60, "requirements": {"Input-Output Conditions": {"requirement": "The function should accept an array of integers and an integer as input, and return an integer representing the maximum length of the subsequence.", "unit_test": "assert isinstance(max_len_sub([1, 2, 3], 3), int)"}, "Exception Handling": {"requirement": "The function should raise a TypeError if the input array is not a list or if the second parameter is not an integer.", "unit_test": "try: max_len_sub('not a list', 3)\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'\ntry: max_len_sub([1, 2, 3], 'not an int')\nexcept TypeError: pass\nelse: assert False, 'TypeError not raised'"}, "Edge Case Handling": {"requirement": "The function should return 0 if the input array is empty, as there are no subsequences possible.", "unit_test": "assert max_len_sub([], 3) == 0"}, "Functionality Extension": {"requirement": "Extend the function to handle cases where the difference between adjacent elements can be negative, and still find the maximum length of the subsequence.", "unit_test": "assert max_len_sub([10, 7, 4, 1, -2], -3) == 5"}, "Annotation Coverage": {"requirement": "The function should include type annotations for its parameters and return type, indicating that it accepts a list of integers and an integer, and returns an integer.", "unit_test": "assert max_len_sub.__annotations__ == {'arr': list, 'diff': int, 'return': int}"}, "Code Standard": {"requirement": "The function should follow PEP 8 guidelines, including proper naming conventions, indentation, and spacing.", "unit_test": "import pycodestyle\nimport os\nimport inspect\ndef check_code_style(function_name, filename=\"temp.py\"):\n    try:\n        code_string = inspect.getsource(function_name)\n        with open(filename, \"w\") as file:\n            file.write(code_string)\n        style = pycodestyle.StyleGuide(quiet=False)\n        result = style.check_files([filename])\n        assert result.total_errors == 0, \"Code does not conform to PEP 8 standards.\"\n    finally:\n        if os.path.exists(filename):\n            os.remove(filename)\ncheck_code_style(max_len_sub)"}}, "multi-turn": ["Input-Output Conditions", "Exception Handling", "Edge Case Handling", "Annotation Coverage", "Code Standard"]}
